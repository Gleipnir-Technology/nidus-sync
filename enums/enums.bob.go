// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package enums

import (
	"database/sql/driver"
	"fmt"
)

// Enum values for Arcgislicensetype
const (
	ArcgislicensetypeAdvancedut             Arcgislicensetype = "advancedUT"
	ArcgislicensetypeBasicut                Arcgislicensetype = "basicUT"
	ArcgislicensetypeCreatorut              Arcgislicensetype = "creatorUT"
	ArcgislicensetypeEditorut               Arcgislicensetype = "editorUT"
	ArcgislicensetypeFieldworkerut          Arcgislicensetype = "fieldWorkerUT"
	ArcgislicensetypeGisprofessionaladvut   Arcgislicensetype = "GISProfessionalAdvUT"
	ArcgislicensetypeGisprofessionalbasicut Arcgislicensetype = "GISProfessionalBasicUT"
	ArcgislicensetypeGisprofessionalstdut   Arcgislicensetype = "GISProfessionalStdUT"
	ArcgislicensetypeIndoorsuserut          Arcgislicensetype = "IndoorsUserUT"
	ArcgislicensetypeInsightsanalystut      Arcgislicensetype = "insightsAnalystUT"
	ArcgislicensetypeLiteut                 Arcgislicensetype = "liteUT"
	ArcgislicensetypeStandardut             Arcgislicensetype = "standardUT"
	ArcgislicensetypeStorytellerut          Arcgislicensetype = "storytellerUT"
	ArcgislicensetypeViewerut               Arcgislicensetype = "viewerUT"
)

func AllArcgislicensetype() []Arcgislicensetype {
	return []Arcgislicensetype{
		ArcgislicensetypeAdvancedut,
		ArcgislicensetypeBasicut,
		ArcgislicensetypeCreatorut,
		ArcgislicensetypeEditorut,
		ArcgislicensetypeFieldworkerut,
		ArcgislicensetypeGisprofessionaladvut,
		ArcgislicensetypeGisprofessionalbasicut,
		ArcgislicensetypeGisprofessionalstdut,
		ArcgislicensetypeIndoorsuserut,
		ArcgislicensetypeInsightsanalystut,
		ArcgislicensetypeLiteut,
		ArcgislicensetypeStandardut,
		ArcgislicensetypeStorytellerut,
		ArcgislicensetypeViewerut,
	}
}

type Arcgislicensetype string

func (e Arcgislicensetype) String() string {
	return string(e)
}

func (e Arcgislicensetype) Valid() bool {
	switch e {
	case ArcgislicensetypeAdvancedut,
		ArcgislicensetypeBasicut,
		ArcgislicensetypeCreatorut,
		ArcgislicensetypeEditorut,
		ArcgislicensetypeFieldworkerut,
		ArcgislicensetypeGisprofessionaladvut,
		ArcgislicensetypeGisprofessionalbasicut,
		ArcgislicensetypeGisprofessionalstdut,
		ArcgislicensetypeIndoorsuserut,
		ArcgislicensetypeInsightsanalystut,
		ArcgislicensetypeLiteut,
		ArcgislicensetypeStandardut,
		ArcgislicensetypeStorytellerut,
		ArcgislicensetypeViewerut:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e Arcgislicensetype) All() []Arcgislicensetype {
	return AllArcgislicensetype()
}

func (e Arcgislicensetype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *Arcgislicensetype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e Arcgislicensetype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *Arcgislicensetype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e Arcgislicensetype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *Arcgislicensetype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = Arcgislicensetype(x)
	case []byte:
		*e = Arcgislicensetype(x)
	case nil:
		return fmt.Errorf("cannot nil into Arcgislicensetype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid Arcgislicensetype value: %s", *e)
	}

	return nil
}

// Enum values for H3aggregationtype
const (
	H3aggregationtypeMosquitosource H3aggregationtype = "MosquitoSource"
	H3aggregationtypeServicerequest H3aggregationtype = "ServiceRequest"
)

func AllH3aggregationtype() []H3aggregationtype {
	return []H3aggregationtype{
		H3aggregationtypeMosquitosource,
		H3aggregationtypeServicerequest,
	}
}

type H3aggregationtype string

func (e H3aggregationtype) String() string {
	return string(e)
}

func (e H3aggregationtype) Valid() bool {
	switch e {
	case H3aggregationtypeMosquitosource,
		H3aggregationtypeServicerequest:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e H3aggregationtype) All() []H3aggregationtype {
	return AllH3aggregationtype()
}

func (e H3aggregationtype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *H3aggregationtype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e H3aggregationtype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *H3aggregationtype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e H3aggregationtype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *H3aggregationtype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = H3aggregationtype(x)
	case []byte:
		*e = H3aggregationtype(x)
	case nil:
		return fmt.Errorf("cannot nil into H3aggregationtype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid H3aggregationtype value: %s", *e)
	}

	return nil
}

// Enum values for Hashtype
const (
	HashtypeBcrypt14 Hashtype = "bcrypt-14"
)

func AllHashtype() []Hashtype {
	return []Hashtype{
		HashtypeBcrypt14,
	}
}

type Hashtype string

func (e Hashtype) String() string {
	return string(e)
}

func (e Hashtype) Valid() bool {
	switch e {
	case HashtypeBcrypt14:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e Hashtype) All() []Hashtype {
	return AllHashtype()
}

func (e Hashtype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *Hashtype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e Hashtype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *Hashtype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e Hashtype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *Hashtype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = Hashtype(x)
	case []byte:
		*e = Hashtype(x)
	case nil:
		return fmt.Errorf("cannot nil into Hashtype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid Hashtype value: %s", *e)
	}

	return nil
}

// Enum values for Notificationtype
const (
	NotificationtypeOauthTokenInvalidated Notificationtype = "oauth_token_invalidated"
)

func AllNotificationtype() []Notificationtype {
	return []Notificationtype{
		NotificationtypeOauthTokenInvalidated,
	}
}

type Notificationtype string

func (e Notificationtype) String() string {
	return string(e)
}

func (e Notificationtype) Valid() bool {
	switch e {
	case NotificationtypeOauthTokenInvalidated:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e Notificationtype) All() []Notificationtype {
	return AllNotificationtype()
}

func (e Notificationtype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *Notificationtype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e Notificationtype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *Notificationtype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e Notificationtype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *Notificationtype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = Notificationtype(x)
	case []byte:
		*e = Notificationtype(x)
	case nil:
		return fmt.Errorf("cannot nil into Notificationtype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid Notificationtype value: %s", *e)
	}

	return nil
}
