// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// FSSamplecollection is an object representing the database table.
type FSSamplecollection struct {
	OrganizationID int32             `db:"organization_id" `
	Activity       null.Val[string]  `db:"activity" `
	Avetemp        null.Val[float64] `db:"avetemp" `
	Chickenid      null.Val[string]  `db:"chickenid" `
	Comments       null.Val[string]  `db:"comments" `
	Creationdate   null.Val[int64]   `db:"creationdate" `
	Creator        null.Val[string]  `db:"creator" `
	Datesent       null.Val[int64]   `db:"datesent" `
	Datetested     null.Val[int64]   `db:"datetested" `
	Diseasepos     null.Val[string]  `db:"diseasepos" `
	Diseasetested  null.Val[string]  `db:"diseasetested" `
	Enddatetime    null.Val[int64]   `db:"enddatetime" `
	Editdate       null.Val[int64]   `db:"editdate" `
	Editor         null.Val[string]  `db:"editor" `
	Fieldtech      null.Val[string]  `db:"fieldtech" `
	Flockid        null.Val[string]  `db:"flockid" `
	Gatewaysync    null.Val[int16]   `db:"gatewaysync" `
	Globalid       string            `db:"globalid" `
	Lab            null.Val[string]  `db:"lab" `
	Locationname   null.Val[string]  `db:"locationname" `
	LocID          null.Val[string]  `db:"loc_id" `
	Objectid       int32             `db:"objectid,pk" `
	Processed      null.Val[int16]   `db:"processed" `
	Raingauge      null.Val[float64] `db:"raingauge" `
	Recordstatus   null.Val[int16]   `db:"recordstatus" `
	Reviewed       null.Val[int16]   `db:"reviewed" `
	Reviewedby     null.Val[string]  `db:"reviewedby" `
	Revieweddate   null.Val[int64]   `db:"revieweddate" `
	Samplecond     null.Val[string]  `db:"samplecond" `
	Samplecount    null.Val[int16]   `db:"samplecount" `
	Sampleid       null.Val[string]  `db:"sampleid" `
	Sampletype     null.Val[string]  `db:"sampletype" `
	Sex            null.Val[string]  `db:"sex" `
	Sitecond       null.Val[string]  `db:"sitecond" `
	Species        null.Val[string]  `db:"species" `
	Startdatetime  null.Val[int64]   `db:"startdatetime" `
	Survtech       null.Val[string]  `db:"survtech" `
	Testmethod     null.Val[string]  `db:"testmethod" `
	Testtech       null.Val[string]  `db:"testtech" `
	Winddir        null.Val[string]  `db:"winddir" `
	Windspeed      null.Val[float64] `db:"windspeed" `
	Zone           null.Val[string]  `db:"zone" `
	Zone2          null.Val[string]  `db:"zone2" `
	CreatedDate    null.Val[int64]   `db:"created_date" `
	CreatedUser    null.Val[string]  `db:"created_user" `
	GeometryX      null.Val[float64] `db:"geometry_x" `
	GeometryY      null.Val[float64] `db:"geometry_y" `
	LastEditedDate null.Val[int64]   `db:"last_edited_date" `
	LastEditedUser null.Val[string]  `db:"last_edited_user" `
	Updated        time.Time         `db:"updated" `

	R fsSamplecollectionR `db:"-" `
}

// FSSamplecollectionSlice is an alias for a slice of pointers to FSSamplecollection.
// This should almost always be used instead of []*FSSamplecollection.
type FSSamplecollectionSlice []*FSSamplecollection

// FSSamplecollections contains methods to work with the fs_samplecollection table
var FSSamplecollections = psql.NewTablex[*FSSamplecollection, FSSamplecollectionSlice, *FSSamplecollectionSetter]("", "fs_samplecollection", buildFSSamplecollectionColumns("fs_samplecollection"))

// FSSamplecollectionsQuery is a query on the fs_samplecollection table
type FSSamplecollectionsQuery = *psql.ViewQuery[*FSSamplecollection, FSSamplecollectionSlice]

// fsSamplecollectionR is where relationships are stored.
type fsSamplecollectionR struct {
	Organization *Organization // fs_samplecollection.fs_samplecollection_organization_id_fkey
}

func buildFSSamplecollectionColumns(alias string) fsSamplecollectionColumns {
	return fsSamplecollectionColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"organization_id", "activity", "avetemp", "chickenid", "comments", "creationdate", "creator", "datesent", "datetested", "diseasepos", "diseasetested", "enddatetime", "editdate", "editor", "fieldtech", "flockid", "gatewaysync", "globalid", "lab", "locationname", "loc_id", "objectid", "processed", "raingauge", "recordstatus", "reviewed", "reviewedby", "revieweddate", "samplecond", "samplecount", "sampleid", "sampletype", "sex", "sitecond", "species", "startdatetime", "survtech", "testmethod", "testtech", "winddir", "windspeed", "zone", "zone2", "created_date", "created_user", "geometry_x", "geometry_y", "last_edited_date", "last_edited_user", "updated",
		).WithParent("fs_samplecollection"),
		tableAlias:     alias,
		OrganizationID: psql.Quote(alias, "organization_id"),
		Activity:       psql.Quote(alias, "activity"),
		Avetemp:        psql.Quote(alias, "avetemp"),
		Chickenid:      psql.Quote(alias, "chickenid"),
		Comments:       psql.Quote(alias, "comments"),
		Creationdate:   psql.Quote(alias, "creationdate"),
		Creator:        psql.Quote(alias, "creator"),
		Datesent:       psql.Quote(alias, "datesent"),
		Datetested:     psql.Quote(alias, "datetested"),
		Diseasepos:     psql.Quote(alias, "diseasepos"),
		Diseasetested:  psql.Quote(alias, "diseasetested"),
		Enddatetime:    psql.Quote(alias, "enddatetime"),
		Editdate:       psql.Quote(alias, "editdate"),
		Editor:         psql.Quote(alias, "editor"),
		Fieldtech:      psql.Quote(alias, "fieldtech"),
		Flockid:        psql.Quote(alias, "flockid"),
		Gatewaysync:    psql.Quote(alias, "gatewaysync"),
		Globalid:       psql.Quote(alias, "globalid"),
		Lab:            psql.Quote(alias, "lab"),
		Locationname:   psql.Quote(alias, "locationname"),
		LocID:          psql.Quote(alias, "loc_id"),
		Objectid:       psql.Quote(alias, "objectid"),
		Processed:      psql.Quote(alias, "processed"),
		Raingauge:      psql.Quote(alias, "raingauge"),
		Recordstatus:   psql.Quote(alias, "recordstatus"),
		Reviewed:       psql.Quote(alias, "reviewed"),
		Reviewedby:     psql.Quote(alias, "reviewedby"),
		Revieweddate:   psql.Quote(alias, "revieweddate"),
		Samplecond:     psql.Quote(alias, "samplecond"),
		Samplecount:    psql.Quote(alias, "samplecount"),
		Sampleid:       psql.Quote(alias, "sampleid"),
		Sampletype:     psql.Quote(alias, "sampletype"),
		Sex:            psql.Quote(alias, "sex"),
		Sitecond:       psql.Quote(alias, "sitecond"),
		Species:        psql.Quote(alias, "species"),
		Startdatetime:  psql.Quote(alias, "startdatetime"),
		Survtech:       psql.Quote(alias, "survtech"),
		Testmethod:     psql.Quote(alias, "testmethod"),
		Testtech:       psql.Quote(alias, "testtech"),
		Winddir:        psql.Quote(alias, "winddir"),
		Windspeed:      psql.Quote(alias, "windspeed"),
		Zone:           psql.Quote(alias, "zone"),
		Zone2:          psql.Quote(alias, "zone2"),
		CreatedDate:    psql.Quote(alias, "created_date"),
		CreatedUser:    psql.Quote(alias, "created_user"),
		GeometryX:      psql.Quote(alias, "geometry_x"),
		GeometryY:      psql.Quote(alias, "geometry_y"),
		LastEditedDate: psql.Quote(alias, "last_edited_date"),
		LastEditedUser: psql.Quote(alias, "last_edited_user"),
		Updated:        psql.Quote(alias, "updated"),
	}
}

type fsSamplecollectionColumns struct {
	expr.ColumnsExpr
	tableAlias     string
	OrganizationID psql.Expression
	Activity       psql.Expression
	Avetemp        psql.Expression
	Chickenid      psql.Expression
	Comments       psql.Expression
	Creationdate   psql.Expression
	Creator        psql.Expression
	Datesent       psql.Expression
	Datetested     psql.Expression
	Diseasepos     psql.Expression
	Diseasetested  psql.Expression
	Enddatetime    psql.Expression
	Editdate       psql.Expression
	Editor         psql.Expression
	Fieldtech      psql.Expression
	Flockid        psql.Expression
	Gatewaysync    psql.Expression
	Globalid       psql.Expression
	Lab            psql.Expression
	Locationname   psql.Expression
	LocID          psql.Expression
	Objectid       psql.Expression
	Processed      psql.Expression
	Raingauge      psql.Expression
	Recordstatus   psql.Expression
	Reviewed       psql.Expression
	Reviewedby     psql.Expression
	Revieweddate   psql.Expression
	Samplecond     psql.Expression
	Samplecount    psql.Expression
	Sampleid       psql.Expression
	Sampletype     psql.Expression
	Sex            psql.Expression
	Sitecond       psql.Expression
	Species        psql.Expression
	Startdatetime  psql.Expression
	Survtech       psql.Expression
	Testmethod     psql.Expression
	Testtech       psql.Expression
	Winddir        psql.Expression
	Windspeed      psql.Expression
	Zone           psql.Expression
	Zone2          psql.Expression
	CreatedDate    psql.Expression
	CreatedUser    psql.Expression
	GeometryX      psql.Expression
	GeometryY      psql.Expression
	LastEditedDate psql.Expression
	LastEditedUser psql.Expression
	Updated        psql.Expression
}

func (c fsSamplecollectionColumns) Alias() string {
	return c.tableAlias
}

func (fsSamplecollectionColumns) AliasedAs(alias string) fsSamplecollectionColumns {
	return buildFSSamplecollectionColumns(alias)
}

// FSSamplecollectionSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type FSSamplecollectionSetter struct {
	OrganizationID omit.Val[int32]       `db:"organization_id" `
	Activity       omitnull.Val[string]  `db:"activity" `
	Avetemp        omitnull.Val[float64] `db:"avetemp" `
	Chickenid      omitnull.Val[string]  `db:"chickenid" `
	Comments       omitnull.Val[string]  `db:"comments" `
	Creationdate   omitnull.Val[int64]   `db:"creationdate" `
	Creator        omitnull.Val[string]  `db:"creator" `
	Datesent       omitnull.Val[int64]   `db:"datesent" `
	Datetested     omitnull.Val[int64]   `db:"datetested" `
	Diseasepos     omitnull.Val[string]  `db:"diseasepos" `
	Diseasetested  omitnull.Val[string]  `db:"diseasetested" `
	Enddatetime    omitnull.Val[int64]   `db:"enddatetime" `
	Editdate       omitnull.Val[int64]   `db:"editdate" `
	Editor         omitnull.Val[string]  `db:"editor" `
	Fieldtech      omitnull.Val[string]  `db:"fieldtech" `
	Flockid        omitnull.Val[string]  `db:"flockid" `
	Gatewaysync    omitnull.Val[int16]   `db:"gatewaysync" `
	Globalid       omit.Val[string]      `db:"globalid" `
	Lab            omitnull.Val[string]  `db:"lab" `
	Locationname   omitnull.Val[string]  `db:"locationname" `
	LocID          omitnull.Val[string]  `db:"loc_id" `
	Objectid       omit.Val[int32]       `db:"objectid,pk" `
	Processed      omitnull.Val[int16]   `db:"processed" `
	Raingauge      omitnull.Val[float64] `db:"raingauge" `
	Recordstatus   omitnull.Val[int16]   `db:"recordstatus" `
	Reviewed       omitnull.Val[int16]   `db:"reviewed" `
	Reviewedby     omitnull.Val[string]  `db:"reviewedby" `
	Revieweddate   omitnull.Val[int64]   `db:"revieweddate" `
	Samplecond     omitnull.Val[string]  `db:"samplecond" `
	Samplecount    omitnull.Val[int16]   `db:"samplecount" `
	Sampleid       omitnull.Val[string]  `db:"sampleid" `
	Sampletype     omitnull.Val[string]  `db:"sampletype" `
	Sex            omitnull.Val[string]  `db:"sex" `
	Sitecond       omitnull.Val[string]  `db:"sitecond" `
	Species        omitnull.Val[string]  `db:"species" `
	Startdatetime  omitnull.Val[int64]   `db:"startdatetime" `
	Survtech       omitnull.Val[string]  `db:"survtech" `
	Testmethod     omitnull.Val[string]  `db:"testmethod" `
	Testtech       omitnull.Val[string]  `db:"testtech" `
	Winddir        omitnull.Val[string]  `db:"winddir" `
	Windspeed      omitnull.Val[float64] `db:"windspeed" `
	Zone           omitnull.Val[string]  `db:"zone" `
	Zone2          omitnull.Val[string]  `db:"zone2" `
	CreatedDate    omitnull.Val[int64]   `db:"created_date" `
	CreatedUser    omitnull.Val[string]  `db:"created_user" `
	GeometryX      omitnull.Val[float64] `db:"geometry_x" `
	GeometryY      omitnull.Val[float64] `db:"geometry_y" `
	LastEditedDate omitnull.Val[int64]   `db:"last_edited_date" `
	LastEditedUser omitnull.Val[string]  `db:"last_edited_user" `
	Updated        omit.Val[time.Time]   `db:"updated" `
}

func (s FSSamplecollectionSetter) SetColumns() []string {
	vals := make([]string, 0, 50)
	if s.OrganizationID.IsValue() {
		vals = append(vals, "organization_id")
	}
	if !s.Activity.IsUnset() {
		vals = append(vals, "activity")
	}
	if !s.Avetemp.IsUnset() {
		vals = append(vals, "avetemp")
	}
	if !s.Chickenid.IsUnset() {
		vals = append(vals, "chickenid")
	}
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Datesent.IsUnset() {
		vals = append(vals, "datesent")
	}
	if !s.Datetested.IsUnset() {
		vals = append(vals, "datetested")
	}
	if !s.Diseasepos.IsUnset() {
		vals = append(vals, "diseasepos")
	}
	if !s.Diseasetested.IsUnset() {
		vals = append(vals, "diseasetested")
	}
	if !s.Enddatetime.IsUnset() {
		vals = append(vals, "enddatetime")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if !s.Fieldtech.IsUnset() {
		vals = append(vals, "fieldtech")
	}
	if !s.Flockid.IsUnset() {
		vals = append(vals, "flockid")
	}
	if !s.Gatewaysync.IsUnset() {
		vals = append(vals, "gatewaysync")
	}
	if s.Globalid.IsValue() {
		vals = append(vals, "globalid")
	}
	if !s.Lab.IsUnset() {
		vals = append(vals, "lab")
	}
	if !s.Locationname.IsUnset() {
		vals = append(vals, "locationname")
	}
	if !s.LocID.IsUnset() {
		vals = append(vals, "loc_id")
	}
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.Processed.IsUnset() {
		vals = append(vals, "processed")
	}
	if !s.Raingauge.IsUnset() {
		vals = append(vals, "raingauge")
	}
	if !s.Recordstatus.IsUnset() {
		vals = append(vals, "recordstatus")
	}
	if !s.Reviewed.IsUnset() {
		vals = append(vals, "reviewed")
	}
	if !s.Reviewedby.IsUnset() {
		vals = append(vals, "reviewedby")
	}
	if !s.Revieweddate.IsUnset() {
		vals = append(vals, "revieweddate")
	}
	if !s.Samplecond.IsUnset() {
		vals = append(vals, "samplecond")
	}
	if !s.Samplecount.IsUnset() {
		vals = append(vals, "samplecount")
	}
	if !s.Sampleid.IsUnset() {
		vals = append(vals, "sampleid")
	}
	if !s.Sampletype.IsUnset() {
		vals = append(vals, "sampletype")
	}
	if !s.Sex.IsUnset() {
		vals = append(vals, "sex")
	}
	if !s.Sitecond.IsUnset() {
		vals = append(vals, "sitecond")
	}
	if !s.Species.IsUnset() {
		vals = append(vals, "species")
	}
	if !s.Startdatetime.IsUnset() {
		vals = append(vals, "startdatetime")
	}
	if !s.Survtech.IsUnset() {
		vals = append(vals, "survtech")
	}
	if !s.Testmethod.IsUnset() {
		vals = append(vals, "testmethod")
	}
	if !s.Testtech.IsUnset() {
		vals = append(vals, "testtech")
	}
	if !s.Winddir.IsUnset() {
		vals = append(vals, "winddir")
	}
	if !s.Windspeed.IsUnset() {
		vals = append(vals, "windspeed")
	}
	if !s.Zone.IsUnset() {
		vals = append(vals, "zone")
	}
	if !s.Zone2.IsUnset() {
		vals = append(vals, "zone2")
	}
	if !s.CreatedDate.IsUnset() {
		vals = append(vals, "created_date")
	}
	if !s.CreatedUser.IsUnset() {
		vals = append(vals, "created_user")
	}
	if !s.GeometryX.IsUnset() {
		vals = append(vals, "geometry_x")
	}
	if !s.GeometryY.IsUnset() {
		vals = append(vals, "geometry_y")
	}
	if !s.LastEditedDate.IsUnset() {
		vals = append(vals, "last_edited_date")
	}
	if !s.LastEditedUser.IsUnset() {
		vals = append(vals, "last_edited_user")
	}
	if s.Updated.IsValue() {
		vals = append(vals, "updated")
	}
	return vals
}

func (s FSSamplecollectionSetter) Overwrite(t *FSSamplecollection) {
	if s.OrganizationID.IsValue() {
		t.OrganizationID = s.OrganizationID.MustGet()
	}
	if !s.Activity.IsUnset() {
		t.Activity = s.Activity.MustGetNull()
	}
	if !s.Avetemp.IsUnset() {
		t.Avetemp = s.Avetemp.MustGetNull()
	}
	if !s.Chickenid.IsUnset() {
		t.Chickenid = s.Chickenid.MustGetNull()
	}
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Datesent.IsUnset() {
		t.Datesent = s.Datesent.MustGetNull()
	}
	if !s.Datetested.IsUnset() {
		t.Datetested = s.Datetested.MustGetNull()
	}
	if !s.Diseasepos.IsUnset() {
		t.Diseasepos = s.Diseasepos.MustGetNull()
	}
	if !s.Diseasetested.IsUnset() {
		t.Diseasetested = s.Diseasetested.MustGetNull()
	}
	if !s.Enddatetime.IsUnset() {
		t.Enddatetime = s.Enddatetime.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if !s.Fieldtech.IsUnset() {
		t.Fieldtech = s.Fieldtech.MustGetNull()
	}
	if !s.Flockid.IsUnset() {
		t.Flockid = s.Flockid.MustGetNull()
	}
	if !s.Gatewaysync.IsUnset() {
		t.Gatewaysync = s.Gatewaysync.MustGetNull()
	}
	if s.Globalid.IsValue() {
		t.Globalid = s.Globalid.MustGet()
	}
	if !s.Lab.IsUnset() {
		t.Lab = s.Lab.MustGetNull()
	}
	if !s.Locationname.IsUnset() {
		t.Locationname = s.Locationname.MustGetNull()
	}
	if !s.LocID.IsUnset() {
		t.LocID = s.LocID.MustGetNull()
	}
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.Processed.IsUnset() {
		t.Processed = s.Processed.MustGetNull()
	}
	if !s.Raingauge.IsUnset() {
		t.Raingauge = s.Raingauge.MustGetNull()
	}
	if !s.Recordstatus.IsUnset() {
		t.Recordstatus = s.Recordstatus.MustGetNull()
	}
	if !s.Reviewed.IsUnset() {
		t.Reviewed = s.Reviewed.MustGetNull()
	}
	if !s.Reviewedby.IsUnset() {
		t.Reviewedby = s.Reviewedby.MustGetNull()
	}
	if !s.Revieweddate.IsUnset() {
		t.Revieweddate = s.Revieweddate.MustGetNull()
	}
	if !s.Samplecond.IsUnset() {
		t.Samplecond = s.Samplecond.MustGetNull()
	}
	if !s.Samplecount.IsUnset() {
		t.Samplecount = s.Samplecount.MustGetNull()
	}
	if !s.Sampleid.IsUnset() {
		t.Sampleid = s.Sampleid.MustGetNull()
	}
	if !s.Sampletype.IsUnset() {
		t.Sampletype = s.Sampletype.MustGetNull()
	}
	if !s.Sex.IsUnset() {
		t.Sex = s.Sex.MustGetNull()
	}
	if !s.Sitecond.IsUnset() {
		t.Sitecond = s.Sitecond.MustGetNull()
	}
	if !s.Species.IsUnset() {
		t.Species = s.Species.MustGetNull()
	}
	if !s.Startdatetime.IsUnset() {
		t.Startdatetime = s.Startdatetime.MustGetNull()
	}
	if !s.Survtech.IsUnset() {
		t.Survtech = s.Survtech.MustGetNull()
	}
	if !s.Testmethod.IsUnset() {
		t.Testmethod = s.Testmethod.MustGetNull()
	}
	if !s.Testtech.IsUnset() {
		t.Testtech = s.Testtech.MustGetNull()
	}
	if !s.Winddir.IsUnset() {
		t.Winddir = s.Winddir.MustGetNull()
	}
	if !s.Windspeed.IsUnset() {
		t.Windspeed = s.Windspeed.MustGetNull()
	}
	if !s.Zone.IsUnset() {
		t.Zone = s.Zone.MustGetNull()
	}
	if !s.Zone2.IsUnset() {
		t.Zone2 = s.Zone2.MustGetNull()
	}
	if !s.CreatedDate.IsUnset() {
		t.CreatedDate = s.CreatedDate.MustGetNull()
	}
	if !s.CreatedUser.IsUnset() {
		t.CreatedUser = s.CreatedUser.MustGetNull()
	}
	if !s.GeometryX.IsUnset() {
		t.GeometryX = s.GeometryX.MustGetNull()
	}
	if !s.GeometryY.IsUnset() {
		t.GeometryY = s.GeometryY.MustGetNull()
	}
	if !s.LastEditedDate.IsUnset() {
		t.LastEditedDate = s.LastEditedDate.MustGetNull()
	}
	if !s.LastEditedUser.IsUnset() {
		t.LastEditedUser = s.LastEditedUser.MustGetNull()
	}
	if s.Updated.IsValue() {
		t.Updated = s.Updated.MustGet()
	}
}

func (s *FSSamplecollectionSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return FSSamplecollections.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 50)
		if s.OrganizationID.IsValue() {
			vals[0] = psql.Arg(s.OrganizationID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Activity.IsUnset() {
			vals[1] = psql.Arg(s.Activity.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Avetemp.IsUnset() {
			vals[2] = psql.Arg(s.Avetemp.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Chickenid.IsUnset() {
			vals[3] = psql.Arg(s.Chickenid.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Comments.IsUnset() {
			vals[4] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[5] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[6] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Datesent.IsUnset() {
			vals[7] = psql.Arg(s.Datesent.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Datetested.IsUnset() {
			vals[8] = psql.Arg(s.Datetested.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Diseasepos.IsUnset() {
			vals[9] = psql.Arg(s.Diseasepos.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Diseasetested.IsUnset() {
			vals[10] = psql.Arg(s.Diseasetested.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.Enddatetime.IsUnset() {
			vals[11] = psql.Arg(s.Enddatetime.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[12] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[13] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.Fieldtech.IsUnset() {
			vals[14] = psql.Arg(s.Fieldtech.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.Flockid.IsUnset() {
			vals[15] = psql.Arg(s.Flockid.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.Gatewaysync.IsUnset() {
			vals[16] = psql.Arg(s.Gatewaysync.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if s.Globalid.IsValue() {
			vals[17] = psql.Arg(s.Globalid.MustGet())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Lab.IsUnset() {
			vals[18] = psql.Arg(s.Lab.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Locationname.IsUnset() {
			vals[19] = psql.Arg(s.Locationname.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.LocID.IsUnset() {
			vals[20] = psql.Arg(s.LocID.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if s.Objectid.IsValue() {
			vals[21] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.Processed.IsUnset() {
			vals[22] = psql.Arg(s.Processed.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if !s.Raingauge.IsUnset() {
			vals[23] = psql.Arg(s.Raingauge.MustGetNull())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.Recordstatus.IsUnset() {
			vals[24] = psql.Arg(s.Recordstatus.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.Reviewed.IsUnset() {
			vals[25] = psql.Arg(s.Reviewed.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.Reviewedby.IsUnset() {
			vals[26] = psql.Arg(s.Reviewedby.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.Revieweddate.IsUnset() {
			vals[27] = psql.Arg(s.Revieweddate.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if !s.Samplecond.IsUnset() {
			vals[28] = psql.Arg(s.Samplecond.MustGetNull())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if !s.Samplecount.IsUnset() {
			vals[29] = psql.Arg(s.Samplecount.MustGetNull())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if !s.Sampleid.IsUnset() {
			vals[30] = psql.Arg(s.Sampleid.MustGetNull())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		if !s.Sampletype.IsUnset() {
			vals[31] = psql.Arg(s.Sampletype.MustGetNull())
		} else {
			vals[31] = psql.Raw("DEFAULT")
		}

		if !s.Sex.IsUnset() {
			vals[32] = psql.Arg(s.Sex.MustGetNull())
		} else {
			vals[32] = psql.Raw("DEFAULT")
		}

		if !s.Sitecond.IsUnset() {
			vals[33] = psql.Arg(s.Sitecond.MustGetNull())
		} else {
			vals[33] = psql.Raw("DEFAULT")
		}

		if !s.Species.IsUnset() {
			vals[34] = psql.Arg(s.Species.MustGetNull())
		} else {
			vals[34] = psql.Raw("DEFAULT")
		}

		if !s.Startdatetime.IsUnset() {
			vals[35] = psql.Arg(s.Startdatetime.MustGetNull())
		} else {
			vals[35] = psql.Raw("DEFAULT")
		}

		if !s.Survtech.IsUnset() {
			vals[36] = psql.Arg(s.Survtech.MustGetNull())
		} else {
			vals[36] = psql.Raw("DEFAULT")
		}

		if !s.Testmethod.IsUnset() {
			vals[37] = psql.Arg(s.Testmethod.MustGetNull())
		} else {
			vals[37] = psql.Raw("DEFAULT")
		}

		if !s.Testtech.IsUnset() {
			vals[38] = psql.Arg(s.Testtech.MustGetNull())
		} else {
			vals[38] = psql.Raw("DEFAULT")
		}

		if !s.Winddir.IsUnset() {
			vals[39] = psql.Arg(s.Winddir.MustGetNull())
		} else {
			vals[39] = psql.Raw("DEFAULT")
		}

		if !s.Windspeed.IsUnset() {
			vals[40] = psql.Arg(s.Windspeed.MustGetNull())
		} else {
			vals[40] = psql.Raw("DEFAULT")
		}

		if !s.Zone.IsUnset() {
			vals[41] = psql.Arg(s.Zone.MustGetNull())
		} else {
			vals[41] = psql.Raw("DEFAULT")
		}

		if !s.Zone2.IsUnset() {
			vals[42] = psql.Arg(s.Zone2.MustGetNull())
		} else {
			vals[42] = psql.Raw("DEFAULT")
		}

		if !s.CreatedDate.IsUnset() {
			vals[43] = psql.Arg(s.CreatedDate.MustGetNull())
		} else {
			vals[43] = psql.Raw("DEFAULT")
		}

		if !s.CreatedUser.IsUnset() {
			vals[44] = psql.Arg(s.CreatedUser.MustGetNull())
		} else {
			vals[44] = psql.Raw("DEFAULT")
		}

		if !s.GeometryX.IsUnset() {
			vals[45] = psql.Arg(s.GeometryX.MustGetNull())
		} else {
			vals[45] = psql.Raw("DEFAULT")
		}

		if !s.GeometryY.IsUnset() {
			vals[46] = psql.Arg(s.GeometryY.MustGetNull())
		} else {
			vals[46] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedDate.IsUnset() {
			vals[47] = psql.Arg(s.LastEditedDate.MustGetNull())
		} else {
			vals[47] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedUser.IsUnset() {
			vals[48] = psql.Arg(s.LastEditedUser.MustGetNull())
		} else {
			vals[48] = psql.Raw("DEFAULT")
		}

		if s.Updated.IsValue() {
			vals[49] = psql.Arg(s.Updated.MustGet())
		} else {
			vals[49] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s FSSamplecollectionSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s FSSamplecollectionSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 50)

	if s.OrganizationID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "organization_id")...),
			psql.Arg(s.OrganizationID),
		}})
	}

	if !s.Activity.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "activity")...),
			psql.Arg(s.Activity),
		}})
	}

	if !s.Avetemp.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "avetemp")...),
			psql.Arg(s.Avetemp),
		}})
	}

	if !s.Chickenid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "chickenid")...),
			psql.Arg(s.Chickenid),
		}})
	}

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Datesent.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datesent")...),
			psql.Arg(s.Datesent),
		}})
	}

	if !s.Datetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datetested")...),
			psql.Arg(s.Datetested),
		}})
	}

	if !s.Diseasepos.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasepos")...),
			psql.Arg(s.Diseasepos),
		}})
	}

	if !s.Diseasetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasetested")...),
			psql.Arg(s.Diseasetested),
		}})
	}

	if !s.Enddatetime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "enddatetime")...),
			psql.Arg(s.Enddatetime),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if !s.Fieldtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "fieldtech")...),
			psql.Arg(s.Fieldtech),
		}})
	}

	if !s.Flockid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "flockid")...),
			psql.Arg(s.Flockid),
		}})
	}

	if !s.Gatewaysync.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "gatewaysync")...),
			psql.Arg(s.Gatewaysync),
		}})
	}

	if s.Globalid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.Lab.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lab")...),
			psql.Arg(s.Lab),
		}})
	}

	if !s.Locationname.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "locationname")...),
			psql.Arg(s.Locationname),
		}})
	}

	if !s.LocID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "loc_id")...),
			psql.Arg(s.LocID),
		}})
	}

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.Processed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "processed")...),
			psql.Arg(s.Processed),
		}})
	}

	if !s.Raingauge.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "raingauge")...),
			psql.Arg(s.Raingauge),
		}})
	}

	if !s.Recordstatus.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "recordstatus")...),
			psql.Arg(s.Recordstatus),
		}})
	}

	if !s.Reviewed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reviewed")...),
			psql.Arg(s.Reviewed),
		}})
	}

	if !s.Reviewedby.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reviewedby")...),
			psql.Arg(s.Reviewedby),
		}})
	}

	if !s.Revieweddate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "revieweddate")...),
			psql.Arg(s.Revieweddate),
		}})
	}

	if !s.Samplecond.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "samplecond")...),
			psql.Arg(s.Samplecond),
		}})
	}

	if !s.Samplecount.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "samplecount")...),
			psql.Arg(s.Samplecount),
		}})
	}

	if !s.Sampleid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sampleid")...),
			psql.Arg(s.Sampleid),
		}})
	}

	if !s.Sampletype.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sampletype")...),
			psql.Arg(s.Sampletype),
		}})
	}

	if !s.Sex.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sex")...),
			psql.Arg(s.Sex),
		}})
	}

	if !s.Sitecond.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sitecond")...),
			psql.Arg(s.Sitecond),
		}})
	}

	if !s.Species.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "species")...),
			psql.Arg(s.Species),
		}})
	}

	if !s.Startdatetime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "startdatetime")...),
			psql.Arg(s.Startdatetime),
		}})
	}

	if !s.Survtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "survtech")...),
			psql.Arg(s.Survtech),
		}})
	}

	if !s.Testmethod.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testmethod")...),
			psql.Arg(s.Testmethod),
		}})
	}

	if !s.Testtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testtech")...),
			psql.Arg(s.Testtech),
		}})
	}

	if !s.Winddir.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "winddir")...),
			psql.Arg(s.Winddir),
		}})
	}

	if !s.Windspeed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "windspeed")...),
			psql.Arg(s.Windspeed),
		}})
	}

	if !s.Zone.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone")...),
			psql.Arg(s.Zone),
		}})
	}

	if !s.Zone2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone2")...),
			psql.Arg(s.Zone2),
		}})
	}

	if !s.CreatedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_date")...),
			psql.Arg(s.CreatedDate),
		}})
	}

	if !s.CreatedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_user")...),
			psql.Arg(s.CreatedUser),
		}})
	}

	if !s.GeometryX.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_x")...),
			psql.Arg(s.GeometryX),
		}})
	}

	if !s.GeometryY.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_y")...),
			psql.Arg(s.GeometryY),
		}})
	}

	if !s.LastEditedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_date")...),
			psql.Arg(s.LastEditedDate),
		}})
	}

	if !s.LastEditedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_user")...),
			psql.Arg(s.LastEditedUser),
		}})
	}

	if s.Updated.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated")...),
			psql.Arg(s.Updated),
		}})
	}

	return exprs
}

// FindFSSamplecollection retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindFSSamplecollection(ctx context.Context, exec bob.Executor, ObjectidPK int32, cols ...string) (*FSSamplecollection, error) {
	if len(cols) == 0 {
		return FSSamplecollections.Query(
			sm.Where(FSSamplecollections.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		).One(ctx, exec)
	}

	return FSSamplecollections.Query(
		sm.Where(FSSamplecollections.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Columns(FSSamplecollections.Columns.Only(cols...)),
	).One(ctx, exec)
}

// FSSamplecollectionExists checks the presence of a single record by primary key
func FSSamplecollectionExists(ctx context.Context, exec bob.Executor, ObjectidPK int32) (bool, error) {
	return FSSamplecollections.Query(
		sm.Where(FSSamplecollections.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after FSSamplecollection is retrieved from the database
func (o *FSSamplecollection) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FSSamplecollections.AfterSelectHooks.RunHooks(ctx, exec, FSSamplecollectionSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = FSSamplecollections.AfterInsertHooks.RunHooks(ctx, exec, FSSamplecollectionSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = FSSamplecollections.AfterUpdateHooks.RunHooks(ctx, exec, FSSamplecollectionSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = FSSamplecollections.AfterDeleteHooks.RunHooks(ctx, exec, FSSamplecollectionSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the FSSamplecollection
func (o *FSSamplecollection) primaryKeyVals() bob.Expression {
	return psql.Arg(o.Objectid)
}

func (o *FSSamplecollection) pkEQ() dialect.Expression {
	return psql.Quote("fs_samplecollection", "objectid").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the FSSamplecollection
func (o *FSSamplecollection) Update(ctx context.Context, exec bob.Executor, s *FSSamplecollectionSetter) error {
	v, err := FSSamplecollections.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single FSSamplecollection record with an executor
func (o *FSSamplecollection) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := FSSamplecollections.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the FSSamplecollection using the executor
func (o *FSSamplecollection) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := FSSamplecollections.Query(
		sm.Where(FSSamplecollections.Columns.Objectid.EQ(psql.Arg(o.Objectid))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after FSSamplecollectionSlice is retrieved from the database
func (o FSSamplecollectionSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FSSamplecollections.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = FSSamplecollections.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = FSSamplecollections.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = FSSamplecollections.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o FSSamplecollectionSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("fs_samplecollection", "objectid").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o FSSamplecollectionSlice) copyMatchingRows(from ...*FSSamplecollection) {
	for i, old := range o {
		for _, new := range from {
			if new.Objectid != old.Objectid {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o FSSamplecollectionSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FSSamplecollections.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FSSamplecollection:
				o.copyMatchingRows(retrieved)
			case []*FSSamplecollection:
				o.copyMatchingRows(retrieved...)
			case FSSamplecollectionSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FSSamplecollection or a slice of FSSamplecollection
				// then run the AfterUpdateHooks on the slice
				_, err = FSSamplecollections.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o FSSamplecollectionSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FSSamplecollections.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FSSamplecollection:
				o.copyMatchingRows(retrieved)
			case []*FSSamplecollection:
				o.copyMatchingRows(retrieved...)
			case FSSamplecollectionSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FSSamplecollection or a slice of FSSamplecollection
				// then run the AfterDeleteHooks on the slice
				_, err = FSSamplecollections.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o FSSamplecollectionSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals FSSamplecollectionSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FSSamplecollections.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o FSSamplecollectionSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FSSamplecollections.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o FSSamplecollectionSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := FSSamplecollections.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// Organization starts a query for related objects on organization
func (o *FSSamplecollection) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	return Organizations.Query(append(mods,
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.OrganizationID))),
	)...)
}

func (os FSSamplecollectionSlice) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	pkOrganizationID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkOrganizationID = append(pkOrganizationID, o.OrganizationID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkOrganizationID), "integer[]")),
	))

	return Organizations.Query(append(mods,
		sm.Where(psql.Group(Organizations.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

func attachFSSamplecollectionOrganization0(ctx context.Context, exec bob.Executor, count int, fsSamplecollection0 *FSSamplecollection, organization1 *Organization) (*FSSamplecollection, error) {
	setter := &FSSamplecollectionSetter{
		OrganizationID: omit.From(organization1.ID),
	}

	err := fsSamplecollection0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachFSSamplecollectionOrganization0: %w", err)
	}

	return fsSamplecollection0, nil
}

func (fsSamplecollection0 *FSSamplecollection) InsertOrganization(ctx context.Context, exec bob.Executor, related *OrganizationSetter) error {
	var err error

	organization1, err := Organizations.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachFSSamplecollectionOrganization0(ctx, exec, 1, fsSamplecollection0, organization1)
	if err != nil {
		return err
	}

	fsSamplecollection0.R.Organization = organization1

	organization1.R.FSSamplecollections = append(organization1.R.FSSamplecollections, fsSamplecollection0)

	return nil
}

func (fsSamplecollection0 *FSSamplecollection) AttachOrganization(ctx context.Context, exec bob.Executor, organization1 *Organization) error {
	var err error

	_, err = attachFSSamplecollectionOrganization0(ctx, exec, 1, fsSamplecollection0, organization1)
	if err != nil {
		return err
	}

	fsSamplecollection0.R.Organization = organization1

	organization1.R.FSSamplecollections = append(organization1.R.FSSamplecollections, fsSamplecollection0)

	return nil
}

type fsSamplecollectionWhere[Q psql.Filterable] struct {
	OrganizationID psql.WhereMod[Q, int32]
	Activity       psql.WhereNullMod[Q, string]
	Avetemp        psql.WhereNullMod[Q, float64]
	Chickenid      psql.WhereNullMod[Q, string]
	Comments       psql.WhereNullMod[Q, string]
	Creationdate   psql.WhereNullMod[Q, int64]
	Creator        psql.WhereNullMod[Q, string]
	Datesent       psql.WhereNullMod[Q, int64]
	Datetested     psql.WhereNullMod[Q, int64]
	Diseasepos     psql.WhereNullMod[Q, string]
	Diseasetested  psql.WhereNullMod[Q, string]
	Enddatetime    psql.WhereNullMod[Q, int64]
	Editdate       psql.WhereNullMod[Q, int64]
	Editor         psql.WhereNullMod[Q, string]
	Fieldtech      psql.WhereNullMod[Q, string]
	Flockid        psql.WhereNullMod[Q, string]
	Gatewaysync    psql.WhereNullMod[Q, int16]
	Globalid       psql.WhereMod[Q, string]
	Lab            psql.WhereNullMod[Q, string]
	Locationname   psql.WhereNullMod[Q, string]
	LocID          psql.WhereNullMod[Q, string]
	Objectid       psql.WhereMod[Q, int32]
	Processed      psql.WhereNullMod[Q, int16]
	Raingauge      psql.WhereNullMod[Q, float64]
	Recordstatus   psql.WhereNullMod[Q, int16]
	Reviewed       psql.WhereNullMod[Q, int16]
	Reviewedby     psql.WhereNullMod[Q, string]
	Revieweddate   psql.WhereNullMod[Q, int64]
	Samplecond     psql.WhereNullMod[Q, string]
	Samplecount    psql.WhereNullMod[Q, int16]
	Sampleid       psql.WhereNullMod[Q, string]
	Sampletype     psql.WhereNullMod[Q, string]
	Sex            psql.WhereNullMod[Q, string]
	Sitecond       psql.WhereNullMod[Q, string]
	Species        psql.WhereNullMod[Q, string]
	Startdatetime  psql.WhereNullMod[Q, int64]
	Survtech       psql.WhereNullMod[Q, string]
	Testmethod     psql.WhereNullMod[Q, string]
	Testtech       psql.WhereNullMod[Q, string]
	Winddir        psql.WhereNullMod[Q, string]
	Windspeed      psql.WhereNullMod[Q, float64]
	Zone           psql.WhereNullMod[Q, string]
	Zone2          psql.WhereNullMod[Q, string]
	CreatedDate    psql.WhereNullMod[Q, int64]
	CreatedUser    psql.WhereNullMod[Q, string]
	GeometryX      psql.WhereNullMod[Q, float64]
	GeometryY      psql.WhereNullMod[Q, float64]
	LastEditedDate psql.WhereNullMod[Q, int64]
	LastEditedUser psql.WhereNullMod[Q, string]
	Updated        psql.WhereMod[Q, time.Time]
}

func (fsSamplecollectionWhere[Q]) AliasedAs(alias string) fsSamplecollectionWhere[Q] {
	return buildFSSamplecollectionWhere[Q](buildFSSamplecollectionColumns(alias))
}

func buildFSSamplecollectionWhere[Q psql.Filterable](cols fsSamplecollectionColumns) fsSamplecollectionWhere[Q] {
	return fsSamplecollectionWhere[Q]{
		OrganizationID: psql.Where[Q, int32](cols.OrganizationID),
		Activity:       psql.WhereNull[Q, string](cols.Activity),
		Avetemp:        psql.WhereNull[Q, float64](cols.Avetemp),
		Chickenid:      psql.WhereNull[Q, string](cols.Chickenid),
		Comments:       psql.WhereNull[Q, string](cols.Comments),
		Creationdate:   psql.WhereNull[Q, int64](cols.Creationdate),
		Creator:        psql.WhereNull[Q, string](cols.Creator),
		Datesent:       psql.WhereNull[Q, int64](cols.Datesent),
		Datetested:     psql.WhereNull[Q, int64](cols.Datetested),
		Diseasepos:     psql.WhereNull[Q, string](cols.Diseasepos),
		Diseasetested:  psql.WhereNull[Q, string](cols.Diseasetested),
		Enddatetime:    psql.WhereNull[Q, int64](cols.Enddatetime),
		Editdate:       psql.WhereNull[Q, int64](cols.Editdate),
		Editor:         psql.WhereNull[Q, string](cols.Editor),
		Fieldtech:      psql.WhereNull[Q, string](cols.Fieldtech),
		Flockid:        psql.WhereNull[Q, string](cols.Flockid),
		Gatewaysync:    psql.WhereNull[Q, int16](cols.Gatewaysync),
		Globalid:       psql.Where[Q, string](cols.Globalid),
		Lab:            psql.WhereNull[Q, string](cols.Lab),
		Locationname:   psql.WhereNull[Q, string](cols.Locationname),
		LocID:          psql.WhereNull[Q, string](cols.LocID),
		Objectid:       psql.Where[Q, int32](cols.Objectid),
		Processed:      psql.WhereNull[Q, int16](cols.Processed),
		Raingauge:      psql.WhereNull[Q, float64](cols.Raingauge),
		Recordstatus:   psql.WhereNull[Q, int16](cols.Recordstatus),
		Reviewed:       psql.WhereNull[Q, int16](cols.Reviewed),
		Reviewedby:     psql.WhereNull[Q, string](cols.Reviewedby),
		Revieweddate:   psql.WhereNull[Q, int64](cols.Revieweddate),
		Samplecond:     psql.WhereNull[Q, string](cols.Samplecond),
		Samplecount:    psql.WhereNull[Q, int16](cols.Samplecount),
		Sampleid:       psql.WhereNull[Q, string](cols.Sampleid),
		Sampletype:     psql.WhereNull[Q, string](cols.Sampletype),
		Sex:            psql.WhereNull[Q, string](cols.Sex),
		Sitecond:       psql.WhereNull[Q, string](cols.Sitecond),
		Species:        psql.WhereNull[Q, string](cols.Species),
		Startdatetime:  psql.WhereNull[Q, int64](cols.Startdatetime),
		Survtech:       psql.WhereNull[Q, string](cols.Survtech),
		Testmethod:     psql.WhereNull[Q, string](cols.Testmethod),
		Testtech:       psql.WhereNull[Q, string](cols.Testtech),
		Winddir:        psql.WhereNull[Q, string](cols.Winddir),
		Windspeed:      psql.WhereNull[Q, float64](cols.Windspeed),
		Zone:           psql.WhereNull[Q, string](cols.Zone),
		Zone2:          psql.WhereNull[Q, string](cols.Zone2),
		CreatedDate:    psql.WhereNull[Q, int64](cols.CreatedDate),
		CreatedUser:    psql.WhereNull[Q, string](cols.CreatedUser),
		GeometryX:      psql.WhereNull[Q, float64](cols.GeometryX),
		GeometryY:      psql.WhereNull[Q, float64](cols.GeometryY),
		LastEditedDate: psql.WhereNull[Q, int64](cols.LastEditedDate),
		LastEditedUser: psql.WhereNull[Q, string](cols.LastEditedUser),
		Updated:        psql.Where[Q, time.Time](cols.Updated),
	}
}

func (o *FSSamplecollection) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Organization":
		rel, ok := retrieved.(*Organization)
		if !ok {
			return fmt.Errorf("fsSamplecollection cannot load %T as %q", retrieved, name)
		}

		o.R.Organization = rel

		if rel != nil {
			rel.R.FSSamplecollections = FSSamplecollectionSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("fsSamplecollection has no relationship %q", name)
	}
}

type fsSamplecollectionPreloader struct {
	Organization func(...psql.PreloadOption) psql.Preloader
}

func buildFSSamplecollectionPreloader() fsSamplecollectionPreloader {
	return fsSamplecollectionPreloader{
		Organization: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Organization, OrganizationSlice](psql.PreloadRel{
				Name: "Organization",
				Sides: []psql.PreloadSide{
					{
						From:        FSSamplecollections,
						To:          Organizations,
						FromColumns: []string{"organization_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Organizations.Columns.Names(), opts...)
		},
	}
}

type fsSamplecollectionThenLoader[Q orm.Loadable] struct {
	Organization func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildFSSamplecollectionThenLoader[Q orm.Loadable]() fsSamplecollectionThenLoader[Q] {
	type OrganizationLoadInterface interface {
		LoadOrganization(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return fsSamplecollectionThenLoader[Q]{
		Organization: thenLoadBuilder[Q](
			"Organization",
			func(ctx context.Context, exec bob.Executor, retrieved OrganizationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrganization(ctx, exec, mods...)
			},
		),
	}
}

// LoadOrganization loads the fsSamplecollection's Organization into the .R struct
func (o *FSSamplecollection) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Organization = nil

	related, err := o.Organization(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.FSSamplecollections = FSSamplecollectionSlice{o}

	o.R.Organization = related
	return nil
}

// LoadOrganization loads the fsSamplecollection's Organization into the .R struct
func (os FSSamplecollectionSlice) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	organizations, err := os.Organization(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range organizations {

			if !(o.OrganizationID == rel.ID) {
				continue
			}

			rel.R.FSSamplecollections = append(rel.R.FSSamplecollections, o)

			o.R.Organization = rel
			break
		}
	}

	return nil
}

type fsSamplecollectionJoins[Q dialect.Joinable] struct {
	typ          string
	Organization modAs[Q, organizationColumns]
}

func (j fsSamplecollectionJoins[Q]) aliasedAs(alias string) fsSamplecollectionJoins[Q] {
	return buildFSSamplecollectionJoins[Q](buildFSSamplecollectionColumns(alias), j.typ)
}

func buildFSSamplecollectionJoins[Q dialect.Joinable](cols fsSamplecollectionColumns, typ string) fsSamplecollectionJoins[Q] {
	return fsSamplecollectionJoins[Q]{
		typ: typ,
		Organization: modAs[Q, organizationColumns]{
			c: Organizations.Columns,
			f: func(to organizationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Organizations.Name().As(to.Alias())).On(
						to.ID.EQ(cols.OrganizationID),
					))
				}

				return mods
			},
		},
	}
}
