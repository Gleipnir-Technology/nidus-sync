// Code generated by BobGen psql v0.42.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/Gleipnir-Technology/bob"
	"github.com/Gleipnir-Technology/bob/dialect/psql"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dialect"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dm"
	"github.com/Gleipnir-Technology/bob/dialect/psql/sm"
	"github.com/Gleipnir-Technology/bob/dialect/psql/um"
	"github.com/Gleipnir-Technology/bob/expr"
	"github.com/Gleipnir-Technology/bob/mods"
	"github.com/Gleipnir-Technology/bob/orm"
	"github.com/Gleipnir-Technology/bob/types/pgtypes"
	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/google/uuid"
	"github.com/stephenafamo/scan"
)

// Organization is an object representing the database table.
type Organization struct {
	ID                int32               `db:"id,pk" `
	Name              string              `db:"name" `
	ArcgisID          null.Val[string]    `db:"arcgis_id" `
	ArcgisName        null.Val[string]    `db:"arcgis_name" `
	FieldseekerURL    null.Val[string]    `db:"fieldseeker_url" `
	ImportDistrictGid null.Val[int32]     `db:"import_district_gid" `
	Website           null.Val[string]    `db:"website" `
	LogoUUID          null.Val[uuid.UUID] `db:"logo_uuid" `
	Slug              null.Val[string]    `db:"slug" `

	R organizationR `db:"-" `

	C organizationC `db:"-" `
}

// OrganizationSlice is an alias for a slice of pointers to Organization.
// This should almost always be used instead of []*Organization.
type OrganizationSlice []*Organization

// Organizations contains methods to work with the organization table
var Organizations = psql.NewTablex[*Organization, OrganizationSlice, *OrganizationSetter]("", "organization", buildOrganizationColumns("organization"))

// OrganizationsQuery is a query on the organization table
type OrganizationsQuery = *psql.ViewQuery[*Organization, OrganizationSlice]

// organizationR is where relationships are stored.
type organizationR struct {
	EmailContacts             CommsEmailContactSlice                 // district_subscription_email.district_subscription_email_email_contact_address_fkeydistrict_subscription_email.district_subscription_email_organization_id_fkey
	Phones                    CommsPhoneSlice                        // district_subscription_phone.district_subscription_phone_organization_id_fkeydistrict_subscription_phone.district_subscription_phone_phone_e164_fkey
	Containerrelates          FieldseekerContainerrelateSlice        // fieldseeker.containerrelate.containerrelate_organization_id_fkey
	Fieldscoutinglogs         FieldseekerFieldscoutinglogSlice       // fieldseeker.fieldscoutinglog.fieldscoutinglog_organization_id_fkey
	Habitatrelates            FieldseekerHabitatrelateSlice          // fieldseeker.habitatrelate.habitatrelate_organization_id_fkey
	Inspectionsamples         FieldseekerInspectionsampleSlice       // fieldseeker.inspectionsample.inspectionsample_organization_id_fkey
	Inspectionsampledetails   FieldseekerInspectionsampledetailSlice // fieldseeker.inspectionsampledetail.inspectionsampledetail_organization_id_fkey
	Linelocations             FieldseekerLinelocationSlice           // fieldseeker.linelocation.linelocation_organization_id_fkey
	Locationtrackings         FieldseekerLocationtrackingSlice       // fieldseeker.locationtracking.locationtracking_organization_id_fkey
	Mosquitoinspections       FieldseekerMosquitoinspectionSlice     // fieldseeker.mosquitoinspection.mosquitoinspection_organization_id_fkey
	Pointlocations            FieldseekerPointlocationSlice          // fieldseeker.pointlocation.pointlocation_organization_id_fkey
	Polygonlocations          FieldseekerPolygonlocationSlice        // fieldseeker.polygonlocation.polygonlocation_organization_id_fkey
	FieldseekerPool           FieldseekerPoolSlice                   // fieldseeker.pool.pool_organization_id_fkey
	Pooldetails               FieldseekerPooldetailSlice             // fieldseeker.pooldetail.pooldetail_organization_id_fkey
	Proposedtreatmentareas    FieldseekerProposedtreatmentareaSlice  // fieldseeker.proposedtreatmentarea.proposedtreatmentarea_organization_id_fkey
	Qamosquitoinspections     FieldseekerQamosquitoinspectionSlice   // fieldseeker.qamosquitoinspection.qamosquitoinspection_organization_id_fkey
	Rodentlocations           FieldseekerRodentlocationSlice         // fieldseeker.rodentlocation.rodentlocation_organization_id_fkey
	Samplecollections         FieldseekerSamplecollectionSlice       // fieldseeker.samplecollection.samplecollection_organization_id_fkey
	Samplelocations           FieldseekerSamplelocationSlice         // fieldseeker.samplelocation.samplelocation_organization_id_fkey
	Servicerequests           FieldseekerServicerequestSlice         // fieldseeker.servicerequest.servicerequest_organization_id_fkey
	Speciesabundances         FieldseekerSpeciesabundanceSlice       // fieldseeker.speciesabundance.speciesabundance_organization_id_fkey
	Stormdrains               FieldseekerStormdrainSlice             // fieldseeker.stormdrain.stormdrain_organization_id_fkey
	Timecards                 FieldseekerTimecardSlice               // fieldseeker.timecard.timecard_organization_id_fkey
	Trapdata                  FieldseekerTrapdatumSlice              // fieldseeker.trapdata.trapdata_organization_id_fkey
	Traplocations             FieldseekerTraplocationSlice           // fieldseeker.traplocation.traplocation_organization_id_fkey
	Treatments                FieldseekerTreatmentSlice              // fieldseeker.treatment.treatment_organization_id_fkey
	Treatmentareas            FieldseekerTreatmentareaSlice          // fieldseeker.treatmentarea.treatmentarea_organization_id_fkey
	Zones                     FieldseekerZoneSlice                   // fieldseeker.zones.zones_organization_id_fkey
	Zones2s                   FieldseekerZones2Slice                 // fieldseeker.zones2.zones2_organization_id_fkey
	FieldseekerSyncs          FieldseekerSyncSlice                   // fieldseeker_sync.fieldseeker_sync_organization_id_fkey
	Files                     FileuploadFileSlice                    // fileupload.file.file_organization_id_fkey
	H3Aggregations            H3AggregationSlice                     // h3_aggregation.h3_aggregation_organization_id_fkey
	NoteAudios                NoteAudioSlice                         // note_audio.note_audio_organization_id_fkey
	NoteImages                NoteImageSlice                         // note_image.note_image_organization_id_fkey
	ImportDistrictGidDistrict *ImportDistrict                        // organization.organization_import_district_gid_fkey
	Pools                     PoolSlice                              // pool.pool_organization_id_fkey
	Nuisances                 PublicreportNuisanceSlice              // publicreport.nuisance.nuisance_organization_id_fkey
	PublicreportPool          PublicreportPoolSlice                  // publicreport.pool.pool_organization_id_fkey
	Quicks                    PublicreportQuickSlice                 // publicreport.quick.quick_organization_id_fkey
	User                      UserSlice                              // user_.user__organization_id_fkey
}

func buildOrganizationColumns(alias string) organizationColumns {
	return organizationColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "name", "arcgis_id", "arcgis_name", "fieldseeker_url", "import_district_gid", "website", "logo_uuid", "slug",
		).WithParent("organization"),
		tableAlias:        alias,
		ID:                psql.Quote(alias, "id"),
		Name:              psql.Quote(alias, "name"),
		ArcgisID:          psql.Quote(alias, "arcgis_id"),
		ArcgisName:        psql.Quote(alias, "arcgis_name"),
		FieldseekerURL:    psql.Quote(alias, "fieldseeker_url"),
		ImportDistrictGid: psql.Quote(alias, "import_district_gid"),
		Website:           psql.Quote(alias, "website"),
		LogoUUID:          psql.Quote(alias, "logo_uuid"),
		Slug:              psql.Quote(alias, "slug"),
	}
}

type organizationColumns struct {
	expr.ColumnsExpr
	tableAlias        string
	ID                psql.Expression
	Name              psql.Expression
	ArcgisID          psql.Expression
	ArcgisName        psql.Expression
	FieldseekerURL    psql.Expression
	ImportDistrictGid psql.Expression
	Website           psql.Expression
	LogoUUID          psql.Expression
	Slug              psql.Expression
}

func (c organizationColumns) Alias() string {
	return c.tableAlias
}

func (organizationColumns) AliasedAs(alias string) organizationColumns {
	return buildOrganizationColumns(alias)
}

// OrganizationSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type OrganizationSetter struct {
	ID                omit.Val[int32]         `db:"id,pk" `
	Name              omit.Val[string]        `db:"name" `
	ArcgisID          omitnull.Val[string]    `db:"arcgis_id" `
	ArcgisName        omitnull.Val[string]    `db:"arcgis_name" `
	FieldseekerURL    omitnull.Val[string]    `db:"fieldseeker_url" `
	ImportDistrictGid omitnull.Val[int32]     `db:"import_district_gid" `
	Website           omitnull.Val[string]    `db:"website" `
	LogoUUID          omitnull.Val[uuid.UUID] `db:"logo_uuid" `
	Slug              omitnull.Val[string]    `db:"slug" `
}

func (s OrganizationSetter) SetColumns() []string {
	vals := make([]string, 0, 9)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if s.Name.IsValue() {
		vals = append(vals, "name")
	}
	if !s.ArcgisID.IsUnset() {
		vals = append(vals, "arcgis_id")
	}
	if !s.ArcgisName.IsUnset() {
		vals = append(vals, "arcgis_name")
	}
	if !s.FieldseekerURL.IsUnset() {
		vals = append(vals, "fieldseeker_url")
	}
	if !s.ImportDistrictGid.IsUnset() {
		vals = append(vals, "import_district_gid")
	}
	if !s.Website.IsUnset() {
		vals = append(vals, "website")
	}
	if !s.LogoUUID.IsUnset() {
		vals = append(vals, "logo_uuid")
	}
	if !s.Slug.IsUnset() {
		vals = append(vals, "slug")
	}
	return vals
}

func (s OrganizationSetter) Overwrite(t *Organization) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if s.Name.IsValue() {
		t.Name = s.Name.MustGet()
	}
	if !s.ArcgisID.IsUnset() {
		t.ArcgisID = s.ArcgisID.MustGetNull()
	}
	if !s.ArcgisName.IsUnset() {
		t.ArcgisName = s.ArcgisName.MustGetNull()
	}
	if !s.FieldseekerURL.IsUnset() {
		t.FieldseekerURL = s.FieldseekerURL.MustGetNull()
	}
	if !s.ImportDistrictGid.IsUnset() {
		t.ImportDistrictGid = s.ImportDistrictGid.MustGetNull()
	}
	if !s.Website.IsUnset() {
		t.Website = s.Website.MustGetNull()
	}
	if !s.LogoUUID.IsUnset() {
		t.LogoUUID = s.LogoUUID.MustGetNull()
	}
	if !s.Slug.IsUnset() {
		t.Slug = s.Slug.MustGetNull()
	}
}

func (s *OrganizationSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Organizations.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 9)
		if s.ID.IsValue() {
			vals[0] = psql.Arg(s.ID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.Name.IsValue() {
			vals[1] = psql.Arg(s.Name.MustGet())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.ArcgisID.IsUnset() {
			vals[2] = psql.Arg(s.ArcgisID.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.ArcgisName.IsUnset() {
			vals[3] = psql.Arg(s.ArcgisName.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.FieldseekerURL.IsUnset() {
			vals[4] = psql.Arg(s.FieldseekerURL.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.ImportDistrictGid.IsUnset() {
			vals[5] = psql.Arg(s.ImportDistrictGid.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Website.IsUnset() {
			vals[6] = psql.Arg(s.Website.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.LogoUUID.IsUnset() {
			vals[7] = psql.Arg(s.LogoUUID.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Slug.IsUnset() {
			vals[8] = psql.Arg(s.Slug.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s OrganizationSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s OrganizationSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 9)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if s.Name.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "name")...),
			psql.Arg(s.Name),
		}})
	}

	if !s.ArcgisID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "arcgis_id")...),
			psql.Arg(s.ArcgisID),
		}})
	}

	if !s.ArcgisName.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "arcgis_name")...),
			psql.Arg(s.ArcgisName),
		}})
	}

	if !s.FieldseekerURL.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "fieldseeker_url")...),
			psql.Arg(s.FieldseekerURL),
		}})
	}

	if !s.ImportDistrictGid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "import_district_gid")...),
			psql.Arg(s.ImportDistrictGid),
		}})
	}

	if !s.Website.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "website")...),
			psql.Arg(s.Website),
		}})
	}

	if !s.LogoUUID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "logo_uuid")...),
			psql.Arg(s.LogoUUID),
		}})
	}

	if !s.Slug.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "slug")...),
			psql.Arg(s.Slug),
		}})
	}

	return exprs
}

// FindOrganization retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindOrganization(ctx context.Context, exec bob.Executor, IDPK int32, cols ...string) (*Organization, error) {
	if len(cols) == 0 {
		return Organizations.Query(
			sm.Where(Organizations.Columns.ID.EQ(psql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return Organizations.Query(
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(IDPK))),
		sm.Columns(Organizations.Columns.Only(cols...)),
	).One(ctx, exec)
}

// OrganizationExists checks the presence of a single record by primary key
func OrganizationExists(ctx context.Context, exec bob.Executor, IDPK int32) (bool, error) {
	return Organizations.Query(
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Organization is retrieved from the database
func (o *Organization) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Organizations.AfterSelectHooks.RunHooks(ctx, exec, OrganizationSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Organizations.AfterInsertHooks.RunHooks(ctx, exec, OrganizationSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Organizations.AfterUpdateHooks.RunHooks(ctx, exec, OrganizationSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Organizations.AfterDeleteHooks.RunHooks(ctx, exec, OrganizationSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Organization
func (o *Organization) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *Organization) pkEQ() dialect.Expression {
	return psql.Quote("organization", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Organization
func (o *Organization) Update(ctx context.Context, exec bob.Executor, s *OrganizationSetter) error {
	v, err := Organizations.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Organization record with an executor
func (o *Organization) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Organizations.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Organization using the executor
func (o *Organization) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Organizations.Query(
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after OrganizationSlice is retrieved from the database
func (o OrganizationSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Organizations.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Organizations.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Organizations.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Organizations.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o OrganizationSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("organization", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o OrganizationSlice) copyMatchingRows(from ...*Organization) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o OrganizationSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Organizations.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Organization:
				o.copyMatchingRows(retrieved)
			case []*Organization:
				o.copyMatchingRows(retrieved...)
			case OrganizationSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Organization or a slice of Organization
				// then run the AfterUpdateHooks on the slice
				_, err = Organizations.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o OrganizationSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Organizations.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Organization:
				o.copyMatchingRows(retrieved)
			case []*Organization:
				o.copyMatchingRows(retrieved...)
			case OrganizationSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Organization or a slice of Organization
				// then run the AfterDeleteHooks on the slice
				_, err = Organizations.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o OrganizationSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals OrganizationSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Organizations.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o OrganizationSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Organizations.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o OrganizationSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Organizations.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// EmailContacts starts a query for related objects on comms.email_contact
func (o *Organization) EmailContacts(mods ...bob.Mod[*dialect.SelectQuery]) CommsEmailContactsQuery {
	return CommsEmailContacts.Query(append(mods,
		sm.InnerJoin(DistrictSubscriptionEmails.NameAs()).On(
			CommsEmailContacts.Columns.Address.EQ(DistrictSubscriptionEmails.Columns.EmailContactAddress)),
		sm.Where(DistrictSubscriptionEmails.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) EmailContacts(mods ...bob.Mod[*dialect.SelectQuery]) CommsEmailContactsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return CommsEmailContacts.Query(append(mods,
		sm.InnerJoin(DistrictSubscriptionEmails.NameAs()).On(
			CommsEmailContacts.Columns.Address.EQ(DistrictSubscriptionEmails.Columns.EmailContactAddress),
		),
		sm.Where(psql.Group(DistrictSubscriptionEmails.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Phones starts a query for related objects on comms.phone
func (o *Organization) Phones(mods ...bob.Mod[*dialect.SelectQuery]) CommsPhonesQuery {
	return CommsPhones.Query(append(mods,
		sm.InnerJoin(DistrictSubscriptionPhones.NameAs()).On(
			CommsPhones.Columns.E164.EQ(DistrictSubscriptionPhones.Columns.PhoneE164)),
		sm.Where(DistrictSubscriptionPhones.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Phones(mods ...bob.Mod[*dialect.SelectQuery]) CommsPhonesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return CommsPhones.Query(append(mods,
		sm.InnerJoin(DistrictSubscriptionPhones.NameAs()).On(
			CommsPhones.Columns.E164.EQ(DistrictSubscriptionPhones.Columns.PhoneE164),
		),
		sm.Where(psql.Group(DistrictSubscriptionPhones.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Containerrelates starts a query for related objects on fieldseeker.containerrelate
func (o *Organization) Containerrelates(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerContainerrelatesQuery {
	return FieldseekerContainerrelates.Query(append(mods,
		sm.Where(FieldseekerContainerrelates.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Containerrelates(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerContainerrelatesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerContainerrelates.Query(append(mods,
		sm.Where(psql.Group(FieldseekerContainerrelates.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Fieldscoutinglogs starts a query for related objects on fieldseeker.fieldscoutinglog
func (o *Organization) Fieldscoutinglogs(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerFieldscoutinglogsQuery {
	return FieldseekerFieldscoutinglogs.Query(append(mods,
		sm.Where(FieldseekerFieldscoutinglogs.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Fieldscoutinglogs(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerFieldscoutinglogsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerFieldscoutinglogs.Query(append(mods,
		sm.Where(psql.Group(FieldseekerFieldscoutinglogs.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Habitatrelates starts a query for related objects on fieldseeker.habitatrelate
func (o *Organization) Habitatrelates(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerHabitatrelatesQuery {
	return FieldseekerHabitatrelates.Query(append(mods,
		sm.Where(FieldseekerHabitatrelates.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Habitatrelates(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerHabitatrelatesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerHabitatrelates.Query(append(mods,
		sm.Where(psql.Group(FieldseekerHabitatrelates.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Inspectionsamples starts a query for related objects on fieldseeker.inspectionsample
func (o *Organization) Inspectionsamples(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerInspectionsamplesQuery {
	return FieldseekerInspectionsamples.Query(append(mods,
		sm.Where(FieldseekerInspectionsamples.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Inspectionsamples(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerInspectionsamplesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerInspectionsamples.Query(append(mods,
		sm.Where(psql.Group(FieldseekerInspectionsamples.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Inspectionsampledetails starts a query for related objects on fieldseeker.inspectionsampledetail
func (o *Organization) Inspectionsampledetails(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerInspectionsampledetailsQuery {
	return FieldseekerInspectionsampledetails.Query(append(mods,
		sm.Where(FieldseekerInspectionsampledetails.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Inspectionsampledetails(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerInspectionsampledetailsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerInspectionsampledetails.Query(append(mods,
		sm.Where(psql.Group(FieldseekerInspectionsampledetails.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Linelocations starts a query for related objects on fieldseeker.linelocation
func (o *Organization) Linelocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerLinelocationsQuery {
	return FieldseekerLinelocations.Query(append(mods,
		sm.Where(FieldseekerLinelocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Linelocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerLinelocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerLinelocations.Query(append(mods,
		sm.Where(psql.Group(FieldseekerLinelocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Locationtrackings starts a query for related objects on fieldseeker.locationtracking
func (o *Organization) Locationtrackings(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerLocationtrackingsQuery {
	return FieldseekerLocationtrackings.Query(append(mods,
		sm.Where(FieldseekerLocationtrackings.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Locationtrackings(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerLocationtrackingsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerLocationtrackings.Query(append(mods,
		sm.Where(psql.Group(FieldseekerLocationtrackings.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Mosquitoinspections starts a query for related objects on fieldseeker.mosquitoinspection
func (o *Organization) Mosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerMosquitoinspectionsQuery {
	return FieldseekerMosquitoinspections.Query(append(mods,
		sm.Where(FieldseekerMosquitoinspections.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Mosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerMosquitoinspectionsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerMosquitoinspections.Query(append(mods,
		sm.Where(psql.Group(FieldseekerMosquitoinspections.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Pointlocations starts a query for related objects on fieldseeker.pointlocation
func (o *Organization) Pointlocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerPointlocationsQuery {
	return FieldseekerPointlocations.Query(append(mods,
		sm.Where(FieldseekerPointlocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Pointlocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerPointlocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerPointlocations.Query(append(mods,
		sm.Where(psql.Group(FieldseekerPointlocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Polygonlocations starts a query for related objects on fieldseeker.polygonlocation
func (o *Organization) Polygonlocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerPolygonlocationsQuery {
	return FieldseekerPolygonlocations.Query(append(mods,
		sm.Where(FieldseekerPolygonlocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Polygonlocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerPolygonlocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerPolygonlocations.Query(append(mods,
		sm.Where(psql.Group(FieldseekerPolygonlocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FieldseekerPool starts a query for related objects on fieldseeker.pool
func (o *Organization) FieldseekerPool(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerPoolsQuery {
	return FieldseekerPools.Query(append(mods,
		sm.Where(FieldseekerPools.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FieldseekerPool(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerPoolsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerPools.Query(append(mods,
		sm.Where(psql.Group(FieldseekerPools.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Pooldetails starts a query for related objects on fieldseeker.pooldetail
func (o *Organization) Pooldetails(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerPooldetailsQuery {
	return FieldseekerPooldetails.Query(append(mods,
		sm.Where(FieldseekerPooldetails.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Pooldetails(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerPooldetailsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerPooldetails.Query(append(mods,
		sm.Where(psql.Group(FieldseekerPooldetails.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Proposedtreatmentareas starts a query for related objects on fieldseeker.proposedtreatmentarea
func (o *Organization) Proposedtreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerProposedtreatmentareasQuery {
	return FieldseekerProposedtreatmentareas.Query(append(mods,
		sm.Where(FieldseekerProposedtreatmentareas.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Proposedtreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerProposedtreatmentareasQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerProposedtreatmentareas.Query(append(mods,
		sm.Where(psql.Group(FieldseekerProposedtreatmentareas.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Qamosquitoinspections starts a query for related objects on fieldseeker.qamosquitoinspection
func (o *Organization) Qamosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerQamosquitoinspectionsQuery {
	return FieldseekerQamosquitoinspections.Query(append(mods,
		sm.Where(FieldseekerQamosquitoinspections.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Qamosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerQamosquitoinspectionsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerQamosquitoinspections.Query(append(mods,
		sm.Where(psql.Group(FieldseekerQamosquitoinspections.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Rodentlocations starts a query for related objects on fieldseeker.rodentlocation
func (o *Organization) Rodentlocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerRodentlocationsQuery {
	return FieldseekerRodentlocations.Query(append(mods,
		sm.Where(FieldseekerRodentlocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Rodentlocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerRodentlocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerRodentlocations.Query(append(mods,
		sm.Where(psql.Group(FieldseekerRodentlocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Samplecollections starts a query for related objects on fieldseeker.samplecollection
func (o *Organization) Samplecollections(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerSamplecollectionsQuery {
	return FieldseekerSamplecollections.Query(append(mods,
		sm.Where(FieldseekerSamplecollections.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Samplecollections(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerSamplecollectionsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerSamplecollections.Query(append(mods,
		sm.Where(psql.Group(FieldseekerSamplecollections.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Samplelocations starts a query for related objects on fieldseeker.samplelocation
func (o *Organization) Samplelocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerSamplelocationsQuery {
	return FieldseekerSamplelocations.Query(append(mods,
		sm.Where(FieldseekerSamplelocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Samplelocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerSamplelocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerSamplelocations.Query(append(mods,
		sm.Where(psql.Group(FieldseekerSamplelocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Servicerequests starts a query for related objects on fieldseeker.servicerequest
func (o *Organization) Servicerequests(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerServicerequestsQuery {
	return FieldseekerServicerequests.Query(append(mods,
		sm.Where(FieldseekerServicerequests.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Servicerequests(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerServicerequestsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerServicerequests.Query(append(mods,
		sm.Where(psql.Group(FieldseekerServicerequests.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Speciesabundances starts a query for related objects on fieldseeker.speciesabundance
func (o *Organization) Speciesabundances(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerSpeciesabundancesQuery {
	return FieldseekerSpeciesabundances.Query(append(mods,
		sm.Where(FieldseekerSpeciesabundances.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Speciesabundances(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerSpeciesabundancesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerSpeciesabundances.Query(append(mods,
		sm.Where(psql.Group(FieldseekerSpeciesabundances.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Stormdrains starts a query for related objects on fieldseeker.stormdrain
func (o *Organization) Stormdrains(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerStormdrainsQuery {
	return FieldseekerStormdrains.Query(append(mods,
		sm.Where(FieldseekerStormdrains.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Stormdrains(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerStormdrainsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerStormdrains.Query(append(mods,
		sm.Where(psql.Group(FieldseekerStormdrains.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Timecards starts a query for related objects on fieldseeker.timecard
func (o *Organization) Timecards(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTimecardsQuery {
	return FieldseekerTimecards.Query(append(mods,
		sm.Where(FieldseekerTimecards.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Timecards(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTimecardsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerTimecards.Query(append(mods,
		sm.Where(psql.Group(FieldseekerTimecards.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Trapdata starts a query for related objects on fieldseeker.trapdata
func (o *Organization) Trapdata(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTrapdataQuery {
	return FieldseekerTrapdata.Query(append(mods,
		sm.Where(FieldseekerTrapdata.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Trapdata(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTrapdataQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerTrapdata.Query(append(mods,
		sm.Where(psql.Group(FieldseekerTrapdata.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Traplocations starts a query for related objects on fieldseeker.traplocation
func (o *Organization) Traplocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTraplocationsQuery {
	return FieldseekerTraplocations.Query(append(mods,
		sm.Where(FieldseekerTraplocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Traplocations(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTraplocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerTraplocations.Query(append(mods,
		sm.Where(psql.Group(FieldseekerTraplocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Treatments starts a query for related objects on fieldseeker.treatment
func (o *Organization) Treatments(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTreatmentsQuery {
	return FieldseekerTreatments.Query(append(mods,
		sm.Where(FieldseekerTreatments.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Treatments(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTreatmentsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerTreatments.Query(append(mods,
		sm.Where(psql.Group(FieldseekerTreatments.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Treatmentareas starts a query for related objects on fieldseeker.treatmentarea
func (o *Organization) Treatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTreatmentareasQuery {
	return FieldseekerTreatmentareas.Query(append(mods,
		sm.Where(FieldseekerTreatmentareas.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Treatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerTreatmentareasQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerTreatmentareas.Query(append(mods,
		sm.Where(psql.Group(FieldseekerTreatmentareas.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Zones starts a query for related objects on fieldseeker.zones
func (o *Organization) Zones(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerZonesQuery {
	return FieldseekerZones.Query(append(mods,
		sm.Where(FieldseekerZones.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Zones(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerZonesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerZones.Query(append(mods,
		sm.Where(psql.Group(FieldseekerZones.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Zones2s starts a query for related objects on fieldseeker.zones2
func (o *Organization) Zones2s(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerZones2sQuery {
	return FieldseekerZones2s.Query(append(mods,
		sm.Where(FieldseekerZones2s.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Zones2s(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerZones2sQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerZones2s.Query(append(mods,
		sm.Where(psql.Group(FieldseekerZones2s.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FieldseekerSyncs starts a query for related objects on fieldseeker_sync
func (o *Organization) FieldseekerSyncs(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerSyncsQuery {
	return FieldseekerSyncs.Query(append(mods,
		sm.Where(FieldseekerSyncs.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FieldseekerSyncs(mods ...bob.Mod[*dialect.SelectQuery]) FieldseekerSyncsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FieldseekerSyncs.Query(append(mods,
		sm.Where(psql.Group(FieldseekerSyncs.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Files starts a query for related objects on fileupload.file
func (o *Organization) Files(mods ...bob.Mod[*dialect.SelectQuery]) FileuploadFilesQuery {
	return FileuploadFiles.Query(append(mods,
		sm.Where(FileuploadFiles.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Files(mods ...bob.Mod[*dialect.SelectQuery]) FileuploadFilesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FileuploadFiles.Query(append(mods,
		sm.Where(psql.Group(FileuploadFiles.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// H3Aggregations starts a query for related objects on h3_aggregation
func (o *Organization) H3Aggregations(mods ...bob.Mod[*dialect.SelectQuery]) H3AggregationsQuery {
	return H3Aggregations.Query(append(mods,
		sm.Where(H3Aggregations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) H3Aggregations(mods ...bob.Mod[*dialect.SelectQuery]) H3AggregationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return H3Aggregations.Query(append(mods,
		sm.Where(psql.Group(H3Aggregations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// NoteAudios starts a query for related objects on note_audio
func (o *Organization) NoteAudios(mods ...bob.Mod[*dialect.SelectQuery]) NoteAudiosQuery {
	return NoteAudios.Query(append(mods,
		sm.Where(NoteAudios.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) NoteAudios(mods ...bob.Mod[*dialect.SelectQuery]) NoteAudiosQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return NoteAudios.Query(append(mods,
		sm.Where(psql.Group(NoteAudios.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// NoteImages starts a query for related objects on note_image
func (o *Organization) NoteImages(mods ...bob.Mod[*dialect.SelectQuery]) NoteImagesQuery {
	return NoteImages.Query(append(mods,
		sm.Where(NoteImages.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) NoteImages(mods ...bob.Mod[*dialect.SelectQuery]) NoteImagesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return NoteImages.Query(append(mods,
		sm.Where(psql.Group(NoteImages.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// ImportDistrictGidDistrict starts a query for related objects on import.district
func (o *Organization) ImportDistrictGidDistrict(mods ...bob.Mod[*dialect.SelectQuery]) ImportDistrictsQuery {
	return ImportDistricts.Query(append(mods,
		sm.Where(ImportDistricts.Columns.Gid.EQ(psql.Arg(o.ImportDistrictGid))),
	)...)
}

func (os OrganizationSlice) ImportDistrictGidDistrict(mods ...bob.Mod[*dialect.SelectQuery]) ImportDistrictsQuery {
	pkImportDistrictGid := make(pgtypes.Array[null.Val[int32]], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkImportDistrictGid = append(pkImportDistrictGid, o.ImportDistrictGid)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkImportDistrictGid), "integer[]")),
	))

	return ImportDistricts.Query(append(mods,
		sm.Where(psql.Group(ImportDistricts.Columns.Gid).OP("IN", PKArgExpr)),
	)...)
}

// Pools starts a query for related objects on pool
func (o *Organization) Pools(mods ...bob.Mod[*dialect.SelectQuery]) PoolsQuery {
	return Pools.Query(append(mods,
		sm.Where(Pools.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Pools(mods ...bob.Mod[*dialect.SelectQuery]) PoolsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return Pools.Query(append(mods,
		sm.Where(psql.Group(Pools.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Nuisances starts a query for related objects on publicreport.nuisance
func (o *Organization) Nuisances(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportNuisancesQuery {
	return PublicreportNuisances.Query(append(mods,
		sm.Where(PublicreportNuisances.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Nuisances(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportNuisancesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return PublicreportNuisances.Query(append(mods,
		sm.Where(psql.Group(PublicreportNuisances.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// PublicreportPool starts a query for related objects on publicreport.pool
func (o *Organization) PublicreportPool(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportPoolsQuery {
	return PublicreportPools.Query(append(mods,
		sm.Where(PublicreportPools.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) PublicreportPool(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportPoolsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return PublicreportPools.Query(append(mods,
		sm.Where(psql.Group(PublicreportPools.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// Quicks starts a query for related objects on publicreport.quick
func (o *Organization) Quicks(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportQuicksQuery {
	return PublicreportQuicks.Query(append(mods,
		sm.Where(PublicreportQuicks.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) Quicks(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportQuicksQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return PublicreportQuicks.Query(append(mods,
		sm.Where(psql.Group(PublicreportQuicks.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// User starts a query for related objects on user_
func (o *Organization) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(Users.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(Users.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

func attachOrganizationEmailContacts0(ctx context.Context, exec bob.Executor, count int, organization0 *Organization, commsEmailContacts2 CommsEmailContactSlice) (DistrictSubscriptionEmailSlice, error) {
	setters := make([]*DistrictSubscriptionEmailSetter, count)
	for i := range count {
		setters[i] = &DistrictSubscriptionEmailSetter{
			OrganizationID:      omit.From(organization0.ID),
			EmailContactAddress: omit.From(commsEmailContacts2[i].Address),
		}
	}

	districtSubscriptionEmails1, err := DistrictSubscriptionEmails.Insert(bob.ToMods(setters...)).All(ctx, exec)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationEmailContacts0: %w", err)
	}

	return districtSubscriptionEmails1, nil
}

func (organization0 *Organization) InsertEmailContacts(ctx context.Context, exec bob.Executor, related ...*CommsEmailContactSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	inserted, err := CommsEmailContacts.Insert(bob.ToMods(related...)).All(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	commsEmailContacts2 := CommsEmailContactSlice(inserted)

	_, err = attachOrganizationEmailContacts0(ctx, exec, len(related), organization0, commsEmailContacts2)
	if err != nil {
		return err
	}

	organization0.R.EmailContacts = append(organization0.R.EmailContacts, commsEmailContacts2...)

	for _, rel := range commsEmailContacts2 {
		rel.R.Organizations = append(rel.R.Organizations, organization0)
	}
	return nil
}

func (organization0 *Organization) AttachEmailContacts(ctx context.Context, exec bob.Executor, related ...*CommsEmailContact) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	commsEmailContacts2 := CommsEmailContactSlice(related)

	_, err = attachOrganizationEmailContacts0(ctx, exec, len(related), organization0, commsEmailContacts2)
	if err != nil {
		return err
	}

	organization0.R.EmailContacts = append(organization0.R.EmailContacts, commsEmailContacts2...)

	for _, rel := range related {
		rel.R.Organizations = append(rel.R.Organizations, organization0)
	}

	return nil
}

func attachOrganizationPhones0(ctx context.Context, exec bob.Executor, count int, organization0 *Organization, commsPhones2 CommsPhoneSlice) (DistrictSubscriptionPhoneSlice, error) {
	setters := make([]*DistrictSubscriptionPhoneSetter, count)
	for i := range count {
		setters[i] = &DistrictSubscriptionPhoneSetter{
			OrganizationID: omit.From(organization0.ID),
			PhoneE164:      omit.From(commsPhones2[i].E164),
		}
	}

	districtSubscriptionPhones1, err := DistrictSubscriptionPhones.Insert(bob.ToMods(setters...)).All(ctx, exec)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationPhones0: %w", err)
	}

	return districtSubscriptionPhones1, nil
}

func (organization0 *Organization) InsertPhones(ctx context.Context, exec bob.Executor, related ...*CommsPhoneSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	inserted, err := CommsPhones.Insert(bob.ToMods(related...)).All(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	commsPhones2 := CommsPhoneSlice(inserted)

	_, err = attachOrganizationPhones0(ctx, exec, len(related), organization0, commsPhones2)
	if err != nil {
		return err
	}

	organization0.R.Phones = append(organization0.R.Phones, commsPhones2...)

	for _, rel := range commsPhones2 {
		rel.R.Organizations = append(rel.R.Organizations, organization0)
	}
	return nil
}

func (organization0 *Organization) AttachPhones(ctx context.Context, exec bob.Executor, related ...*CommsPhone) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	commsPhones2 := CommsPhoneSlice(related)

	_, err = attachOrganizationPhones0(ctx, exec, len(related), organization0, commsPhones2)
	if err != nil {
		return err
	}

	organization0.R.Phones = append(organization0.R.Phones, commsPhones2...)

	for _, rel := range related {
		rel.R.Organizations = append(rel.R.Organizations, organization0)
	}

	return nil
}

func insertOrganizationContainerrelates0(ctx context.Context, exec bob.Executor, fieldseekerContainerrelates1 []*FieldseekerContainerrelateSetter, organization0 *Organization) (FieldseekerContainerrelateSlice, error) {
	for i := range fieldseekerContainerrelates1 {
		fieldseekerContainerrelates1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerContainerrelates.Insert(bob.ToMods(fieldseekerContainerrelates1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationContainerrelates0: %w", err)
	}

	return ret, nil
}

func attachOrganizationContainerrelates0(ctx context.Context, exec bob.Executor, count int, fieldseekerContainerrelates1 FieldseekerContainerrelateSlice, organization0 *Organization) (FieldseekerContainerrelateSlice, error) {
	setter := &FieldseekerContainerrelateSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerContainerrelates1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationContainerrelates0: %w", err)
	}

	return fieldseekerContainerrelates1, nil
}

func (organization0 *Organization) InsertContainerrelates(ctx context.Context, exec bob.Executor, related ...*FieldseekerContainerrelateSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerContainerrelates1, err := insertOrganizationContainerrelates0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Containerrelates = append(organization0.R.Containerrelates, fieldseekerContainerrelates1...)

	for _, rel := range fieldseekerContainerrelates1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachContainerrelates(ctx context.Context, exec bob.Executor, related ...*FieldseekerContainerrelate) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerContainerrelates1 := FieldseekerContainerrelateSlice(related)

	_, err = attachOrganizationContainerrelates0(ctx, exec, len(related), fieldseekerContainerrelates1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Containerrelates = append(organization0.R.Containerrelates, fieldseekerContainerrelates1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFieldscoutinglogs0(ctx context.Context, exec bob.Executor, fieldseekerFieldscoutinglogs1 []*FieldseekerFieldscoutinglogSetter, organization0 *Organization) (FieldseekerFieldscoutinglogSlice, error) {
	for i := range fieldseekerFieldscoutinglogs1 {
		fieldseekerFieldscoutinglogs1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerFieldscoutinglogs.Insert(bob.ToMods(fieldseekerFieldscoutinglogs1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFieldscoutinglogs0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFieldscoutinglogs0(ctx context.Context, exec bob.Executor, count int, fieldseekerFieldscoutinglogs1 FieldseekerFieldscoutinglogSlice, organization0 *Organization) (FieldseekerFieldscoutinglogSlice, error) {
	setter := &FieldseekerFieldscoutinglogSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerFieldscoutinglogs1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFieldscoutinglogs0: %w", err)
	}

	return fieldseekerFieldscoutinglogs1, nil
}

func (organization0 *Organization) InsertFieldscoutinglogs(ctx context.Context, exec bob.Executor, related ...*FieldseekerFieldscoutinglogSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerFieldscoutinglogs1, err := insertOrganizationFieldscoutinglogs0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Fieldscoutinglogs = append(organization0.R.Fieldscoutinglogs, fieldseekerFieldscoutinglogs1...)

	for _, rel := range fieldseekerFieldscoutinglogs1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFieldscoutinglogs(ctx context.Context, exec bob.Executor, related ...*FieldseekerFieldscoutinglog) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerFieldscoutinglogs1 := FieldseekerFieldscoutinglogSlice(related)

	_, err = attachOrganizationFieldscoutinglogs0(ctx, exec, len(related), fieldseekerFieldscoutinglogs1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Fieldscoutinglogs = append(organization0.R.Fieldscoutinglogs, fieldseekerFieldscoutinglogs1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHabitatrelates0(ctx context.Context, exec bob.Executor, fieldseekerHabitatrelates1 []*FieldseekerHabitatrelateSetter, organization0 *Organization) (FieldseekerHabitatrelateSlice, error) {
	for i := range fieldseekerHabitatrelates1 {
		fieldseekerHabitatrelates1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerHabitatrelates.Insert(bob.ToMods(fieldseekerHabitatrelates1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHabitatrelates0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHabitatrelates0(ctx context.Context, exec bob.Executor, count int, fieldseekerHabitatrelates1 FieldseekerHabitatrelateSlice, organization0 *Organization) (FieldseekerHabitatrelateSlice, error) {
	setter := &FieldseekerHabitatrelateSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerHabitatrelates1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHabitatrelates0: %w", err)
	}

	return fieldseekerHabitatrelates1, nil
}

func (organization0 *Organization) InsertHabitatrelates(ctx context.Context, exec bob.Executor, related ...*FieldseekerHabitatrelateSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerHabitatrelates1, err := insertOrganizationHabitatrelates0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Habitatrelates = append(organization0.R.Habitatrelates, fieldseekerHabitatrelates1...)

	for _, rel := range fieldseekerHabitatrelates1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHabitatrelates(ctx context.Context, exec bob.Executor, related ...*FieldseekerHabitatrelate) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerHabitatrelates1 := FieldseekerHabitatrelateSlice(related)

	_, err = attachOrganizationHabitatrelates0(ctx, exec, len(related), fieldseekerHabitatrelates1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Habitatrelates = append(organization0.R.Habitatrelates, fieldseekerHabitatrelates1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationInspectionsamples0(ctx context.Context, exec bob.Executor, fieldseekerInspectionsamples1 []*FieldseekerInspectionsampleSetter, organization0 *Organization) (FieldseekerInspectionsampleSlice, error) {
	for i := range fieldseekerInspectionsamples1 {
		fieldseekerInspectionsamples1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerInspectionsamples.Insert(bob.ToMods(fieldseekerInspectionsamples1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationInspectionsamples0: %w", err)
	}

	return ret, nil
}

func attachOrganizationInspectionsamples0(ctx context.Context, exec bob.Executor, count int, fieldseekerInspectionsamples1 FieldseekerInspectionsampleSlice, organization0 *Organization) (FieldseekerInspectionsampleSlice, error) {
	setter := &FieldseekerInspectionsampleSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerInspectionsamples1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationInspectionsamples0: %w", err)
	}

	return fieldseekerInspectionsamples1, nil
}

func (organization0 *Organization) InsertInspectionsamples(ctx context.Context, exec bob.Executor, related ...*FieldseekerInspectionsampleSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerInspectionsamples1, err := insertOrganizationInspectionsamples0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Inspectionsamples = append(organization0.R.Inspectionsamples, fieldseekerInspectionsamples1...)

	for _, rel := range fieldseekerInspectionsamples1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachInspectionsamples(ctx context.Context, exec bob.Executor, related ...*FieldseekerInspectionsample) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerInspectionsamples1 := FieldseekerInspectionsampleSlice(related)

	_, err = attachOrganizationInspectionsamples0(ctx, exec, len(related), fieldseekerInspectionsamples1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Inspectionsamples = append(organization0.R.Inspectionsamples, fieldseekerInspectionsamples1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationInspectionsampledetails0(ctx context.Context, exec bob.Executor, fieldseekerInspectionsampledetails1 []*FieldseekerInspectionsampledetailSetter, organization0 *Organization) (FieldseekerInspectionsampledetailSlice, error) {
	for i := range fieldseekerInspectionsampledetails1 {
		fieldseekerInspectionsampledetails1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerInspectionsampledetails.Insert(bob.ToMods(fieldseekerInspectionsampledetails1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationInspectionsampledetails0: %w", err)
	}

	return ret, nil
}

func attachOrganizationInspectionsampledetails0(ctx context.Context, exec bob.Executor, count int, fieldseekerInspectionsampledetails1 FieldseekerInspectionsampledetailSlice, organization0 *Organization) (FieldseekerInspectionsampledetailSlice, error) {
	setter := &FieldseekerInspectionsampledetailSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerInspectionsampledetails1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationInspectionsampledetails0: %w", err)
	}

	return fieldseekerInspectionsampledetails1, nil
}

func (organization0 *Organization) InsertInspectionsampledetails(ctx context.Context, exec bob.Executor, related ...*FieldseekerInspectionsampledetailSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerInspectionsampledetails1, err := insertOrganizationInspectionsampledetails0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Inspectionsampledetails = append(organization0.R.Inspectionsampledetails, fieldseekerInspectionsampledetails1...)

	for _, rel := range fieldseekerInspectionsampledetails1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachInspectionsampledetails(ctx context.Context, exec bob.Executor, related ...*FieldseekerInspectionsampledetail) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerInspectionsampledetails1 := FieldseekerInspectionsampledetailSlice(related)

	_, err = attachOrganizationInspectionsampledetails0(ctx, exec, len(related), fieldseekerInspectionsampledetails1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Inspectionsampledetails = append(organization0.R.Inspectionsampledetails, fieldseekerInspectionsampledetails1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationLinelocations0(ctx context.Context, exec bob.Executor, fieldseekerLinelocations1 []*FieldseekerLinelocationSetter, organization0 *Organization) (FieldseekerLinelocationSlice, error) {
	for i := range fieldseekerLinelocations1 {
		fieldseekerLinelocations1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerLinelocations.Insert(bob.ToMods(fieldseekerLinelocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationLinelocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationLinelocations0(ctx context.Context, exec bob.Executor, count int, fieldseekerLinelocations1 FieldseekerLinelocationSlice, organization0 *Organization) (FieldseekerLinelocationSlice, error) {
	setter := &FieldseekerLinelocationSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerLinelocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationLinelocations0: %w", err)
	}

	return fieldseekerLinelocations1, nil
}

func (organization0 *Organization) InsertLinelocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerLinelocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerLinelocations1, err := insertOrganizationLinelocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Linelocations = append(organization0.R.Linelocations, fieldseekerLinelocations1...)

	for _, rel := range fieldseekerLinelocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachLinelocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerLinelocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerLinelocations1 := FieldseekerLinelocationSlice(related)

	_, err = attachOrganizationLinelocations0(ctx, exec, len(related), fieldseekerLinelocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Linelocations = append(organization0.R.Linelocations, fieldseekerLinelocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationLocationtrackings0(ctx context.Context, exec bob.Executor, fieldseekerLocationtrackings1 []*FieldseekerLocationtrackingSetter, organization0 *Organization) (FieldseekerLocationtrackingSlice, error) {
	for i := range fieldseekerLocationtrackings1 {
		fieldseekerLocationtrackings1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerLocationtrackings.Insert(bob.ToMods(fieldseekerLocationtrackings1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationLocationtrackings0: %w", err)
	}

	return ret, nil
}

func attachOrganizationLocationtrackings0(ctx context.Context, exec bob.Executor, count int, fieldseekerLocationtrackings1 FieldseekerLocationtrackingSlice, organization0 *Organization) (FieldseekerLocationtrackingSlice, error) {
	setter := &FieldseekerLocationtrackingSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerLocationtrackings1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationLocationtrackings0: %w", err)
	}

	return fieldseekerLocationtrackings1, nil
}

func (organization0 *Organization) InsertLocationtrackings(ctx context.Context, exec bob.Executor, related ...*FieldseekerLocationtrackingSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerLocationtrackings1, err := insertOrganizationLocationtrackings0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Locationtrackings = append(organization0.R.Locationtrackings, fieldseekerLocationtrackings1...)

	for _, rel := range fieldseekerLocationtrackings1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachLocationtrackings(ctx context.Context, exec bob.Executor, related ...*FieldseekerLocationtracking) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerLocationtrackings1 := FieldseekerLocationtrackingSlice(related)

	_, err = attachOrganizationLocationtrackings0(ctx, exec, len(related), fieldseekerLocationtrackings1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Locationtrackings = append(organization0.R.Locationtrackings, fieldseekerLocationtrackings1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationMosquitoinspections0(ctx context.Context, exec bob.Executor, fieldseekerMosquitoinspections1 []*FieldseekerMosquitoinspectionSetter, organization0 *Organization) (FieldseekerMosquitoinspectionSlice, error) {
	for i := range fieldseekerMosquitoinspections1 {
		fieldseekerMosquitoinspections1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerMosquitoinspections.Insert(bob.ToMods(fieldseekerMosquitoinspections1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationMosquitoinspections0: %w", err)
	}

	return ret, nil
}

func attachOrganizationMosquitoinspections0(ctx context.Context, exec bob.Executor, count int, fieldseekerMosquitoinspections1 FieldseekerMosquitoinspectionSlice, organization0 *Organization) (FieldseekerMosquitoinspectionSlice, error) {
	setter := &FieldseekerMosquitoinspectionSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerMosquitoinspections1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationMosquitoinspections0: %w", err)
	}

	return fieldseekerMosquitoinspections1, nil
}

func (organization0 *Organization) InsertMosquitoinspections(ctx context.Context, exec bob.Executor, related ...*FieldseekerMosquitoinspectionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerMosquitoinspections1, err := insertOrganizationMosquitoinspections0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Mosquitoinspections = append(organization0.R.Mosquitoinspections, fieldseekerMosquitoinspections1...)

	for _, rel := range fieldseekerMosquitoinspections1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachMosquitoinspections(ctx context.Context, exec bob.Executor, related ...*FieldseekerMosquitoinspection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerMosquitoinspections1 := FieldseekerMosquitoinspectionSlice(related)

	_, err = attachOrganizationMosquitoinspections0(ctx, exec, len(related), fieldseekerMosquitoinspections1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Mosquitoinspections = append(organization0.R.Mosquitoinspections, fieldseekerMosquitoinspections1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationPointlocations0(ctx context.Context, exec bob.Executor, fieldseekerPointlocations1 []*FieldseekerPointlocationSetter, organization0 *Organization) (FieldseekerPointlocationSlice, error) {
	for i := range fieldseekerPointlocations1 {
		fieldseekerPointlocations1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerPointlocations.Insert(bob.ToMods(fieldseekerPointlocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationPointlocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationPointlocations0(ctx context.Context, exec bob.Executor, count int, fieldseekerPointlocations1 FieldseekerPointlocationSlice, organization0 *Organization) (FieldseekerPointlocationSlice, error) {
	setter := &FieldseekerPointlocationSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerPointlocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationPointlocations0: %w", err)
	}

	return fieldseekerPointlocations1, nil
}

func (organization0 *Organization) InsertPointlocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerPointlocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerPointlocations1, err := insertOrganizationPointlocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Pointlocations = append(organization0.R.Pointlocations, fieldseekerPointlocations1...)

	for _, rel := range fieldseekerPointlocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachPointlocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerPointlocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerPointlocations1 := FieldseekerPointlocationSlice(related)

	_, err = attachOrganizationPointlocations0(ctx, exec, len(related), fieldseekerPointlocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Pointlocations = append(organization0.R.Pointlocations, fieldseekerPointlocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationPolygonlocations0(ctx context.Context, exec bob.Executor, fieldseekerPolygonlocations1 []*FieldseekerPolygonlocationSetter, organization0 *Organization) (FieldseekerPolygonlocationSlice, error) {
	for i := range fieldseekerPolygonlocations1 {
		fieldseekerPolygonlocations1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerPolygonlocations.Insert(bob.ToMods(fieldseekerPolygonlocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationPolygonlocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationPolygonlocations0(ctx context.Context, exec bob.Executor, count int, fieldseekerPolygonlocations1 FieldseekerPolygonlocationSlice, organization0 *Organization) (FieldseekerPolygonlocationSlice, error) {
	setter := &FieldseekerPolygonlocationSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerPolygonlocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationPolygonlocations0: %w", err)
	}

	return fieldseekerPolygonlocations1, nil
}

func (organization0 *Organization) InsertPolygonlocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerPolygonlocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerPolygonlocations1, err := insertOrganizationPolygonlocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Polygonlocations = append(organization0.R.Polygonlocations, fieldseekerPolygonlocations1...)

	for _, rel := range fieldseekerPolygonlocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachPolygonlocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerPolygonlocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerPolygonlocations1 := FieldseekerPolygonlocationSlice(related)

	_, err = attachOrganizationPolygonlocations0(ctx, exec, len(related), fieldseekerPolygonlocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Polygonlocations = append(organization0.R.Polygonlocations, fieldseekerPolygonlocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFieldseekerPool0(ctx context.Context, exec bob.Executor, fieldseekerPools1 []*FieldseekerPoolSetter, organization0 *Organization) (FieldseekerPoolSlice, error) {
	for i := range fieldseekerPools1 {
		fieldseekerPools1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerPools.Insert(bob.ToMods(fieldseekerPools1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFieldseekerPool0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFieldseekerPool0(ctx context.Context, exec bob.Executor, count int, fieldseekerPools1 FieldseekerPoolSlice, organization0 *Organization) (FieldseekerPoolSlice, error) {
	setter := &FieldseekerPoolSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerPools1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFieldseekerPool0: %w", err)
	}

	return fieldseekerPools1, nil
}

func (organization0 *Organization) InsertFieldseekerPool(ctx context.Context, exec bob.Executor, related ...*FieldseekerPoolSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerPools1, err := insertOrganizationFieldseekerPool0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FieldseekerPool = append(organization0.R.FieldseekerPool, fieldseekerPools1...)

	for _, rel := range fieldseekerPools1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFieldseekerPool(ctx context.Context, exec bob.Executor, related ...*FieldseekerPool) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerPools1 := FieldseekerPoolSlice(related)

	_, err = attachOrganizationFieldseekerPool0(ctx, exec, len(related), fieldseekerPools1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FieldseekerPool = append(organization0.R.FieldseekerPool, fieldseekerPools1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationPooldetails0(ctx context.Context, exec bob.Executor, fieldseekerPooldetails1 []*FieldseekerPooldetailSetter, organization0 *Organization) (FieldseekerPooldetailSlice, error) {
	for i := range fieldseekerPooldetails1 {
		fieldseekerPooldetails1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerPooldetails.Insert(bob.ToMods(fieldseekerPooldetails1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationPooldetails0: %w", err)
	}

	return ret, nil
}

func attachOrganizationPooldetails0(ctx context.Context, exec bob.Executor, count int, fieldseekerPooldetails1 FieldseekerPooldetailSlice, organization0 *Organization) (FieldseekerPooldetailSlice, error) {
	setter := &FieldseekerPooldetailSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerPooldetails1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationPooldetails0: %w", err)
	}

	return fieldseekerPooldetails1, nil
}

func (organization0 *Organization) InsertPooldetails(ctx context.Context, exec bob.Executor, related ...*FieldseekerPooldetailSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerPooldetails1, err := insertOrganizationPooldetails0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Pooldetails = append(organization0.R.Pooldetails, fieldseekerPooldetails1...)

	for _, rel := range fieldseekerPooldetails1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachPooldetails(ctx context.Context, exec bob.Executor, related ...*FieldseekerPooldetail) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerPooldetails1 := FieldseekerPooldetailSlice(related)

	_, err = attachOrganizationPooldetails0(ctx, exec, len(related), fieldseekerPooldetails1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Pooldetails = append(organization0.R.Pooldetails, fieldseekerPooldetails1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationProposedtreatmentareas0(ctx context.Context, exec bob.Executor, fieldseekerProposedtreatmentareas1 []*FieldseekerProposedtreatmentareaSetter, organization0 *Organization) (FieldseekerProposedtreatmentareaSlice, error) {
	for i := range fieldseekerProposedtreatmentareas1 {
		fieldseekerProposedtreatmentareas1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerProposedtreatmentareas.Insert(bob.ToMods(fieldseekerProposedtreatmentareas1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationProposedtreatmentareas0: %w", err)
	}

	return ret, nil
}

func attachOrganizationProposedtreatmentareas0(ctx context.Context, exec bob.Executor, count int, fieldseekerProposedtreatmentareas1 FieldseekerProposedtreatmentareaSlice, organization0 *Organization) (FieldseekerProposedtreatmentareaSlice, error) {
	setter := &FieldseekerProposedtreatmentareaSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerProposedtreatmentareas1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationProposedtreatmentareas0: %w", err)
	}

	return fieldseekerProposedtreatmentareas1, nil
}

func (organization0 *Organization) InsertProposedtreatmentareas(ctx context.Context, exec bob.Executor, related ...*FieldseekerProposedtreatmentareaSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerProposedtreatmentareas1, err := insertOrganizationProposedtreatmentareas0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Proposedtreatmentareas = append(organization0.R.Proposedtreatmentareas, fieldseekerProposedtreatmentareas1...)

	for _, rel := range fieldseekerProposedtreatmentareas1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachProposedtreatmentareas(ctx context.Context, exec bob.Executor, related ...*FieldseekerProposedtreatmentarea) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerProposedtreatmentareas1 := FieldseekerProposedtreatmentareaSlice(related)

	_, err = attachOrganizationProposedtreatmentareas0(ctx, exec, len(related), fieldseekerProposedtreatmentareas1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Proposedtreatmentareas = append(organization0.R.Proposedtreatmentareas, fieldseekerProposedtreatmentareas1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationQamosquitoinspections0(ctx context.Context, exec bob.Executor, fieldseekerQamosquitoinspections1 []*FieldseekerQamosquitoinspectionSetter, organization0 *Organization) (FieldseekerQamosquitoinspectionSlice, error) {
	for i := range fieldseekerQamosquitoinspections1 {
		fieldseekerQamosquitoinspections1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerQamosquitoinspections.Insert(bob.ToMods(fieldseekerQamosquitoinspections1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationQamosquitoinspections0: %w", err)
	}

	return ret, nil
}

func attachOrganizationQamosquitoinspections0(ctx context.Context, exec bob.Executor, count int, fieldseekerQamosquitoinspections1 FieldseekerQamosquitoinspectionSlice, organization0 *Organization) (FieldseekerQamosquitoinspectionSlice, error) {
	setter := &FieldseekerQamosquitoinspectionSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerQamosquitoinspections1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationQamosquitoinspections0: %w", err)
	}

	return fieldseekerQamosquitoinspections1, nil
}

func (organization0 *Organization) InsertQamosquitoinspections(ctx context.Context, exec bob.Executor, related ...*FieldseekerQamosquitoinspectionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerQamosquitoinspections1, err := insertOrganizationQamosquitoinspections0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Qamosquitoinspections = append(organization0.R.Qamosquitoinspections, fieldseekerQamosquitoinspections1...)

	for _, rel := range fieldseekerQamosquitoinspections1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachQamosquitoinspections(ctx context.Context, exec bob.Executor, related ...*FieldseekerQamosquitoinspection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerQamosquitoinspections1 := FieldseekerQamosquitoinspectionSlice(related)

	_, err = attachOrganizationQamosquitoinspections0(ctx, exec, len(related), fieldseekerQamosquitoinspections1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Qamosquitoinspections = append(organization0.R.Qamosquitoinspections, fieldseekerQamosquitoinspections1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationRodentlocations0(ctx context.Context, exec bob.Executor, fieldseekerRodentlocations1 []*FieldseekerRodentlocationSetter, organization0 *Organization) (FieldseekerRodentlocationSlice, error) {
	for i := range fieldseekerRodentlocations1 {
		fieldseekerRodentlocations1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerRodentlocations.Insert(bob.ToMods(fieldseekerRodentlocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationRodentlocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationRodentlocations0(ctx context.Context, exec bob.Executor, count int, fieldseekerRodentlocations1 FieldseekerRodentlocationSlice, organization0 *Organization) (FieldseekerRodentlocationSlice, error) {
	setter := &FieldseekerRodentlocationSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerRodentlocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationRodentlocations0: %w", err)
	}

	return fieldseekerRodentlocations1, nil
}

func (organization0 *Organization) InsertRodentlocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerRodentlocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerRodentlocations1, err := insertOrganizationRodentlocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Rodentlocations = append(organization0.R.Rodentlocations, fieldseekerRodentlocations1...)

	for _, rel := range fieldseekerRodentlocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachRodentlocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerRodentlocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerRodentlocations1 := FieldseekerRodentlocationSlice(related)

	_, err = attachOrganizationRodentlocations0(ctx, exec, len(related), fieldseekerRodentlocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Rodentlocations = append(organization0.R.Rodentlocations, fieldseekerRodentlocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationSamplecollections0(ctx context.Context, exec bob.Executor, fieldseekerSamplecollections1 []*FieldseekerSamplecollectionSetter, organization0 *Organization) (FieldseekerSamplecollectionSlice, error) {
	for i := range fieldseekerSamplecollections1 {
		fieldseekerSamplecollections1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerSamplecollections.Insert(bob.ToMods(fieldseekerSamplecollections1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationSamplecollections0: %w", err)
	}

	return ret, nil
}

func attachOrganizationSamplecollections0(ctx context.Context, exec bob.Executor, count int, fieldseekerSamplecollections1 FieldseekerSamplecollectionSlice, organization0 *Organization) (FieldseekerSamplecollectionSlice, error) {
	setter := &FieldseekerSamplecollectionSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerSamplecollections1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationSamplecollections0: %w", err)
	}

	return fieldseekerSamplecollections1, nil
}

func (organization0 *Organization) InsertSamplecollections(ctx context.Context, exec bob.Executor, related ...*FieldseekerSamplecollectionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerSamplecollections1, err := insertOrganizationSamplecollections0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Samplecollections = append(organization0.R.Samplecollections, fieldseekerSamplecollections1...)

	for _, rel := range fieldseekerSamplecollections1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachSamplecollections(ctx context.Context, exec bob.Executor, related ...*FieldseekerSamplecollection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerSamplecollections1 := FieldseekerSamplecollectionSlice(related)

	_, err = attachOrganizationSamplecollections0(ctx, exec, len(related), fieldseekerSamplecollections1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Samplecollections = append(organization0.R.Samplecollections, fieldseekerSamplecollections1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationSamplelocations0(ctx context.Context, exec bob.Executor, fieldseekerSamplelocations1 []*FieldseekerSamplelocationSetter, organization0 *Organization) (FieldseekerSamplelocationSlice, error) {
	for i := range fieldseekerSamplelocations1 {
		fieldseekerSamplelocations1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerSamplelocations.Insert(bob.ToMods(fieldseekerSamplelocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationSamplelocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationSamplelocations0(ctx context.Context, exec bob.Executor, count int, fieldseekerSamplelocations1 FieldseekerSamplelocationSlice, organization0 *Organization) (FieldseekerSamplelocationSlice, error) {
	setter := &FieldseekerSamplelocationSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerSamplelocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationSamplelocations0: %w", err)
	}

	return fieldseekerSamplelocations1, nil
}

func (organization0 *Organization) InsertSamplelocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerSamplelocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerSamplelocations1, err := insertOrganizationSamplelocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Samplelocations = append(organization0.R.Samplelocations, fieldseekerSamplelocations1...)

	for _, rel := range fieldseekerSamplelocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachSamplelocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerSamplelocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerSamplelocations1 := FieldseekerSamplelocationSlice(related)

	_, err = attachOrganizationSamplelocations0(ctx, exec, len(related), fieldseekerSamplelocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Samplelocations = append(organization0.R.Samplelocations, fieldseekerSamplelocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationServicerequests0(ctx context.Context, exec bob.Executor, fieldseekerServicerequests1 []*FieldseekerServicerequestSetter, organization0 *Organization) (FieldseekerServicerequestSlice, error) {
	for i := range fieldseekerServicerequests1 {
		fieldseekerServicerequests1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerServicerequests.Insert(bob.ToMods(fieldseekerServicerequests1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationServicerequests0: %w", err)
	}

	return ret, nil
}

func attachOrganizationServicerequests0(ctx context.Context, exec bob.Executor, count int, fieldseekerServicerequests1 FieldseekerServicerequestSlice, organization0 *Organization) (FieldseekerServicerequestSlice, error) {
	setter := &FieldseekerServicerequestSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerServicerequests1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationServicerequests0: %w", err)
	}

	return fieldseekerServicerequests1, nil
}

func (organization0 *Organization) InsertServicerequests(ctx context.Context, exec bob.Executor, related ...*FieldseekerServicerequestSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerServicerequests1, err := insertOrganizationServicerequests0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Servicerequests = append(organization0.R.Servicerequests, fieldseekerServicerequests1...)

	for _, rel := range fieldseekerServicerequests1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachServicerequests(ctx context.Context, exec bob.Executor, related ...*FieldseekerServicerequest) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerServicerequests1 := FieldseekerServicerequestSlice(related)

	_, err = attachOrganizationServicerequests0(ctx, exec, len(related), fieldseekerServicerequests1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Servicerequests = append(organization0.R.Servicerequests, fieldseekerServicerequests1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationSpeciesabundances0(ctx context.Context, exec bob.Executor, fieldseekerSpeciesabundances1 []*FieldseekerSpeciesabundanceSetter, organization0 *Organization) (FieldseekerSpeciesabundanceSlice, error) {
	for i := range fieldseekerSpeciesabundances1 {
		fieldseekerSpeciesabundances1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerSpeciesabundances.Insert(bob.ToMods(fieldseekerSpeciesabundances1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationSpeciesabundances0: %w", err)
	}

	return ret, nil
}

func attachOrganizationSpeciesabundances0(ctx context.Context, exec bob.Executor, count int, fieldseekerSpeciesabundances1 FieldseekerSpeciesabundanceSlice, organization0 *Organization) (FieldseekerSpeciesabundanceSlice, error) {
	setter := &FieldseekerSpeciesabundanceSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerSpeciesabundances1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationSpeciesabundances0: %w", err)
	}

	return fieldseekerSpeciesabundances1, nil
}

func (organization0 *Organization) InsertSpeciesabundances(ctx context.Context, exec bob.Executor, related ...*FieldseekerSpeciesabundanceSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerSpeciesabundances1, err := insertOrganizationSpeciesabundances0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Speciesabundances = append(organization0.R.Speciesabundances, fieldseekerSpeciesabundances1...)

	for _, rel := range fieldseekerSpeciesabundances1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachSpeciesabundances(ctx context.Context, exec bob.Executor, related ...*FieldseekerSpeciesabundance) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerSpeciesabundances1 := FieldseekerSpeciesabundanceSlice(related)

	_, err = attachOrganizationSpeciesabundances0(ctx, exec, len(related), fieldseekerSpeciesabundances1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Speciesabundances = append(organization0.R.Speciesabundances, fieldseekerSpeciesabundances1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationStormdrains0(ctx context.Context, exec bob.Executor, fieldseekerStormdrains1 []*FieldseekerStormdrainSetter, organization0 *Organization) (FieldseekerStormdrainSlice, error) {
	for i := range fieldseekerStormdrains1 {
		fieldseekerStormdrains1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerStormdrains.Insert(bob.ToMods(fieldseekerStormdrains1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationStormdrains0: %w", err)
	}

	return ret, nil
}

func attachOrganizationStormdrains0(ctx context.Context, exec bob.Executor, count int, fieldseekerStormdrains1 FieldseekerStormdrainSlice, organization0 *Organization) (FieldseekerStormdrainSlice, error) {
	setter := &FieldseekerStormdrainSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerStormdrains1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationStormdrains0: %w", err)
	}

	return fieldseekerStormdrains1, nil
}

func (organization0 *Organization) InsertStormdrains(ctx context.Context, exec bob.Executor, related ...*FieldseekerStormdrainSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerStormdrains1, err := insertOrganizationStormdrains0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Stormdrains = append(organization0.R.Stormdrains, fieldseekerStormdrains1...)

	for _, rel := range fieldseekerStormdrains1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachStormdrains(ctx context.Context, exec bob.Executor, related ...*FieldseekerStormdrain) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerStormdrains1 := FieldseekerStormdrainSlice(related)

	_, err = attachOrganizationStormdrains0(ctx, exec, len(related), fieldseekerStormdrains1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Stormdrains = append(organization0.R.Stormdrains, fieldseekerStormdrains1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationTimecards0(ctx context.Context, exec bob.Executor, fieldseekerTimecards1 []*FieldseekerTimecardSetter, organization0 *Organization) (FieldseekerTimecardSlice, error) {
	for i := range fieldseekerTimecards1 {
		fieldseekerTimecards1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerTimecards.Insert(bob.ToMods(fieldseekerTimecards1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationTimecards0: %w", err)
	}

	return ret, nil
}

func attachOrganizationTimecards0(ctx context.Context, exec bob.Executor, count int, fieldseekerTimecards1 FieldseekerTimecardSlice, organization0 *Organization) (FieldseekerTimecardSlice, error) {
	setter := &FieldseekerTimecardSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerTimecards1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationTimecards0: %w", err)
	}

	return fieldseekerTimecards1, nil
}

func (organization0 *Organization) InsertTimecards(ctx context.Context, exec bob.Executor, related ...*FieldseekerTimecardSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerTimecards1, err := insertOrganizationTimecards0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Timecards = append(organization0.R.Timecards, fieldseekerTimecards1...)

	for _, rel := range fieldseekerTimecards1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachTimecards(ctx context.Context, exec bob.Executor, related ...*FieldseekerTimecard) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerTimecards1 := FieldseekerTimecardSlice(related)

	_, err = attachOrganizationTimecards0(ctx, exec, len(related), fieldseekerTimecards1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Timecards = append(organization0.R.Timecards, fieldseekerTimecards1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationTrapdata0(ctx context.Context, exec bob.Executor, fieldseekerTrapdata1 []*FieldseekerTrapdatumSetter, organization0 *Organization) (FieldseekerTrapdatumSlice, error) {
	for i := range fieldseekerTrapdata1 {
		fieldseekerTrapdata1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerTrapdata.Insert(bob.ToMods(fieldseekerTrapdata1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationTrapdata0: %w", err)
	}

	return ret, nil
}

func attachOrganizationTrapdata0(ctx context.Context, exec bob.Executor, count int, fieldseekerTrapdata1 FieldseekerTrapdatumSlice, organization0 *Organization) (FieldseekerTrapdatumSlice, error) {
	setter := &FieldseekerTrapdatumSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerTrapdata1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationTrapdata0: %w", err)
	}

	return fieldseekerTrapdata1, nil
}

func (organization0 *Organization) InsertTrapdata(ctx context.Context, exec bob.Executor, related ...*FieldseekerTrapdatumSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerTrapdata1, err := insertOrganizationTrapdata0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Trapdata = append(organization0.R.Trapdata, fieldseekerTrapdata1...)

	for _, rel := range fieldseekerTrapdata1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachTrapdata(ctx context.Context, exec bob.Executor, related ...*FieldseekerTrapdatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerTrapdata1 := FieldseekerTrapdatumSlice(related)

	_, err = attachOrganizationTrapdata0(ctx, exec, len(related), fieldseekerTrapdata1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Trapdata = append(organization0.R.Trapdata, fieldseekerTrapdata1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationTraplocations0(ctx context.Context, exec bob.Executor, fieldseekerTraplocations1 []*FieldseekerTraplocationSetter, organization0 *Organization) (FieldseekerTraplocationSlice, error) {
	for i := range fieldseekerTraplocations1 {
		fieldseekerTraplocations1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerTraplocations.Insert(bob.ToMods(fieldseekerTraplocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationTraplocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationTraplocations0(ctx context.Context, exec bob.Executor, count int, fieldseekerTraplocations1 FieldseekerTraplocationSlice, organization0 *Organization) (FieldseekerTraplocationSlice, error) {
	setter := &FieldseekerTraplocationSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerTraplocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationTraplocations0: %w", err)
	}

	return fieldseekerTraplocations1, nil
}

func (organization0 *Organization) InsertTraplocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerTraplocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerTraplocations1, err := insertOrganizationTraplocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Traplocations = append(organization0.R.Traplocations, fieldseekerTraplocations1...)

	for _, rel := range fieldseekerTraplocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachTraplocations(ctx context.Context, exec bob.Executor, related ...*FieldseekerTraplocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerTraplocations1 := FieldseekerTraplocationSlice(related)

	_, err = attachOrganizationTraplocations0(ctx, exec, len(related), fieldseekerTraplocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Traplocations = append(organization0.R.Traplocations, fieldseekerTraplocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationTreatments0(ctx context.Context, exec bob.Executor, fieldseekerTreatments1 []*FieldseekerTreatmentSetter, organization0 *Organization) (FieldseekerTreatmentSlice, error) {
	for i := range fieldseekerTreatments1 {
		fieldseekerTreatments1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerTreatments.Insert(bob.ToMods(fieldseekerTreatments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationTreatments0: %w", err)
	}

	return ret, nil
}

func attachOrganizationTreatments0(ctx context.Context, exec bob.Executor, count int, fieldseekerTreatments1 FieldseekerTreatmentSlice, organization0 *Organization) (FieldseekerTreatmentSlice, error) {
	setter := &FieldseekerTreatmentSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerTreatments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationTreatments0: %w", err)
	}

	return fieldseekerTreatments1, nil
}

func (organization0 *Organization) InsertTreatments(ctx context.Context, exec bob.Executor, related ...*FieldseekerTreatmentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerTreatments1, err := insertOrganizationTreatments0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Treatments = append(organization0.R.Treatments, fieldseekerTreatments1...)

	for _, rel := range fieldseekerTreatments1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachTreatments(ctx context.Context, exec bob.Executor, related ...*FieldseekerTreatment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerTreatments1 := FieldseekerTreatmentSlice(related)

	_, err = attachOrganizationTreatments0(ctx, exec, len(related), fieldseekerTreatments1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Treatments = append(organization0.R.Treatments, fieldseekerTreatments1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationTreatmentareas0(ctx context.Context, exec bob.Executor, fieldseekerTreatmentareas1 []*FieldseekerTreatmentareaSetter, organization0 *Organization) (FieldseekerTreatmentareaSlice, error) {
	for i := range fieldseekerTreatmentareas1 {
		fieldseekerTreatmentareas1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerTreatmentareas.Insert(bob.ToMods(fieldseekerTreatmentareas1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationTreatmentareas0: %w", err)
	}

	return ret, nil
}

func attachOrganizationTreatmentareas0(ctx context.Context, exec bob.Executor, count int, fieldseekerTreatmentareas1 FieldseekerTreatmentareaSlice, organization0 *Organization) (FieldseekerTreatmentareaSlice, error) {
	setter := &FieldseekerTreatmentareaSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerTreatmentareas1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationTreatmentareas0: %w", err)
	}

	return fieldseekerTreatmentareas1, nil
}

func (organization0 *Organization) InsertTreatmentareas(ctx context.Context, exec bob.Executor, related ...*FieldseekerTreatmentareaSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerTreatmentareas1, err := insertOrganizationTreatmentareas0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Treatmentareas = append(organization0.R.Treatmentareas, fieldseekerTreatmentareas1...)

	for _, rel := range fieldseekerTreatmentareas1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachTreatmentareas(ctx context.Context, exec bob.Executor, related ...*FieldseekerTreatmentarea) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerTreatmentareas1 := FieldseekerTreatmentareaSlice(related)

	_, err = attachOrganizationTreatmentareas0(ctx, exec, len(related), fieldseekerTreatmentareas1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Treatmentareas = append(organization0.R.Treatmentareas, fieldseekerTreatmentareas1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationZones0(ctx context.Context, exec bob.Executor, fieldseekerZones1 []*FieldseekerZoneSetter, organization0 *Organization) (FieldseekerZoneSlice, error) {
	for i := range fieldseekerZones1 {
		fieldseekerZones1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerZones.Insert(bob.ToMods(fieldseekerZones1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationZones0: %w", err)
	}

	return ret, nil
}

func attachOrganizationZones0(ctx context.Context, exec bob.Executor, count int, fieldseekerZones1 FieldseekerZoneSlice, organization0 *Organization) (FieldseekerZoneSlice, error) {
	setter := &FieldseekerZoneSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerZones1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationZones0: %w", err)
	}

	return fieldseekerZones1, nil
}

func (organization0 *Organization) InsertZones(ctx context.Context, exec bob.Executor, related ...*FieldseekerZoneSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerZones1, err := insertOrganizationZones0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Zones = append(organization0.R.Zones, fieldseekerZones1...)

	for _, rel := range fieldseekerZones1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachZones(ctx context.Context, exec bob.Executor, related ...*FieldseekerZone) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerZones1 := FieldseekerZoneSlice(related)

	_, err = attachOrganizationZones0(ctx, exec, len(related), fieldseekerZones1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Zones = append(organization0.R.Zones, fieldseekerZones1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationZones2s0(ctx context.Context, exec bob.Executor, fieldseekerZones2s1 []*FieldseekerZones2Setter, organization0 *Organization) (FieldseekerZones2Slice, error) {
	for i := range fieldseekerZones2s1 {
		fieldseekerZones2s1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerZones2s.Insert(bob.ToMods(fieldseekerZones2s1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationZones2s0: %w", err)
	}

	return ret, nil
}

func attachOrganizationZones2s0(ctx context.Context, exec bob.Executor, count int, fieldseekerZones2s1 FieldseekerZones2Slice, organization0 *Organization) (FieldseekerZones2Slice, error) {
	setter := &FieldseekerZones2Setter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerZones2s1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationZones2s0: %w", err)
	}

	return fieldseekerZones2s1, nil
}

func (organization0 *Organization) InsertZones2s(ctx context.Context, exec bob.Executor, related ...*FieldseekerZones2Setter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerZones2s1, err := insertOrganizationZones2s0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Zones2s = append(organization0.R.Zones2s, fieldseekerZones2s1...)

	for _, rel := range fieldseekerZones2s1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachZones2s(ctx context.Context, exec bob.Executor, related ...*FieldseekerZones2) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerZones2s1 := FieldseekerZones2Slice(related)

	_, err = attachOrganizationZones2s0(ctx, exec, len(related), fieldseekerZones2s1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Zones2s = append(organization0.R.Zones2s, fieldseekerZones2s1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFieldseekerSyncs0(ctx context.Context, exec bob.Executor, fieldseekerSyncs1 []*FieldseekerSyncSetter, organization0 *Organization) (FieldseekerSyncSlice, error) {
	for i := range fieldseekerSyncs1 {
		fieldseekerSyncs1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FieldseekerSyncs.Insert(bob.ToMods(fieldseekerSyncs1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFieldseekerSyncs0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFieldseekerSyncs0(ctx context.Context, exec bob.Executor, count int, fieldseekerSyncs1 FieldseekerSyncSlice, organization0 *Organization) (FieldseekerSyncSlice, error) {
	setter := &FieldseekerSyncSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fieldseekerSyncs1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFieldseekerSyncs0: %w", err)
	}

	return fieldseekerSyncs1, nil
}

func (organization0 *Organization) InsertFieldseekerSyncs(ctx context.Context, exec bob.Executor, related ...*FieldseekerSyncSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fieldseekerSyncs1, err := insertOrganizationFieldseekerSyncs0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FieldseekerSyncs = append(organization0.R.FieldseekerSyncs, fieldseekerSyncs1...)

	for _, rel := range fieldseekerSyncs1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFieldseekerSyncs(ctx context.Context, exec bob.Executor, related ...*FieldseekerSync) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fieldseekerSyncs1 := FieldseekerSyncSlice(related)

	_, err = attachOrganizationFieldseekerSyncs0(ctx, exec, len(related), fieldseekerSyncs1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FieldseekerSyncs = append(organization0.R.FieldseekerSyncs, fieldseekerSyncs1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFiles0(ctx context.Context, exec bob.Executor, fileuploadFiles1 []*FileuploadFileSetter, organization0 *Organization) (FileuploadFileSlice, error) {
	for i := range fileuploadFiles1 {
		fileuploadFiles1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := FileuploadFiles.Insert(bob.ToMods(fileuploadFiles1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFiles0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFiles0(ctx context.Context, exec bob.Executor, count int, fileuploadFiles1 FileuploadFileSlice, organization0 *Organization) (FileuploadFileSlice, error) {
	setter := &FileuploadFileSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := fileuploadFiles1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFiles0: %w", err)
	}

	return fileuploadFiles1, nil
}

func (organization0 *Organization) InsertFiles(ctx context.Context, exec bob.Executor, related ...*FileuploadFileSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fileuploadFiles1, err := insertOrganizationFiles0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Files = append(organization0.R.Files, fileuploadFiles1...)

	for _, rel := range fileuploadFiles1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFiles(ctx context.Context, exec bob.Executor, related ...*FileuploadFile) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fileuploadFiles1 := FileuploadFileSlice(related)

	_, err = attachOrganizationFiles0(ctx, exec, len(related), fileuploadFiles1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Files = append(organization0.R.Files, fileuploadFiles1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationH3Aggregations0(ctx context.Context, exec bob.Executor, h3Aggregations1 []*H3AggregationSetter, organization0 *Organization) (H3AggregationSlice, error) {
	for i := range h3Aggregations1 {
		h3Aggregations1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := H3Aggregations.Insert(bob.ToMods(h3Aggregations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationH3Aggregations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationH3Aggregations0(ctx context.Context, exec bob.Executor, count int, h3Aggregations1 H3AggregationSlice, organization0 *Organization) (H3AggregationSlice, error) {
	setter := &H3AggregationSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := h3Aggregations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationH3Aggregations0: %w", err)
	}

	return h3Aggregations1, nil
}

func (organization0 *Organization) InsertH3Aggregations(ctx context.Context, exec bob.Executor, related ...*H3AggregationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	h3Aggregations1, err := insertOrganizationH3Aggregations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.H3Aggregations = append(organization0.R.H3Aggregations, h3Aggregations1...)

	for _, rel := range h3Aggregations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachH3Aggregations(ctx context.Context, exec bob.Executor, related ...*H3Aggregation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	h3Aggregations1 := H3AggregationSlice(related)

	_, err = attachOrganizationH3Aggregations0(ctx, exec, len(related), h3Aggregations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.H3Aggregations = append(organization0.R.H3Aggregations, h3Aggregations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationNoteAudios0(ctx context.Context, exec bob.Executor, noteAudios1 []*NoteAudioSetter, organization0 *Organization) (NoteAudioSlice, error) {
	for i := range noteAudios1 {
		noteAudios1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := NoteAudios.Insert(bob.ToMods(noteAudios1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationNoteAudios0: %w", err)
	}

	return ret, nil
}

func attachOrganizationNoteAudios0(ctx context.Context, exec bob.Executor, count int, noteAudios1 NoteAudioSlice, organization0 *Organization) (NoteAudioSlice, error) {
	setter := &NoteAudioSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := noteAudios1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationNoteAudios0: %w", err)
	}

	return noteAudios1, nil
}

func (organization0 *Organization) InsertNoteAudios(ctx context.Context, exec bob.Executor, related ...*NoteAudioSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	noteAudios1, err := insertOrganizationNoteAudios0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.NoteAudios = append(organization0.R.NoteAudios, noteAudios1...)

	for _, rel := range noteAudios1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachNoteAudios(ctx context.Context, exec bob.Executor, related ...*NoteAudio) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	noteAudios1 := NoteAudioSlice(related)

	_, err = attachOrganizationNoteAudios0(ctx, exec, len(related), noteAudios1, organization0)
	if err != nil {
		return err
	}

	organization0.R.NoteAudios = append(organization0.R.NoteAudios, noteAudios1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationNoteImages0(ctx context.Context, exec bob.Executor, noteImages1 []*NoteImageSetter, organization0 *Organization) (NoteImageSlice, error) {
	for i := range noteImages1 {
		noteImages1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := NoteImages.Insert(bob.ToMods(noteImages1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationNoteImages0: %w", err)
	}

	return ret, nil
}

func attachOrganizationNoteImages0(ctx context.Context, exec bob.Executor, count int, noteImages1 NoteImageSlice, organization0 *Organization) (NoteImageSlice, error) {
	setter := &NoteImageSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := noteImages1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationNoteImages0: %w", err)
	}

	return noteImages1, nil
}

func (organization0 *Organization) InsertNoteImages(ctx context.Context, exec bob.Executor, related ...*NoteImageSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	noteImages1, err := insertOrganizationNoteImages0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.NoteImages = append(organization0.R.NoteImages, noteImages1...)

	for _, rel := range noteImages1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachNoteImages(ctx context.Context, exec bob.Executor, related ...*NoteImage) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	noteImages1 := NoteImageSlice(related)

	_, err = attachOrganizationNoteImages0(ctx, exec, len(related), noteImages1, organization0)
	if err != nil {
		return err
	}

	organization0.R.NoteImages = append(organization0.R.NoteImages, noteImages1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func attachOrganizationImportDistrictGidDistrict0(ctx context.Context, exec bob.Executor, count int, organization0 *Organization, importDistrict1 *ImportDistrict) (*Organization, error) {
	setter := &OrganizationSetter{
		ImportDistrictGid: omitnull.From(importDistrict1.Gid),
	}

	err := organization0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationImportDistrictGidDistrict0: %w", err)
	}

	return organization0, nil
}

func (organization0 *Organization) InsertImportDistrictGidDistrict(ctx context.Context, exec bob.Executor, related *ImportDistrictSetter) error {
	var err error

	importDistrict1, err := ImportDistricts.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachOrganizationImportDistrictGidDistrict0(ctx, exec, 1, organization0, importDistrict1)
	if err != nil {
		return err
	}

	organization0.R.ImportDistrictGidDistrict = importDistrict1

	importDistrict1.R.ImportDistrictGidOrganization = organization0

	return nil
}

func (organization0 *Organization) AttachImportDistrictGidDistrict(ctx context.Context, exec bob.Executor, importDistrict1 *ImportDistrict) error {
	var err error

	_, err = attachOrganizationImportDistrictGidDistrict0(ctx, exec, 1, organization0, importDistrict1)
	if err != nil {
		return err
	}

	organization0.R.ImportDistrictGidDistrict = importDistrict1

	importDistrict1.R.ImportDistrictGidOrganization = organization0

	return nil
}

func insertOrganizationPools0(ctx context.Context, exec bob.Executor, pools1 []*PoolSetter, organization0 *Organization) (PoolSlice, error) {
	for i := range pools1 {
		pools1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := Pools.Insert(bob.ToMods(pools1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationPools0: %w", err)
	}

	return ret, nil
}

func attachOrganizationPools0(ctx context.Context, exec bob.Executor, count int, pools1 PoolSlice, organization0 *Organization) (PoolSlice, error) {
	setter := &PoolSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := pools1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationPools0: %w", err)
	}

	return pools1, nil
}

func (organization0 *Organization) InsertPools(ctx context.Context, exec bob.Executor, related ...*PoolSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	pools1, err := insertOrganizationPools0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Pools = append(organization0.R.Pools, pools1...)

	for _, rel := range pools1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachPools(ctx context.Context, exec bob.Executor, related ...*Pool) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	pools1 := PoolSlice(related)

	_, err = attachOrganizationPools0(ctx, exec, len(related), pools1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Pools = append(organization0.R.Pools, pools1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationNuisances0(ctx context.Context, exec bob.Executor, publicreportNuisances1 []*PublicreportNuisanceSetter, organization0 *Organization) (PublicreportNuisanceSlice, error) {
	for i := range publicreportNuisances1 {
		publicreportNuisances1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := PublicreportNuisances.Insert(bob.ToMods(publicreportNuisances1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationNuisances0: %w", err)
	}

	return ret, nil
}

func attachOrganizationNuisances0(ctx context.Context, exec bob.Executor, count int, publicreportNuisances1 PublicreportNuisanceSlice, organization0 *Organization) (PublicreportNuisanceSlice, error) {
	setter := &PublicreportNuisanceSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := publicreportNuisances1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationNuisances0: %w", err)
	}

	return publicreportNuisances1, nil
}

func (organization0 *Organization) InsertNuisances(ctx context.Context, exec bob.Executor, related ...*PublicreportNuisanceSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	publicreportNuisances1, err := insertOrganizationNuisances0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Nuisances = append(organization0.R.Nuisances, publicreportNuisances1...)

	for _, rel := range publicreportNuisances1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachNuisances(ctx context.Context, exec bob.Executor, related ...*PublicreportNuisance) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	publicreportNuisances1 := PublicreportNuisanceSlice(related)

	_, err = attachOrganizationNuisances0(ctx, exec, len(related), publicreportNuisances1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Nuisances = append(organization0.R.Nuisances, publicreportNuisances1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationPublicreportPool0(ctx context.Context, exec bob.Executor, publicreportPools1 []*PublicreportPoolSetter, organization0 *Organization) (PublicreportPoolSlice, error) {
	for i := range publicreportPools1 {
		publicreportPools1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := PublicreportPools.Insert(bob.ToMods(publicreportPools1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationPublicreportPool0: %w", err)
	}

	return ret, nil
}

func attachOrganizationPublicreportPool0(ctx context.Context, exec bob.Executor, count int, publicreportPools1 PublicreportPoolSlice, organization0 *Organization) (PublicreportPoolSlice, error) {
	setter := &PublicreportPoolSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := publicreportPools1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationPublicreportPool0: %w", err)
	}

	return publicreportPools1, nil
}

func (organization0 *Organization) InsertPublicreportPool(ctx context.Context, exec bob.Executor, related ...*PublicreportPoolSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	publicreportPools1, err := insertOrganizationPublicreportPool0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.PublicreportPool = append(organization0.R.PublicreportPool, publicreportPools1...)

	for _, rel := range publicreportPools1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachPublicreportPool(ctx context.Context, exec bob.Executor, related ...*PublicreportPool) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	publicreportPools1 := PublicreportPoolSlice(related)

	_, err = attachOrganizationPublicreportPool0(ctx, exec, len(related), publicreportPools1, organization0)
	if err != nil {
		return err
	}

	organization0.R.PublicreportPool = append(organization0.R.PublicreportPool, publicreportPools1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationQuicks0(ctx context.Context, exec bob.Executor, publicreportQuicks1 []*PublicreportQuickSetter, organization0 *Organization) (PublicreportQuickSlice, error) {
	for i := range publicreportQuicks1 {
		publicreportQuicks1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := PublicreportQuicks.Insert(bob.ToMods(publicreportQuicks1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationQuicks0: %w", err)
	}

	return ret, nil
}

func attachOrganizationQuicks0(ctx context.Context, exec bob.Executor, count int, publicreportQuicks1 PublicreportQuickSlice, organization0 *Organization) (PublicreportQuickSlice, error) {
	setter := &PublicreportQuickSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := publicreportQuicks1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationQuicks0: %w", err)
	}

	return publicreportQuicks1, nil
}

func (organization0 *Organization) InsertQuicks(ctx context.Context, exec bob.Executor, related ...*PublicreportQuickSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	publicreportQuicks1, err := insertOrganizationQuicks0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.Quicks = append(organization0.R.Quicks, publicreportQuicks1...)

	for _, rel := range publicreportQuicks1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachQuicks(ctx context.Context, exec bob.Executor, related ...*PublicreportQuick) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	publicreportQuicks1 := PublicreportQuickSlice(related)

	_, err = attachOrganizationQuicks0(ctx, exec, len(related), publicreportQuicks1, organization0)
	if err != nil {
		return err
	}

	organization0.R.Quicks = append(organization0.R.Quicks, publicreportQuicks1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationUser0(ctx context.Context, exec bob.Executor, users1 []*UserSetter, organization0 *Organization) (UserSlice, error) {
	for i := range users1 {
		users1[i].OrganizationID = omit.From(organization0.ID)
	}

	ret, err := Users.Insert(bob.ToMods(users1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationUser0: %w", err)
	}

	return ret, nil
}

func attachOrganizationUser0(ctx context.Context, exec bob.Executor, count int, users1 UserSlice, organization0 *Organization) (UserSlice, error) {
	setter := &UserSetter{
		OrganizationID: omit.From(organization0.ID),
	}

	err := users1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationUser0: %w", err)
	}

	return users1, nil
}

func (organization0 *Organization) InsertUser(ctx context.Context, exec bob.Executor, related ...*UserSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	users1, err := insertOrganizationUser0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.User = append(organization0.R.User, users1...)

	for _, rel := range users1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachUser(ctx context.Context, exec bob.Executor, related ...*User) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	users1 := UserSlice(related)

	_, err = attachOrganizationUser0(ctx, exec, len(related), users1, organization0)
	if err != nil {
		return err
	}

	organization0.R.User = append(organization0.R.User, users1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

type organizationWhere[Q psql.Filterable] struct {
	ID                psql.WhereMod[Q, int32]
	Name              psql.WhereMod[Q, string]
	ArcgisID          psql.WhereNullMod[Q, string]
	ArcgisName        psql.WhereNullMod[Q, string]
	FieldseekerURL    psql.WhereNullMod[Q, string]
	ImportDistrictGid psql.WhereNullMod[Q, int32]
	Website           psql.WhereNullMod[Q, string]
	LogoUUID          psql.WhereNullMod[Q, uuid.UUID]
	Slug              psql.WhereNullMod[Q, string]
}

func (organizationWhere[Q]) AliasedAs(alias string) organizationWhere[Q] {
	return buildOrganizationWhere[Q](buildOrganizationColumns(alias))
}

func buildOrganizationWhere[Q psql.Filterable](cols organizationColumns) organizationWhere[Q] {
	return organizationWhere[Q]{
		ID:                psql.Where[Q, int32](cols.ID),
		Name:              psql.Where[Q, string](cols.Name),
		ArcgisID:          psql.WhereNull[Q, string](cols.ArcgisID),
		ArcgisName:        psql.WhereNull[Q, string](cols.ArcgisName),
		FieldseekerURL:    psql.WhereNull[Q, string](cols.FieldseekerURL),
		ImportDistrictGid: psql.WhereNull[Q, int32](cols.ImportDistrictGid),
		Website:           psql.WhereNull[Q, string](cols.Website),
		LogoUUID:          psql.WhereNull[Q, uuid.UUID](cols.LogoUUID),
		Slug:              psql.WhereNull[Q, string](cols.Slug),
	}
}

func (o *Organization) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "EmailContacts":
		rels, ok := retrieved.(CommsEmailContactSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.EmailContacts = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organizations = OrganizationSlice{o}
			}
		}
		return nil
	case "Phones":
		rels, ok := retrieved.(CommsPhoneSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Phones = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organizations = OrganizationSlice{o}
			}
		}
		return nil
	case "Containerrelates":
		rels, ok := retrieved.(FieldseekerContainerrelateSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Containerrelates = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Fieldscoutinglogs":
		rels, ok := retrieved.(FieldseekerFieldscoutinglogSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Fieldscoutinglogs = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Habitatrelates":
		rels, ok := retrieved.(FieldseekerHabitatrelateSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Habitatrelates = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Inspectionsamples":
		rels, ok := retrieved.(FieldseekerInspectionsampleSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Inspectionsamples = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Inspectionsampledetails":
		rels, ok := retrieved.(FieldseekerInspectionsampledetailSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Inspectionsampledetails = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Linelocations":
		rels, ok := retrieved.(FieldseekerLinelocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Linelocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Locationtrackings":
		rels, ok := retrieved.(FieldseekerLocationtrackingSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Locationtrackings = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Mosquitoinspections":
		rels, ok := retrieved.(FieldseekerMosquitoinspectionSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Mosquitoinspections = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Pointlocations":
		rels, ok := retrieved.(FieldseekerPointlocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Pointlocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Polygonlocations":
		rels, ok := retrieved.(FieldseekerPolygonlocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Polygonlocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FieldseekerPool":
		rels, ok := retrieved.(FieldseekerPoolSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FieldseekerPool = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Pooldetails":
		rels, ok := retrieved.(FieldseekerPooldetailSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Pooldetails = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Proposedtreatmentareas":
		rels, ok := retrieved.(FieldseekerProposedtreatmentareaSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Proposedtreatmentareas = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Qamosquitoinspections":
		rels, ok := retrieved.(FieldseekerQamosquitoinspectionSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Qamosquitoinspections = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Rodentlocations":
		rels, ok := retrieved.(FieldseekerRodentlocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Rodentlocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Samplecollections":
		rels, ok := retrieved.(FieldseekerSamplecollectionSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Samplecollections = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Samplelocations":
		rels, ok := retrieved.(FieldseekerSamplelocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Samplelocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Servicerequests":
		rels, ok := retrieved.(FieldseekerServicerequestSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Servicerequests = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Speciesabundances":
		rels, ok := retrieved.(FieldseekerSpeciesabundanceSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Speciesabundances = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Stormdrains":
		rels, ok := retrieved.(FieldseekerStormdrainSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Stormdrains = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Timecards":
		rels, ok := retrieved.(FieldseekerTimecardSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Timecards = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Trapdata":
		rels, ok := retrieved.(FieldseekerTrapdatumSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Trapdata = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Traplocations":
		rels, ok := retrieved.(FieldseekerTraplocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Traplocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Treatments":
		rels, ok := retrieved.(FieldseekerTreatmentSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Treatments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Treatmentareas":
		rels, ok := retrieved.(FieldseekerTreatmentareaSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Treatmentareas = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Zones":
		rels, ok := retrieved.(FieldseekerZoneSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Zones = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Zones2s":
		rels, ok := retrieved.(FieldseekerZones2Slice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Zones2s = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FieldseekerSyncs":
		rels, ok := retrieved.(FieldseekerSyncSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FieldseekerSyncs = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Files":
		rels, ok := retrieved.(FileuploadFileSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Files = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "H3Aggregations":
		rels, ok := retrieved.(H3AggregationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.H3Aggregations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "NoteAudios":
		rels, ok := retrieved.(NoteAudioSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.NoteAudios = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "NoteImages":
		rels, ok := retrieved.(NoteImageSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.NoteImages = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "ImportDistrictGidDistrict":
		rel, ok := retrieved.(*ImportDistrict)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.ImportDistrictGidDistrict = rel

		if rel != nil {
			rel.R.ImportDistrictGidOrganization = o
		}
		return nil
	case "Pools":
		rels, ok := retrieved.(PoolSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Pools = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Nuisances":
		rels, ok := retrieved.(PublicreportNuisanceSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Nuisances = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "PublicreportPool":
		rels, ok := retrieved.(PublicreportPoolSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.PublicreportPool = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "Quicks":
		rels, ok := retrieved.(PublicreportQuickSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.Quicks = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "User":
		rels, ok := retrieved.(UserSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.User = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	default:
		return fmt.Errorf("organization has no relationship %q", name)
	}
}

type organizationPreloader struct {
	ImportDistrictGidDistrict func(...psql.PreloadOption) psql.Preloader
}

func buildOrganizationPreloader() organizationPreloader {
	return organizationPreloader{
		ImportDistrictGidDistrict: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*ImportDistrict, ImportDistrictSlice](psql.PreloadRel{
				Name: "ImportDistrictGidDistrict",
				Sides: []psql.PreloadSide{
					{
						From:        Organizations,
						To:          ImportDistricts,
						FromColumns: []string{"import_district_gid"},
						ToColumns:   []string{"gid"},
					},
				},
			}, ImportDistricts.Columns.Names(), opts...)
		},
	}
}

type organizationThenLoader[Q orm.Loadable] struct {
	EmailContacts             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Phones                    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Containerrelates          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Fieldscoutinglogs         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Habitatrelates            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Inspectionsamples         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Inspectionsampledetails   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Linelocations             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Locationtrackings         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Mosquitoinspections       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pointlocations            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Polygonlocations          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FieldseekerPool           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pooldetails               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Proposedtreatmentareas    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Qamosquitoinspections     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Rodentlocations           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Samplecollections         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Samplelocations           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Servicerequests           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Speciesabundances         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Stormdrains               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Timecards                 func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Trapdata                  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Traplocations             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Treatments                func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Treatmentareas            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Zones                     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Zones2s                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FieldseekerSyncs          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Files                     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	H3Aggregations            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	NoteAudios                func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	NoteImages                func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ImportDistrictGidDistrict func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pools                     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Nuisances                 func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	PublicreportPool          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Quicks                    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	User                      func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildOrganizationThenLoader[Q orm.Loadable]() organizationThenLoader[Q] {
	type EmailContactsLoadInterface interface {
		LoadEmailContacts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PhonesLoadInterface interface {
		LoadPhones(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ContainerrelatesLoadInterface interface {
		LoadContainerrelates(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FieldscoutinglogsLoadInterface interface {
		LoadFieldscoutinglogs(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HabitatrelatesLoadInterface interface {
		LoadHabitatrelates(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type InspectionsamplesLoadInterface interface {
		LoadInspectionsamples(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type InspectionsampledetailsLoadInterface interface {
		LoadInspectionsampledetails(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type LinelocationsLoadInterface interface {
		LoadLinelocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type LocationtrackingsLoadInterface interface {
		LoadLocationtrackings(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type MosquitoinspectionsLoadInterface interface {
		LoadMosquitoinspections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PointlocationsLoadInterface interface {
		LoadPointlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PolygonlocationsLoadInterface interface {
		LoadPolygonlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FieldseekerPoolLoadInterface interface {
		LoadFieldseekerPool(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PooldetailsLoadInterface interface {
		LoadPooldetails(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ProposedtreatmentareasLoadInterface interface {
		LoadProposedtreatmentareas(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type QamosquitoinspectionsLoadInterface interface {
		LoadQamosquitoinspections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RodentlocationsLoadInterface interface {
		LoadRodentlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SamplecollectionsLoadInterface interface {
		LoadSamplecollections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SamplelocationsLoadInterface interface {
		LoadSamplelocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ServicerequestsLoadInterface interface {
		LoadServicerequests(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SpeciesabundancesLoadInterface interface {
		LoadSpeciesabundances(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type StormdrainsLoadInterface interface {
		LoadStormdrains(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TimecardsLoadInterface interface {
		LoadTimecards(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TrapdataLoadInterface interface {
		LoadTrapdata(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TraplocationsLoadInterface interface {
		LoadTraplocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TreatmentsLoadInterface interface {
		LoadTreatments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TreatmentareasLoadInterface interface {
		LoadTreatmentareas(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ZonesLoadInterface interface {
		LoadZones(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type Zones2sLoadInterface interface {
		LoadZones2s(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FieldseekerSyncsLoadInterface interface {
		LoadFieldseekerSyncs(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FilesLoadInterface interface {
		LoadFiles(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type H3AggregationsLoadInterface interface {
		LoadH3Aggregations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type NoteAudiosLoadInterface interface {
		LoadNoteAudios(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type NoteImagesLoadInterface interface {
		LoadNoteImages(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ImportDistrictGidDistrictLoadInterface interface {
		LoadImportDistrictGidDistrict(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PoolsLoadInterface interface {
		LoadPools(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type NuisancesLoadInterface interface {
		LoadNuisances(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PublicreportPoolLoadInterface interface {
		LoadPublicreportPool(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type QuicksLoadInterface interface {
		LoadQuicks(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserLoadInterface interface {
		LoadUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return organizationThenLoader[Q]{
		EmailContacts: thenLoadBuilder[Q](
			"EmailContacts",
			func(ctx context.Context, exec bob.Executor, retrieved EmailContactsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadEmailContacts(ctx, exec, mods...)
			},
		),
		Phones: thenLoadBuilder[Q](
			"Phones",
			func(ctx context.Context, exec bob.Executor, retrieved PhonesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPhones(ctx, exec, mods...)
			},
		),
		Containerrelates: thenLoadBuilder[Q](
			"Containerrelates",
			func(ctx context.Context, exec bob.Executor, retrieved ContainerrelatesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadContainerrelates(ctx, exec, mods...)
			},
		),
		Fieldscoutinglogs: thenLoadBuilder[Q](
			"Fieldscoutinglogs",
			func(ctx context.Context, exec bob.Executor, retrieved FieldscoutinglogsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFieldscoutinglogs(ctx, exec, mods...)
			},
		),
		Habitatrelates: thenLoadBuilder[Q](
			"Habitatrelates",
			func(ctx context.Context, exec bob.Executor, retrieved HabitatrelatesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHabitatrelates(ctx, exec, mods...)
			},
		),
		Inspectionsamples: thenLoadBuilder[Q](
			"Inspectionsamples",
			func(ctx context.Context, exec bob.Executor, retrieved InspectionsamplesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadInspectionsamples(ctx, exec, mods...)
			},
		),
		Inspectionsampledetails: thenLoadBuilder[Q](
			"Inspectionsampledetails",
			func(ctx context.Context, exec bob.Executor, retrieved InspectionsampledetailsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadInspectionsampledetails(ctx, exec, mods...)
			},
		),
		Linelocations: thenLoadBuilder[Q](
			"Linelocations",
			func(ctx context.Context, exec bob.Executor, retrieved LinelocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadLinelocations(ctx, exec, mods...)
			},
		),
		Locationtrackings: thenLoadBuilder[Q](
			"Locationtrackings",
			func(ctx context.Context, exec bob.Executor, retrieved LocationtrackingsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadLocationtrackings(ctx, exec, mods...)
			},
		),
		Mosquitoinspections: thenLoadBuilder[Q](
			"Mosquitoinspections",
			func(ctx context.Context, exec bob.Executor, retrieved MosquitoinspectionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadMosquitoinspections(ctx, exec, mods...)
			},
		),
		Pointlocations: thenLoadBuilder[Q](
			"Pointlocations",
			func(ctx context.Context, exec bob.Executor, retrieved PointlocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPointlocations(ctx, exec, mods...)
			},
		),
		Polygonlocations: thenLoadBuilder[Q](
			"Polygonlocations",
			func(ctx context.Context, exec bob.Executor, retrieved PolygonlocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPolygonlocations(ctx, exec, mods...)
			},
		),
		FieldseekerPool: thenLoadBuilder[Q](
			"FieldseekerPool",
			func(ctx context.Context, exec bob.Executor, retrieved FieldseekerPoolLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFieldseekerPool(ctx, exec, mods...)
			},
		),
		Pooldetails: thenLoadBuilder[Q](
			"Pooldetails",
			func(ctx context.Context, exec bob.Executor, retrieved PooldetailsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPooldetails(ctx, exec, mods...)
			},
		),
		Proposedtreatmentareas: thenLoadBuilder[Q](
			"Proposedtreatmentareas",
			func(ctx context.Context, exec bob.Executor, retrieved ProposedtreatmentareasLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadProposedtreatmentareas(ctx, exec, mods...)
			},
		),
		Qamosquitoinspections: thenLoadBuilder[Q](
			"Qamosquitoinspections",
			func(ctx context.Context, exec bob.Executor, retrieved QamosquitoinspectionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadQamosquitoinspections(ctx, exec, mods...)
			},
		),
		Rodentlocations: thenLoadBuilder[Q](
			"Rodentlocations",
			func(ctx context.Context, exec bob.Executor, retrieved RodentlocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRodentlocations(ctx, exec, mods...)
			},
		),
		Samplecollections: thenLoadBuilder[Q](
			"Samplecollections",
			func(ctx context.Context, exec bob.Executor, retrieved SamplecollectionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSamplecollections(ctx, exec, mods...)
			},
		),
		Samplelocations: thenLoadBuilder[Q](
			"Samplelocations",
			func(ctx context.Context, exec bob.Executor, retrieved SamplelocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSamplelocations(ctx, exec, mods...)
			},
		),
		Servicerequests: thenLoadBuilder[Q](
			"Servicerequests",
			func(ctx context.Context, exec bob.Executor, retrieved ServicerequestsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadServicerequests(ctx, exec, mods...)
			},
		),
		Speciesabundances: thenLoadBuilder[Q](
			"Speciesabundances",
			func(ctx context.Context, exec bob.Executor, retrieved SpeciesabundancesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSpeciesabundances(ctx, exec, mods...)
			},
		),
		Stormdrains: thenLoadBuilder[Q](
			"Stormdrains",
			func(ctx context.Context, exec bob.Executor, retrieved StormdrainsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadStormdrains(ctx, exec, mods...)
			},
		),
		Timecards: thenLoadBuilder[Q](
			"Timecards",
			func(ctx context.Context, exec bob.Executor, retrieved TimecardsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadTimecards(ctx, exec, mods...)
			},
		),
		Trapdata: thenLoadBuilder[Q](
			"Trapdata",
			func(ctx context.Context, exec bob.Executor, retrieved TrapdataLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadTrapdata(ctx, exec, mods...)
			},
		),
		Traplocations: thenLoadBuilder[Q](
			"Traplocations",
			func(ctx context.Context, exec bob.Executor, retrieved TraplocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadTraplocations(ctx, exec, mods...)
			},
		),
		Treatments: thenLoadBuilder[Q](
			"Treatments",
			func(ctx context.Context, exec bob.Executor, retrieved TreatmentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadTreatments(ctx, exec, mods...)
			},
		),
		Treatmentareas: thenLoadBuilder[Q](
			"Treatmentareas",
			func(ctx context.Context, exec bob.Executor, retrieved TreatmentareasLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadTreatmentareas(ctx, exec, mods...)
			},
		),
		Zones: thenLoadBuilder[Q](
			"Zones",
			func(ctx context.Context, exec bob.Executor, retrieved ZonesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadZones(ctx, exec, mods...)
			},
		),
		Zones2s: thenLoadBuilder[Q](
			"Zones2s",
			func(ctx context.Context, exec bob.Executor, retrieved Zones2sLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadZones2s(ctx, exec, mods...)
			},
		),
		FieldseekerSyncs: thenLoadBuilder[Q](
			"FieldseekerSyncs",
			func(ctx context.Context, exec bob.Executor, retrieved FieldseekerSyncsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFieldseekerSyncs(ctx, exec, mods...)
			},
		),
		Files: thenLoadBuilder[Q](
			"Files",
			func(ctx context.Context, exec bob.Executor, retrieved FilesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFiles(ctx, exec, mods...)
			},
		),
		H3Aggregations: thenLoadBuilder[Q](
			"H3Aggregations",
			func(ctx context.Context, exec bob.Executor, retrieved H3AggregationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadH3Aggregations(ctx, exec, mods...)
			},
		),
		NoteAudios: thenLoadBuilder[Q](
			"NoteAudios",
			func(ctx context.Context, exec bob.Executor, retrieved NoteAudiosLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadNoteAudios(ctx, exec, mods...)
			},
		),
		NoteImages: thenLoadBuilder[Q](
			"NoteImages",
			func(ctx context.Context, exec bob.Executor, retrieved NoteImagesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadNoteImages(ctx, exec, mods...)
			},
		),
		ImportDistrictGidDistrict: thenLoadBuilder[Q](
			"ImportDistrictGidDistrict",
			func(ctx context.Context, exec bob.Executor, retrieved ImportDistrictGidDistrictLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadImportDistrictGidDistrict(ctx, exec, mods...)
			},
		),
		Pools: thenLoadBuilder[Q](
			"Pools",
			func(ctx context.Context, exec bob.Executor, retrieved PoolsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPools(ctx, exec, mods...)
			},
		),
		Nuisances: thenLoadBuilder[Q](
			"Nuisances",
			func(ctx context.Context, exec bob.Executor, retrieved NuisancesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadNuisances(ctx, exec, mods...)
			},
		),
		PublicreportPool: thenLoadBuilder[Q](
			"PublicreportPool",
			func(ctx context.Context, exec bob.Executor, retrieved PublicreportPoolLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPublicreportPool(ctx, exec, mods...)
			},
		),
		Quicks: thenLoadBuilder[Q](
			"Quicks",
			func(ctx context.Context, exec bob.Executor, retrieved QuicksLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadQuicks(ctx, exec, mods...)
			},
		),
		User: thenLoadBuilder[Q](
			"User",
			func(ctx context.Context, exec bob.Executor, retrieved UserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadEmailContacts loads the organization's EmailContacts into the .R struct
func (o *Organization) LoadEmailContacts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.EmailContacts = nil

	related, err := o.EmailContacts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organizations = OrganizationSlice{o}
	}

	o.R.EmailContacts = related
	return nil
}

// LoadEmailContacts loads the organization's EmailContacts into the .R struct
func (os OrganizationSlice) LoadEmailContacts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	// since we are changing the columns, we need to check if the original columns were set or add the defaults
	sq := dialect.SelectQuery{}
	for _, mod := range mods {
		mod.Apply(&sq)
	}

	if len(sq.SelectList.Columns) == 0 {
		mods = append(mods, sm.Columns(CommsEmailContacts.Columns))
	}

	q := os.EmailContacts(append(
		mods,
		sm.Columns(DistrictSubscriptionEmails.Columns.OrganizationID.As("related_organization.ID")),
	)...)

	IDSlice := []int32{}

	mapper := scan.Mod(scan.StructMapper[*CommsEmailContact](), func(ctx context.Context, cols []string) (scan.BeforeFunc, func(any, any) error) {
		return func(row *scan.Row) (any, error) {
				IDSlice = append(IDSlice, *new(int32))
				row.ScheduleScanByName("related_organization.ID", &IDSlice[len(IDSlice)-1])

				return nil, nil
			},
			func(any, any) error {
				return nil
			}
	})

	commsEmailContacts, err := bob.Allx[bob.SliceTransformer[*CommsEmailContact, CommsEmailContactSlice]](ctx, exec, q, mapper)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.EmailContacts = nil
	}

	for _, o := range os {
		for i, rel := range commsEmailContacts {
			if !(o.ID == IDSlice[i]) {
				continue
			}

			rel.R.Organizations = append(rel.R.Organizations, o)

			o.R.EmailContacts = append(o.R.EmailContacts, rel)
		}
	}

	return nil
}

// LoadPhones loads the organization's Phones into the .R struct
func (o *Organization) LoadPhones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Phones = nil

	related, err := o.Phones(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organizations = OrganizationSlice{o}
	}

	o.R.Phones = related
	return nil
}

// LoadPhones loads the organization's Phones into the .R struct
func (os OrganizationSlice) LoadPhones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	// since we are changing the columns, we need to check if the original columns were set or add the defaults
	sq := dialect.SelectQuery{}
	for _, mod := range mods {
		mod.Apply(&sq)
	}

	if len(sq.SelectList.Columns) == 0 {
		mods = append(mods, sm.Columns(CommsPhones.Columns))
	}

	q := os.Phones(append(
		mods,
		sm.Columns(DistrictSubscriptionPhones.Columns.OrganizationID.As("related_organization.ID")),
	)...)

	IDSlice := []int32{}

	mapper := scan.Mod(scan.StructMapper[*CommsPhone](), func(ctx context.Context, cols []string) (scan.BeforeFunc, func(any, any) error) {
		return func(row *scan.Row) (any, error) {
				IDSlice = append(IDSlice, *new(int32))
				row.ScheduleScanByName("related_organization.ID", &IDSlice[len(IDSlice)-1])

				return nil, nil
			},
			func(any, any) error {
				return nil
			}
	})

	commsPhones, err := bob.Allx[bob.SliceTransformer[*CommsPhone, CommsPhoneSlice]](ctx, exec, q, mapper)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Phones = nil
	}

	for _, o := range os {
		for i, rel := range commsPhones {
			if !(o.ID == IDSlice[i]) {
				continue
			}

			rel.R.Organizations = append(rel.R.Organizations, o)

			o.R.Phones = append(o.R.Phones, rel)
		}
	}

	return nil
}

// LoadContainerrelates loads the organization's Containerrelates into the .R struct
func (o *Organization) LoadContainerrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Containerrelates = nil

	related, err := o.Containerrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Containerrelates = related
	return nil
}

// LoadContainerrelates loads the organization's Containerrelates into the .R struct
func (os OrganizationSlice) LoadContainerrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerContainerrelates, err := os.Containerrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Containerrelates = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerContainerrelates {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Containerrelates = append(o.R.Containerrelates, rel)
		}
	}

	return nil
}

// LoadFieldscoutinglogs loads the organization's Fieldscoutinglogs into the .R struct
func (o *Organization) LoadFieldscoutinglogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Fieldscoutinglogs = nil

	related, err := o.Fieldscoutinglogs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Fieldscoutinglogs = related
	return nil
}

// LoadFieldscoutinglogs loads the organization's Fieldscoutinglogs into the .R struct
func (os OrganizationSlice) LoadFieldscoutinglogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerFieldscoutinglogs, err := os.Fieldscoutinglogs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Fieldscoutinglogs = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerFieldscoutinglogs {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Fieldscoutinglogs = append(o.R.Fieldscoutinglogs, rel)
		}
	}

	return nil
}

// LoadHabitatrelates loads the organization's Habitatrelates into the .R struct
func (o *Organization) LoadHabitatrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Habitatrelates = nil

	related, err := o.Habitatrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Habitatrelates = related
	return nil
}

// LoadHabitatrelates loads the organization's Habitatrelates into the .R struct
func (os OrganizationSlice) LoadHabitatrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerHabitatrelates, err := os.Habitatrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Habitatrelates = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerHabitatrelates {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Habitatrelates = append(o.R.Habitatrelates, rel)
		}
	}

	return nil
}

// LoadInspectionsamples loads the organization's Inspectionsamples into the .R struct
func (o *Organization) LoadInspectionsamples(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Inspectionsamples = nil

	related, err := o.Inspectionsamples(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Inspectionsamples = related
	return nil
}

// LoadInspectionsamples loads the organization's Inspectionsamples into the .R struct
func (os OrganizationSlice) LoadInspectionsamples(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerInspectionsamples, err := os.Inspectionsamples(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Inspectionsamples = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerInspectionsamples {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Inspectionsamples = append(o.R.Inspectionsamples, rel)
		}
	}

	return nil
}

// LoadInspectionsampledetails loads the organization's Inspectionsampledetails into the .R struct
func (o *Organization) LoadInspectionsampledetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Inspectionsampledetails = nil

	related, err := o.Inspectionsampledetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Inspectionsampledetails = related
	return nil
}

// LoadInspectionsampledetails loads the organization's Inspectionsampledetails into the .R struct
func (os OrganizationSlice) LoadInspectionsampledetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerInspectionsampledetails, err := os.Inspectionsampledetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Inspectionsampledetails = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerInspectionsampledetails {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Inspectionsampledetails = append(o.R.Inspectionsampledetails, rel)
		}
	}

	return nil
}

// LoadLinelocations loads the organization's Linelocations into the .R struct
func (o *Organization) LoadLinelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Linelocations = nil

	related, err := o.Linelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Linelocations = related
	return nil
}

// LoadLinelocations loads the organization's Linelocations into the .R struct
func (os OrganizationSlice) LoadLinelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerLinelocations, err := os.Linelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Linelocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerLinelocations {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Linelocations = append(o.R.Linelocations, rel)
		}
	}

	return nil
}

// LoadLocationtrackings loads the organization's Locationtrackings into the .R struct
func (o *Organization) LoadLocationtrackings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Locationtrackings = nil

	related, err := o.Locationtrackings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Locationtrackings = related
	return nil
}

// LoadLocationtrackings loads the organization's Locationtrackings into the .R struct
func (os OrganizationSlice) LoadLocationtrackings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerLocationtrackings, err := os.Locationtrackings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Locationtrackings = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerLocationtrackings {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Locationtrackings = append(o.R.Locationtrackings, rel)
		}
	}

	return nil
}

// LoadMosquitoinspections loads the organization's Mosquitoinspections into the .R struct
func (o *Organization) LoadMosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Mosquitoinspections = nil

	related, err := o.Mosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Mosquitoinspections = related
	return nil
}

// LoadMosquitoinspections loads the organization's Mosquitoinspections into the .R struct
func (os OrganizationSlice) LoadMosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerMosquitoinspections, err := os.Mosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Mosquitoinspections = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerMosquitoinspections {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Mosquitoinspections = append(o.R.Mosquitoinspections, rel)
		}
	}

	return nil
}

// LoadPointlocations loads the organization's Pointlocations into the .R struct
func (o *Organization) LoadPointlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Pointlocations = nil

	related, err := o.Pointlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Pointlocations = related
	return nil
}

// LoadPointlocations loads the organization's Pointlocations into the .R struct
func (os OrganizationSlice) LoadPointlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerPointlocations, err := os.Pointlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Pointlocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerPointlocations {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Pointlocations = append(o.R.Pointlocations, rel)
		}
	}

	return nil
}

// LoadPolygonlocations loads the organization's Polygonlocations into the .R struct
func (o *Organization) LoadPolygonlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Polygonlocations = nil

	related, err := o.Polygonlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Polygonlocations = related
	return nil
}

// LoadPolygonlocations loads the organization's Polygonlocations into the .R struct
func (os OrganizationSlice) LoadPolygonlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerPolygonlocations, err := os.Polygonlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Polygonlocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerPolygonlocations {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Polygonlocations = append(o.R.Polygonlocations, rel)
		}
	}

	return nil
}

// LoadFieldseekerPool loads the organization's FieldseekerPool into the .R struct
func (o *Organization) LoadFieldseekerPool(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FieldseekerPool = nil

	related, err := o.FieldseekerPool(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FieldseekerPool = related
	return nil
}

// LoadFieldseekerPool loads the organization's FieldseekerPool into the .R struct
func (os OrganizationSlice) LoadFieldseekerPool(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerPools, err := os.FieldseekerPool(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FieldseekerPool = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerPools {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.FieldseekerPool = append(o.R.FieldseekerPool, rel)
		}
	}

	return nil
}

// LoadPooldetails loads the organization's Pooldetails into the .R struct
func (o *Organization) LoadPooldetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Pooldetails = nil

	related, err := o.Pooldetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Pooldetails = related
	return nil
}

// LoadPooldetails loads the organization's Pooldetails into the .R struct
func (os OrganizationSlice) LoadPooldetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerPooldetails, err := os.Pooldetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Pooldetails = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerPooldetails {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Pooldetails = append(o.R.Pooldetails, rel)
		}
	}

	return nil
}

// LoadProposedtreatmentareas loads the organization's Proposedtreatmentareas into the .R struct
func (o *Organization) LoadProposedtreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Proposedtreatmentareas = nil

	related, err := o.Proposedtreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Proposedtreatmentareas = related
	return nil
}

// LoadProposedtreatmentareas loads the organization's Proposedtreatmentareas into the .R struct
func (os OrganizationSlice) LoadProposedtreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerProposedtreatmentareas, err := os.Proposedtreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Proposedtreatmentareas = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerProposedtreatmentareas {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Proposedtreatmentareas = append(o.R.Proposedtreatmentareas, rel)
		}
	}

	return nil
}

// LoadQamosquitoinspections loads the organization's Qamosquitoinspections into the .R struct
func (o *Organization) LoadQamosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Qamosquitoinspections = nil

	related, err := o.Qamosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Qamosquitoinspections = related
	return nil
}

// LoadQamosquitoinspections loads the organization's Qamosquitoinspections into the .R struct
func (os OrganizationSlice) LoadQamosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerQamosquitoinspections, err := os.Qamosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Qamosquitoinspections = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerQamosquitoinspections {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Qamosquitoinspections = append(o.R.Qamosquitoinspections, rel)
		}
	}

	return nil
}

// LoadRodentlocations loads the organization's Rodentlocations into the .R struct
func (o *Organization) LoadRodentlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Rodentlocations = nil

	related, err := o.Rodentlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Rodentlocations = related
	return nil
}

// LoadRodentlocations loads the organization's Rodentlocations into the .R struct
func (os OrganizationSlice) LoadRodentlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerRodentlocations, err := os.Rodentlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Rodentlocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerRodentlocations {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Rodentlocations = append(o.R.Rodentlocations, rel)
		}
	}

	return nil
}

// LoadSamplecollections loads the organization's Samplecollections into the .R struct
func (o *Organization) LoadSamplecollections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Samplecollections = nil

	related, err := o.Samplecollections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Samplecollections = related
	return nil
}

// LoadSamplecollections loads the organization's Samplecollections into the .R struct
func (os OrganizationSlice) LoadSamplecollections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerSamplecollections, err := os.Samplecollections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Samplecollections = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerSamplecollections {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Samplecollections = append(o.R.Samplecollections, rel)
		}
	}

	return nil
}

// LoadSamplelocations loads the organization's Samplelocations into the .R struct
func (o *Organization) LoadSamplelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Samplelocations = nil

	related, err := o.Samplelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Samplelocations = related
	return nil
}

// LoadSamplelocations loads the organization's Samplelocations into the .R struct
func (os OrganizationSlice) LoadSamplelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerSamplelocations, err := os.Samplelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Samplelocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerSamplelocations {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Samplelocations = append(o.R.Samplelocations, rel)
		}
	}

	return nil
}

// LoadServicerequests loads the organization's Servicerequests into the .R struct
func (o *Organization) LoadServicerequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Servicerequests = nil

	related, err := o.Servicerequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Servicerequests = related
	return nil
}

// LoadServicerequests loads the organization's Servicerequests into the .R struct
func (os OrganizationSlice) LoadServicerequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerServicerequests, err := os.Servicerequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Servicerequests = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerServicerequests {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Servicerequests = append(o.R.Servicerequests, rel)
		}
	}

	return nil
}

// LoadSpeciesabundances loads the organization's Speciesabundances into the .R struct
func (o *Organization) LoadSpeciesabundances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Speciesabundances = nil

	related, err := o.Speciesabundances(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Speciesabundances = related
	return nil
}

// LoadSpeciesabundances loads the organization's Speciesabundances into the .R struct
func (os OrganizationSlice) LoadSpeciesabundances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerSpeciesabundances, err := os.Speciesabundances(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Speciesabundances = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerSpeciesabundances {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Speciesabundances = append(o.R.Speciesabundances, rel)
		}
	}

	return nil
}

// LoadStormdrains loads the organization's Stormdrains into the .R struct
func (o *Organization) LoadStormdrains(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Stormdrains = nil

	related, err := o.Stormdrains(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Stormdrains = related
	return nil
}

// LoadStormdrains loads the organization's Stormdrains into the .R struct
func (os OrganizationSlice) LoadStormdrains(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerStormdrains, err := os.Stormdrains(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Stormdrains = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerStormdrains {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Stormdrains = append(o.R.Stormdrains, rel)
		}
	}

	return nil
}

// LoadTimecards loads the organization's Timecards into the .R struct
func (o *Organization) LoadTimecards(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Timecards = nil

	related, err := o.Timecards(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Timecards = related
	return nil
}

// LoadTimecards loads the organization's Timecards into the .R struct
func (os OrganizationSlice) LoadTimecards(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerTimecards, err := os.Timecards(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Timecards = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerTimecards {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Timecards = append(o.R.Timecards, rel)
		}
	}

	return nil
}

// LoadTrapdata loads the organization's Trapdata into the .R struct
func (o *Organization) LoadTrapdata(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Trapdata = nil

	related, err := o.Trapdata(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Trapdata = related
	return nil
}

// LoadTrapdata loads the organization's Trapdata into the .R struct
func (os OrganizationSlice) LoadTrapdata(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerTrapdata, err := os.Trapdata(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Trapdata = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerTrapdata {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Trapdata = append(o.R.Trapdata, rel)
		}
	}

	return nil
}

// LoadTraplocations loads the organization's Traplocations into the .R struct
func (o *Organization) LoadTraplocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Traplocations = nil

	related, err := o.Traplocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Traplocations = related
	return nil
}

// LoadTraplocations loads the organization's Traplocations into the .R struct
func (os OrganizationSlice) LoadTraplocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerTraplocations, err := os.Traplocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Traplocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerTraplocations {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Traplocations = append(o.R.Traplocations, rel)
		}
	}

	return nil
}

// LoadTreatments loads the organization's Treatments into the .R struct
func (o *Organization) LoadTreatments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Treatments = nil

	related, err := o.Treatments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Treatments = related
	return nil
}

// LoadTreatments loads the organization's Treatments into the .R struct
func (os OrganizationSlice) LoadTreatments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerTreatments, err := os.Treatments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Treatments = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerTreatments {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Treatments = append(o.R.Treatments, rel)
		}
	}

	return nil
}

// LoadTreatmentareas loads the organization's Treatmentareas into the .R struct
func (o *Organization) LoadTreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Treatmentareas = nil

	related, err := o.Treatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Treatmentareas = related
	return nil
}

// LoadTreatmentareas loads the organization's Treatmentareas into the .R struct
func (os OrganizationSlice) LoadTreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerTreatmentareas, err := os.Treatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Treatmentareas = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerTreatmentareas {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Treatmentareas = append(o.R.Treatmentareas, rel)
		}
	}

	return nil
}

// LoadZones loads the organization's Zones into the .R struct
func (o *Organization) LoadZones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Zones = nil

	related, err := o.Zones(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Zones = related
	return nil
}

// LoadZones loads the organization's Zones into the .R struct
func (os OrganizationSlice) LoadZones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerZones, err := os.Zones(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Zones = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerZones {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Zones = append(o.R.Zones, rel)
		}
	}

	return nil
}

// LoadZones2s loads the organization's Zones2s into the .R struct
func (o *Organization) LoadZones2s(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Zones2s = nil

	related, err := o.Zones2s(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Zones2s = related
	return nil
}

// LoadZones2s loads the organization's Zones2s into the .R struct
func (os OrganizationSlice) LoadZones2s(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerZones2s, err := os.Zones2s(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Zones2s = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerZones2s {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Zones2s = append(o.R.Zones2s, rel)
		}
	}

	return nil
}

// LoadFieldseekerSyncs loads the organization's FieldseekerSyncs into the .R struct
func (o *Organization) LoadFieldseekerSyncs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FieldseekerSyncs = nil

	related, err := o.FieldseekerSyncs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FieldseekerSyncs = related
	return nil
}

// LoadFieldseekerSyncs loads the organization's FieldseekerSyncs into the .R struct
func (os OrganizationSlice) LoadFieldseekerSyncs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fieldseekerSyncs, err := os.FieldseekerSyncs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FieldseekerSyncs = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fieldseekerSyncs {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.FieldseekerSyncs = append(o.R.FieldseekerSyncs, rel)
		}
	}

	return nil
}

// LoadFiles loads the organization's Files into the .R struct
func (o *Organization) LoadFiles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Files = nil

	related, err := o.Files(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Files = related
	return nil
}

// LoadFiles loads the organization's Files into the .R struct
func (os OrganizationSlice) LoadFiles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fileuploadFiles, err := os.Files(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Files = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fileuploadFiles {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Files = append(o.R.Files, rel)
		}
	}

	return nil
}

// LoadH3Aggregations loads the organization's H3Aggregations into the .R struct
func (o *Organization) LoadH3Aggregations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.H3Aggregations = nil

	related, err := o.H3Aggregations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.H3Aggregations = related
	return nil
}

// LoadH3Aggregations loads the organization's H3Aggregations into the .R struct
func (os OrganizationSlice) LoadH3Aggregations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	h3Aggregations, err := os.H3Aggregations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.H3Aggregations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range h3Aggregations {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.H3Aggregations = append(o.R.H3Aggregations, rel)
		}
	}

	return nil
}

// LoadNoteAudios loads the organization's NoteAudios into the .R struct
func (o *Organization) LoadNoteAudios(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.NoteAudios = nil

	related, err := o.NoteAudios(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.NoteAudios = related
	return nil
}

// LoadNoteAudios loads the organization's NoteAudios into the .R struct
func (os OrganizationSlice) LoadNoteAudios(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	noteAudios, err := os.NoteAudios(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.NoteAudios = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range noteAudios {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.NoteAudios = append(o.R.NoteAudios, rel)
		}
	}

	return nil
}

// LoadNoteImages loads the organization's NoteImages into the .R struct
func (o *Organization) LoadNoteImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.NoteImages = nil

	related, err := o.NoteImages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.NoteImages = related
	return nil
}

// LoadNoteImages loads the organization's NoteImages into the .R struct
func (os OrganizationSlice) LoadNoteImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	noteImages, err := os.NoteImages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.NoteImages = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range noteImages {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.NoteImages = append(o.R.NoteImages, rel)
		}
	}

	return nil
}

// LoadImportDistrictGidDistrict loads the organization's ImportDistrictGidDistrict into the .R struct
func (o *Organization) LoadImportDistrictGidDistrict(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ImportDistrictGidDistrict = nil

	related, err := o.ImportDistrictGidDistrict(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.ImportDistrictGidOrganization = o

	o.R.ImportDistrictGidDistrict = related
	return nil
}

// LoadImportDistrictGidDistrict loads the organization's ImportDistrictGidDistrict into the .R struct
func (os OrganizationSlice) LoadImportDistrictGidDistrict(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	importDistricts, err := os.ImportDistrictGidDistrict(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range importDistricts {
			if !o.ImportDistrictGid.IsValue() {
				continue
			}

			if !(o.ImportDistrictGid.IsValue() && o.ImportDistrictGid.MustGet() == rel.Gid) {
				continue
			}

			rel.R.ImportDistrictGidOrganization = o

			o.R.ImportDistrictGidDistrict = rel
			break
		}
	}

	return nil
}

// LoadPools loads the organization's Pools into the .R struct
func (o *Organization) LoadPools(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Pools = nil

	related, err := o.Pools(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Pools = related
	return nil
}

// LoadPools loads the organization's Pools into the .R struct
func (os OrganizationSlice) LoadPools(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	pools, err := os.Pools(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Pools = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range pools {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.Pools = append(o.R.Pools, rel)
		}
	}

	return nil
}

// LoadNuisances loads the organization's Nuisances into the .R struct
func (o *Organization) LoadNuisances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Nuisances = nil

	related, err := o.Nuisances(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Nuisances = related
	return nil
}

// LoadNuisances loads the organization's Nuisances into the .R struct
func (os OrganizationSlice) LoadNuisances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	publicreportNuisances, err := os.Nuisances(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Nuisances = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range publicreportNuisances {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.Nuisances = append(o.R.Nuisances, rel)
		}
	}

	return nil
}

// LoadPublicreportPool loads the organization's PublicreportPool into the .R struct
func (o *Organization) LoadPublicreportPool(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.PublicreportPool = nil

	related, err := o.PublicreportPool(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.PublicreportPool = related
	return nil
}

// LoadPublicreportPool loads the organization's PublicreportPool into the .R struct
func (os OrganizationSlice) LoadPublicreportPool(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	publicreportPools, err := os.PublicreportPool(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.PublicreportPool = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range publicreportPools {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.PublicreportPool = append(o.R.PublicreportPool, rel)
		}
	}

	return nil
}

// LoadQuicks loads the organization's Quicks into the .R struct
func (o *Organization) LoadQuicks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Quicks = nil

	related, err := o.Quicks(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.Quicks = related
	return nil
}

// LoadQuicks loads the organization's Quicks into the .R struct
func (os OrganizationSlice) LoadQuicks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	publicreportQuicks, err := os.Quicks(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Quicks = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range publicreportQuicks {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.Quicks = append(o.R.Quicks, rel)
		}
	}

	return nil
}

// LoadUser loads the organization's User into the .R struct
func (o *Organization) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.User = nil

	related, err := o.User(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.User = related
	return nil
}

// LoadUser loads the organization's User into the .R struct
func (os OrganizationSlice) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.User(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.User = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range users {

			if !(o.ID == rel.OrganizationID) {
				continue
			}

			rel.R.Organization = o

			o.R.User = append(o.R.User, rel)
		}
	}

	return nil
}

// organizationC is where relationship counts are stored.
type organizationC struct {
	EmailContacts           *int64
	Phones                  *int64
	Containerrelates        *int64
	Fieldscoutinglogs       *int64
	Habitatrelates          *int64
	Inspectionsamples       *int64
	Inspectionsampledetails *int64
	Linelocations           *int64
	Locationtrackings       *int64
	Mosquitoinspections     *int64
	Pointlocations          *int64
	Polygonlocations        *int64
	FieldseekerPool         *int64
	Pooldetails             *int64
	Proposedtreatmentareas  *int64
	Qamosquitoinspections   *int64
	Rodentlocations         *int64
	Samplecollections       *int64
	Samplelocations         *int64
	Servicerequests         *int64
	Speciesabundances       *int64
	Stormdrains             *int64
	Timecards               *int64
	Trapdata                *int64
	Traplocations           *int64
	Treatments              *int64
	Treatmentareas          *int64
	Zones                   *int64
	Zones2s                 *int64
	FieldseekerSyncs        *int64
	Files                   *int64
	H3Aggregations          *int64
	NoteAudios              *int64
	NoteImages              *int64
	Pools                   *int64
	Nuisances               *int64
	PublicreportPool        *int64
	Quicks                  *int64
	User                    *int64
}

// PreloadCount sets a count in the C struct by name
func (o *Organization) PreloadCount(name string, count int64) error {
	if o == nil {
		return nil
	}

	switch name {
	case "EmailContacts":
		o.C.EmailContacts = &count
	case "Phones":
		o.C.Phones = &count
	case "Containerrelates":
		o.C.Containerrelates = &count
	case "Fieldscoutinglogs":
		o.C.Fieldscoutinglogs = &count
	case "Habitatrelates":
		o.C.Habitatrelates = &count
	case "Inspectionsamples":
		o.C.Inspectionsamples = &count
	case "Inspectionsampledetails":
		o.C.Inspectionsampledetails = &count
	case "Linelocations":
		o.C.Linelocations = &count
	case "Locationtrackings":
		o.C.Locationtrackings = &count
	case "Mosquitoinspections":
		o.C.Mosquitoinspections = &count
	case "Pointlocations":
		o.C.Pointlocations = &count
	case "Polygonlocations":
		o.C.Polygonlocations = &count
	case "FieldseekerPool":
		o.C.FieldseekerPool = &count
	case "Pooldetails":
		o.C.Pooldetails = &count
	case "Proposedtreatmentareas":
		o.C.Proposedtreatmentareas = &count
	case "Qamosquitoinspections":
		o.C.Qamosquitoinspections = &count
	case "Rodentlocations":
		o.C.Rodentlocations = &count
	case "Samplecollections":
		o.C.Samplecollections = &count
	case "Samplelocations":
		o.C.Samplelocations = &count
	case "Servicerequests":
		o.C.Servicerequests = &count
	case "Speciesabundances":
		o.C.Speciesabundances = &count
	case "Stormdrains":
		o.C.Stormdrains = &count
	case "Timecards":
		o.C.Timecards = &count
	case "Trapdata":
		o.C.Trapdata = &count
	case "Traplocations":
		o.C.Traplocations = &count
	case "Treatments":
		o.C.Treatments = &count
	case "Treatmentareas":
		o.C.Treatmentareas = &count
	case "Zones":
		o.C.Zones = &count
	case "Zones2s":
		o.C.Zones2s = &count
	case "FieldseekerSyncs":
		o.C.FieldseekerSyncs = &count
	case "Files":
		o.C.Files = &count
	case "H3Aggregations":
		o.C.H3Aggregations = &count
	case "NoteAudios":
		o.C.NoteAudios = &count
	case "NoteImages":
		o.C.NoteImages = &count
	case "Pools":
		o.C.Pools = &count
	case "Nuisances":
		o.C.Nuisances = &count
	case "PublicreportPool":
		o.C.PublicreportPool = &count
	case "Quicks":
		o.C.Quicks = &count
	case "User":
		o.C.User = &count
	}
	return nil
}

type organizationCountPreloader struct {
	EmailContacts           func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Phones                  func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Containerrelates        func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Fieldscoutinglogs       func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Habitatrelates          func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Inspectionsamples       func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Inspectionsampledetails func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Linelocations           func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Locationtrackings       func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Mosquitoinspections     func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Pointlocations          func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Polygonlocations        func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	FieldseekerPool         func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Pooldetails             func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Proposedtreatmentareas  func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Qamosquitoinspections   func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Rodentlocations         func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Samplecollections       func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Samplelocations         func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Servicerequests         func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Speciesabundances       func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Stormdrains             func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Timecards               func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Trapdata                func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Traplocations           func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Treatments              func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Treatmentareas          func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Zones                   func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Zones2s                 func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	FieldseekerSyncs        func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Files                   func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	H3Aggregations          func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	NoteAudios              func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	NoteImages              func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Pools                   func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Nuisances               func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	PublicreportPool        func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	Quicks                  func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
	User                    func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
}

func buildOrganizationCountPreloader() organizationCountPreloader {
	return organizationCountPreloader{
		EmailContacts: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("EmailContacts", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(DistrictSubscriptionEmails.Name()),
					sm.Where(psql.Quote(DistrictSubscriptionEmails.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
					sm.InnerJoin(CommsEmailContacts.Name()).On(
						psql.Quote(CommsEmailContacts.Alias(), "address").EQ(psql.Quote(DistrictSubscriptionEmails.Alias(), "email_contact_address")),
					),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Phones: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Phones", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(DistrictSubscriptionPhones.Name()),
					sm.Where(psql.Quote(DistrictSubscriptionPhones.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
					sm.InnerJoin(CommsPhones.Name()).On(
						psql.Quote(CommsPhones.Alias(), "e164").EQ(psql.Quote(DistrictSubscriptionPhones.Alias(), "phone_e164")),
					),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Containerrelates: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Containerrelates", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerContainerrelates.Name()),
					sm.Where(psql.Quote(FieldseekerContainerrelates.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Fieldscoutinglogs: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Fieldscoutinglogs", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerFieldscoutinglogs.Name()),
					sm.Where(psql.Quote(FieldseekerFieldscoutinglogs.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Habitatrelates: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Habitatrelates", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerHabitatrelates.Name()),
					sm.Where(psql.Quote(FieldseekerHabitatrelates.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Inspectionsamples: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Inspectionsamples", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerInspectionsamples.Name()),
					sm.Where(psql.Quote(FieldseekerInspectionsamples.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Inspectionsampledetails: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Inspectionsampledetails", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerInspectionsampledetails.Name()),
					sm.Where(psql.Quote(FieldseekerInspectionsampledetails.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Linelocations: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Linelocations", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerLinelocations.Name()),
					sm.Where(psql.Quote(FieldseekerLinelocations.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Locationtrackings: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Locationtrackings", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerLocationtrackings.Name()),
					sm.Where(psql.Quote(FieldseekerLocationtrackings.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Mosquitoinspections: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Mosquitoinspections", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerMosquitoinspections.Name()),
					sm.Where(psql.Quote(FieldseekerMosquitoinspections.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Pointlocations: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Pointlocations", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerPointlocations.Name()),
					sm.Where(psql.Quote(FieldseekerPointlocations.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Polygonlocations: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Polygonlocations", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerPolygonlocations.Name()),
					sm.Where(psql.Quote(FieldseekerPolygonlocations.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		FieldseekerPool: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("FieldseekerPool", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerPools.Name()),
					sm.Where(psql.Quote(FieldseekerPools.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Pooldetails: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Pooldetails", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerPooldetails.Name()),
					sm.Where(psql.Quote(FieldseekerPooldetails.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Proposedtreatmentareas: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Proposedtreatmentareas", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerProposedtreatmentareas.Name()),
					sm.Where(psql.Quote(FieldseekerProposedtreatmentareas.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Qamosquitoinspections: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Qamosquitoinspections", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerQamosquitoinspections.Name()),
					sm.Where(psql.Quote(FieldseekerQamosquitoinspections.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Rodentlocations: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Rodentlocations", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerRodentlocations.Name()),
					sm.Where(psql.Quote(FieldseekerRodentlocations.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Samplecollections: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Samplecollections", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerSamplecollections.Name()),
					sm.Where(psql.Quote(FieldseekerSamplecollections.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Samplelocations: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Samplelocations", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerSamplelocations.Name()),
					sm.Where(psql.Quote(FieldseekerSamplelocations.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Servicerequests: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Servicerequests", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerServicerequests.Name()),
					sm.Where(psql.Quote(FieldseekerServicerequests.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Speciesabundances: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Speciesabundances", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerSpeciesabundances.Name()),
					sm.Where(psql.Quote(FieldseekerSpeciesabundances.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Stormdrains: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Stormdrains", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerStormdrains.Name()),
					sm.Where(psql.Quote(FieldseekerStormdrains.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Timecards: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Timecards", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerTimecards.Name()),
					sm.Where(psql.Quote(FieldseekerTimecards.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Trapdata: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Trapdata", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerTrapdata.Name()),
					sm.Where(psql.Quote(FieldseekerTrapdata.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Traplocations: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Traplocations", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerTraplocations.Name()),
					sm.Where(psql.Quote(FieldseekerTraplocations.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Treatments: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Treatments", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerTreatments.Name()),
					sm.Where(psql.Quote(FieldseekerTreatments.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Treatmentareas: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Treatmentareas", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerTreatmentareas.Name()),
					sm.Where(psql.Quote(FieldseekerTreatmentareas.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Zones: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Zones", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerZones.Name()),
					sm.Where(psql.Quote(FieldseekerZones.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Zones2s: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Zones2s", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerZones2s.Name()),
					sm.Where(psql.Quote(FieldseekerZones2s.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		FieldseekerSyncs: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("FieldseekerSyncs", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FieldseekerSyncs.Name()),
					sm.Where(psql.Quote(FieldseekerSyncs.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Files: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Files", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(FileuploadFiles.Name()),
					sm.Where(psql.Quote(FileuploadFiles.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		H3Aggregations: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("H3Aggregations", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(H3Aggregations.Name()),
					sm.Where(psql.Quote(H3Aggregations.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		NoteAudios: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("NoteAudios", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(NoteAudios.Name()),
					sm.Where(psql.Quote(NoteAudios.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		NoteImages: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("NoteImages", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(NoteImages.Name()),
					sm.Where(psql.Quote(NoteImages.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Pools: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Pools", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(Pools.Name()),
					sm.Where(psql.Quote(Pools.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Nuisances: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Nuisances", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(PublicreportNuisances.Name()),
					sm.Where(psql.Quote(PublicreportNuisances.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		PublicreportPool: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("PublicreportPool", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(PublicreportPools.Name()),
					sm.Where(psql.Quote(PublicreportPools.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		Quicks: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("Quicks", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(PublicreportQuicks.Name()),
					sm.Where(psql.Quote(PublicreportQuicks.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
		User: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*Organization]("User", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = Organizations.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(Users.Name()),
					sm.Where(psql.Quote(Users.Alias(), "organization_id").EQ(psql.Quote(parent, "id"))),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
	}
}

type organizationCountThenLoader[Q orm.Loadable] struct {
	EmailContacts           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Phones                  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Containerrelates        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Fieldscoutinglogs       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Habitatrelates          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Inspectionsamples       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Inspectionsampledetails func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Linelocations           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Locationtrackings       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Mosquitoinspections     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pointlocations          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Polygonlocations        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FieldseekerPool         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pooldetails             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Proposedtreatmentareas  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Qamosquitoinspections   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Rodentlocations         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Samplecollections       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Samplelocations         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Servicerequests         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Speciesabundances       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Stormdrains             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Timecards               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Trapdata                func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Traplocations           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Treatments              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Treatmentareas          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Zones                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Zones2s                 func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FieldseekerSyncs        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Files                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	H3Aggregations          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	NoteAudios              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	NoteImages              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Pools                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Nuisances               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	PublicreportPool        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Quicks                  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	User                    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildOrganizationCountThenLoader[Q orm.Loadable]() organizationCountThenLoader[Q] {
	type EmailContactsCountInterface interface {
		LoadCountEmailContacts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PhonesCountInterface interface {
		LoadCountPhones(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ContainerrelatesCountInterface interface {
		LoadCountContainerrelates(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FieldscoutinglogsCountInterface interface {
		LoadCountFieldscoutinglogs(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HabitatrelatesCountInterface interface {
		LoadCountHabitatrelates(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type InspectionsamplesCountInterface interface {
		LoadCountInspectionsamples(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type InspectionsampledetailsCountInterface interface {
		LoadCountInspectionsampledetails(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type LinelocationsCountInterface interface {
		LoadCountLinelocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type LocationtrackingsCountInterface interface {
		LoadCountLocationtrackings(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type MosquitoinspectionsCountInterface interface {
		LoadCountMosquitoinspections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PointlocationsCountInterface interface {
		LoadCountPointlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PolygonlocationsCountInterface interface {
		LoadCountPolygonlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FieldseekerPoolCountInterface interface {
		LoadCountFieldseekerPool(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PooldetailsCountInterface interface {
		LoadCountPooldetails(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ProposedtreatmentareasCountInterface interface {
		LoadCountProposedtreatmentareas(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type QamosquitoinspectionsCountInterface interface {
		LoadCountQamosquitoinspections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RodentlocationsCountInterface interface {
		LoadCountRodentlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SamplecollectionsCountInterface interface {
		LoadCountSamplecollections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SamplelocationsCountInterface interface {
		LoadCountSamplelocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ServicerequestsCountInterface interface {
		LoadCountServicerequests(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SpeciesabundancesCountInterface interface {
		LoadCountSpeciesabundances(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type StormdrainsCountInterface interface {
		LoadCountStormdrains(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TimecardsCountInterface interface {
		LoadCountTimecards(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TrapdataCountInterface interface {
		LoadCountTrapdata(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TraplocationsCountInterface interface {
		LoadCountTraplocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TreatmentsCountInterface interface {
		LoadCountTreatments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TreatmentareasCountInterface interface {
		LoadCountTreatmentareas(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ZonesCountInterface interface {
		LoadCountZones(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type Zones2sCountInterface interface {
		LoadCountZones2s(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FieldseekerSyncsCountInterface interface {
		LoadCountFieldseekerSyncs(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FilesCountInterface interface {
		LoadCountFiles(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type H3AggregationsCountInterface interface {
		LoadCountH3Aggregations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type NoteAudiosCountInterface interface {
		LoadCountNoteAudios(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type NoteImagesCountInterface interface {
		LoadCountNoteImages(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PoolsCountInterface interface {
		LoadCountPools(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type NuisancesCountInterface interface {
		LoadCountNuisances(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PublicreportPoolCountInterface interface {
		LoadCountPublicreportPool(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type QuicksCountInterface interface {
		LoadCountQuicks(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserCountInterface interface {
		LoadCountUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return organizationCountThenLoader[Q]{
		EmailContacts: countThenLoadBuilder[Q](
			"EmailContacts",
			func(ctx context.Context, exec bob.Executor, retrieved EmailContactsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountEmailContacts(ctx, exec, mods...)
			},
		),
		Phones: countThenLoadBuilder[Q](
			"Phones",
			func(ctx context.Context, exec bob.Executor, retrieved PhonesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountPhones(ctx, exec, mods...)
			},
		),
		Containerrelates: countThenLoadBuilder[Q](
			"Containerrelates",
			func(ctx context.Context, exec bob.Executor, retrieved ContainerrelatesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountContainerrelates(ctx, exec, mods...)
			},
		),
		Fieldscoutinglogs: countThenLoadBuilder[Q](
			"Fieldscoutinglogs",
			func(ctx context.Context, exec bob.Executor, retrieved FieldscoutinglogsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountFieldscoutinglogs(ctx, exec, mods...)
			},
		),
		Habitatrelates: countThenLoadBuilder[Q](
			"Habitatrelates",
			func(ctx context.Context, exec bob.Executor, retrieved HabitatrelatesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountHabitatrelates(ctx, exec, mods...)
			},
		),
		Inspectionsamples: countThenLoadBuilder[Q](
			"Inspectionsamples",
			func(ctx context.Context, exec bob.Executor, retrieved InspectionsamplesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountInspectionsamples(ctx, exec, mods...)
			},
		),
		Inspectionsampledetails: countThenLoadBuilder[Q](
			"Inspectionsampledetails",
			func(ctx context.Context, exec bob.Executor, retrieved InspectionsampledetailsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountInspectionsampledetails(ctx, exec, mods...)
			},
		),
		Linelocations: countThenLoadBuilder[Q](
			"Linelocations",
			func(ctx context.Context, exec bob.Executor, retrieved LinelocationsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountLinelocations(ctx, exec, mods...)
			},
		),
		Locationtrackings: countThenLoadBuilder[Q](
			"Locationtrackings",
			func(ctx context.Context, exec bob.Executor, retrieved LocationtrackingsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountLocationtrackings(ctx, exec, mods...)
			},
		),
		Mosquitoinspections: countThenLoadBuilder[Q](
			"Mosquitoinspections",
			func(ctx context.Context, exec bob.Executor, retrieved MosquitoinspectionsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountMosquitoinspections(ctx, exec, mods...)
			},
		),
		Pointlocations: countThenLoadBuilder[Q](
			"Pointlocations",
			func(ctx context.Context, exec bob.Executor, retrieved PointlocationsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountPointlocations(ctx, exec, mods...)
			},
		),
		Polygonlocations: countThenLoadBuilder[Q](
			"Polygonlocations",
			func(ctx context.Context, exec bob.Executor, retrieved PolygonlocationsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountPolygonlocations(ctx, exec, mods...)
			},
		),
		FieldseekerPool: countThenLoadBuilder[Q](
			"FieldseekerPool",
			func(ctx context.Context, exec bob.Executor, retrieved FieldseekerPoolCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountFieldseekerPool(ctx, exec, mods...)
			},
		),
		Pooldetails: countThenLoadBuilder[Q](
			"Pooldetails",
			func(ctx context.Context, exec bob.Executor, retrieved PooldetailsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountPooldetails(ctx, exec, mods...)
			},
		),
		Proposedtreatmentareas: countThenLoadBuilder[Q](
			"Proposedtreatmentareas",
			func(ctx context.Context, exec bob.Executor, retrieved ProposedtreatmentareasCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountProposedtreatmentareas(ctx, exec, mods...)
			},
		),
		Qamosquitoinspections: countThenLoadBuilder[Q](
			"Qamosquitoinspections",
			func(ctx context.Context, exec bob.Executor, retrieved QamosquitoinspectionsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountQamosquitoinspections(ctx, exec, mods...)
			},
		),
		Rodentlocations: countThenLoadBuilder[Q](
			"Rodentlocations",
			func(ctx context.Context, exec bob.Executor, retrieved RodentlocationsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountRodentlocations(ctx, exec, mods...)
			},
		),
		Samplecollections: countThenLoadBuilder[Q](
			"Samplecollections",
			func(ctx context.Context, exec bob.Executor, retrieved SamplecollectionsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountSamplecollections(ctx, exec, mods...)
			},
		),
		Samplelocations: countThenLoadBuilder[Q](
			"Samplelocations",
			func(ctx context.Context, exec bob.Executor, retrieved SamplelocationsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountSamplelocations(ctx, exec, mods...)
			},
		),
		Servicerequests: countThenLoadBuilder[Q](
			"Servicerequests",
			func(ctx context.Context, exec bob.Executor, retrieved ServicerequestsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountServicerequests(ctx, exec, mods...)
			},
		),
		Speciesabundances: countThenLoadBuilder[Q](
			"Speciesabundances",
			func(ctx context.Context, exec bob.Executor, retrieved SpeciesabundancesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountSpeciesabundances(ctx, exec, mods...)
			},
		),
		Stormdrains: countThenLoadBuilder[Q](
			"Stormdrains",
			func(ctx context.Context, exec bob.Executor, retrieved StormdrainsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountStormdrains(ctx, exec, mods...)
			},
		),
		Timecards: countThenLoadBuilder[Q](
			"Timecards",
			func(ctx context.Context, exec bob.Executor, retrieved TimecardsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountTimecards(ctx, exec, mods...)
			},
		),
		Trapdata: countThenLoadBuilder[Q](
			"Trapdata",
			func(ctx context.Context, exec bob.Executor, retrieved TrapdataCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountTrapdata(ctx, exec, mods...)
			},
		),
		Traplocations: countThenLoadBuilder[Q](
			"Traplocations",
			func(ctx context.Context, exec bob.Executor, retrieved TraplocationsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountTraplocations(ctx, exec, mods...)
			},
		),
		Treatments: countThenLoadBuilder[Q](
			"Treatments",
			func(ctx context.Context, exec bob.Executor, retrieved TreatmentsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountTreatments(ctx, exec, mods...)
			},
		),
		Treatmentareas: countThenLoadBuilder[Q](
			"Treatmentareas",
			func(ctx context.Context, exec bob.Executor, retrieved TreatmentareasCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountTreatmentareas(ctx, exec, mods...)
			},
		),
		Zones: countThenLoadBuilder[Q](
			"Zones",
			func(ctx context.Context, exec bob.Executor, retrieved ZonesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountZones(ctx, exec, mods...)
			},
		),
		Zones2s: countThenLoadBuilder[Q](
			"Zones2s",
			func(ctx context.Context, exec bob.Executor, retrieved Zones2sCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountZones2s(ctx, exec, mods...)
			},
		),
		FieldseekerSyncs: countThenLoadBuilder[Q](
			"FieldseekerSyncs",
			func(ctx context.Context, exec bob.Executor, retrieved FieldseekerSyncsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountFieldseekerSyncs(ctx, exec, mods...)
			},
		),
		Files: countThenLoadBuilder[Q](
			"Files",
			func(ctx context.Context, exec bob.Executor, retrieved FilesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountFiles(ctx, exec, mods...)
			},
		),
		H3Aggregations: countThenLoadBuilder[Q](
			"H3Aggregations",
			func(ctx context.Context, exec bob.Executor, retrieved H3AggregationsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountH3Aggregations(ctx, exec, mods...)
			},
		),
		NoteAudios: countThenLoadBuilder[Q](
			"NoteAudios",
			func(ctx context.Context, exec bob.Executor, retrieved NoteAudiosCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountNoteAudios(ctx, exec, mods...)
			},
		),
		NoteImages: countThenLoadBuilder[Q](
			"NoteImages",
			func(ctx context.Context, exec bob.Executor, retrieved NoteImagesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountNoteImages(ctx, exec, mods...)
			},
		),
		Pools: countThenLoadBuilder[Q](
			"Pools",
			func(ctx context.Context, exec bob.Executor, retrieved PoolsCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountPools(ctx, exec, mods...)
			},
		),
		Nuisances: countThenLoadBuilder[Q](
			"Nuisances",
			func(ctx context.Context, exec bob.Executor, retrieved NuisancesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountNuisances(ctx, exec, mods...)
			},
		),
		PublicreportPool: countThenLoadBuilder[Q](
			"PublicreportPool",
			func(ctx context.Context, exec bob.Executor, retrieved PublicreportPoolCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountPublicreportPool(ctx, exec, mods...)
			},
		),
		Quicks: countThenLoadBuilder[Q](
			"Quicks",
			func(ctx context.Context, exec bob.Executor, retrieved QuicksCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountQuicks(ctx, exec, mods...)
			},
		),
		User: countThenLoadBuilder[Q](
			"User",
			func(ctx context.Context, exec bob.Executor, retrieved UserCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadCountEmailContacts loads the count of EmailContacts into the C struct
func (o *Organization) LoadCountEmailContacts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.EmailContacts(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.EmailContacts = &count
	return nil
}

// LoadCountEmailContacts loads the count of EmailContacts for a slice
func (os OrganizationSlice) LoadCountEmailContacts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountEmailContacts(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountPhones loads the count of Phones into the C struct
func (o *Organization) LoadCountPhones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Phones(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Phones = &count
	return nil
}

// LoadCountPhones loads the count of Phones for a slice
func (os OrganizationSlice) LoadCountPhones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountPhones(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountContainerrelates loads the count of Containerrelates into the C struct
func (o *Organization) LoadCountContainerrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Containerrelates(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Containerrelates = &count
	return nil
}

// LoadCountContainerrelates loads the count of Containerrelates for a slice
func (os OrganizationSlice) LoadCountContainerrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountContainerrelates(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountFieldscoutinglogs loads the count of Fieldscoutinglogs into the C struct
func (o *Organization) LoadCountFieldscoutinglogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Fieldscoutinglogs(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Fieldscoutinglogs = &count
	return nil
}

// LoadCountFieldscoutinglogs loads the count of Fieldscoutinglogs for a slice
func (os OrganizationSlice) LoadCountFieldscoutinglogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountFieldscoutinglogs(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountHabitatrelates loads the count of Habitatrelates into the C struct
func (o *Organization) LoadCountHabitatrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Habitatrelates(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Habitatrelates = &count
	return nil
}

// LoadCountHabitatrelates loads the count of Habitatrelates for a slice
func (os OrganizationSlice) LoadCountHabitatrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountHabitatrelates(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountInspectionsamples loads the count of Inspectionsamples into the C struct
func (o *Organization) LoadCountInspectionsamples(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Inspectionsamples(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Inspectionsamples = &count
	return nil
}

// LoadCountInspectionsamples loads the count of Inspectionsamples for a slice
func (os OrganizationSlice) LoadCountInspectionsamples(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountInspectionsamples(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountInspectionsampledetails loads the count of Inspectionsampledetails into the C struct
func (o *Organization) LoadCountInspectionsampledetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Inspectionsampledetails(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Inspectionsampledetails = &count
	return nil
}

// LoadCountInspectionsampledetails loads the count of Inspectionsampledetails for a slice
func (os OrganizationSlice) LoadCountInspectionsampledetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountInspectionsampledetails(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountLinelocations loads the count of Linelocations into the C struct
func (o *Organization) LoadCountLinelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Linelocations(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Linelocations = &count
	return nil
}

// LoadCountLinelocations loads the count of Linelocations for a slice
func (os OrganizationSlice) LoadCountLinelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountLinelocations(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountLocationtrackings loads the count of Locationtrackings into the C struct
func (o *Organization) LoadCountLocationtrackings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Locationtrackings(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Locationtrackings = &count
	return nil
}

// LoadCountLocationtrackings loads the count of Locationtrackings for a slice
func (os OrganizationSlice) LoadCountLocationtrackings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountLocationtrackings(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountMosquitoinspections loads the count of Mosquitoinspections into the C struct
func (o *Organization) LoadCountMosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Mosquitoinspections(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Mosquitoinspections = &count
	return nil
}

// LoadCountMosquitoinspections loads the count of Mosquitoinspections for a slice
func (os OrganizationSlice) LoadCountMosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountMosquitoinspections(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountPointlocations loads the count of Pointlocations into the C struct
func (o *Organization) LoadCountPointlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Pointlocations(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Pointlocations = &count
	return nil
}

// LoadCountPointlocations loads the count of Pointlocations for a slice
func (os OrganizationSlice) LoadCountPointlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountPointlocations(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountPolygonlocations loads the count of Polygonlocations into the C struct
func (o *Organization) LoadCountPolygonlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Polygonlocations(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Polygonlocations = &count
	return nil
}

// LoadCountPolygonlocations loads the count of Polygonlocations for a slice
func (os OrganizationSlice) LoadCountPolygonlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountPolygonlocations(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountFieldseekerPool loads the count of FieldseekerPool into the C struct
func (o *Organization) LoadCountFieldseekerPool(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.FieldseekerPool(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.FieldseekerPool = &count
	return nil
}

// LoadCountFieldseekerPool loads the count of FieldseekerPool for a slice
func (os OrganizationSlice) LoadCountFieldseekerPool(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountFieldseekerPool(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountPooldetails loads the count of Pooldetails into the C struct
func (o *Organization) LoadCountPooldetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Pooldetails(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Pooldetails = &count
	return nil
}

// LoadCountPooldetails loads the count of Pooldetails for a slice
func (os OrganizationSlice) LoadCountPooldetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountPooldetails(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountProposedtreatmentareas loads the count of Proposedtreatmentareas into the C struct
func (o *Organization) LoadCountProposedtreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Proposedtreatmentareas(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Proposedtreatmentareas = &count
	return nil
}

// LoadCountProposedtreatmentareas loads the count of Proposedtreatmentareas for a slice
func (os OrganizationSlice) LoadCountProposedtreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountProposedtreatmentareas(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountQamosquitoinspections loads the count of Qamosquitoinspections into the C struct
func (o *Organization) LoadCountQamosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Qamosquitoinspections(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Qamosquitoinspections = &count
	return nil
}

// LoadCountQamosquitoinspections loads the count of Qamosquitoinspections for a slice
func (os OrganizationSlice) LoadCountQamosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountQamosquitoinspections(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountRodentlocations loads the count of Rodentlocations into the C struct
func (o *Organization) LoadCountRodentlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Rodentlocations(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Rodentlocations = &count
	return nil
}

// LoadCountRodentlocations loads the count of Rodentlocations for a slice
func (os OrganizationSlice) LoadCountRodentlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountRodentlocations(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountSamplecollections loads the count of Samplecollections into the C struct
func (o *Organization) LoadCountSamplecollections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Samplecollections(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Samplecollections = &count
	return nil
}

// LoadCountSamplecollections loads the count of Samplecollections for a slice
func (os OrganizationSlice) LoadCountSamplecollections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountSamplecollections(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountSamplelocations loads the count of Samplelocations into the C struct
func (o *Organization) LoadCountSamplelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Samplelocations(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Samplelocations = &count
	return nil
}

// LoadCountSamplelocations loads the count of Samplelocations for a slice
func (os OrganizationSlice) LoadCountSamplelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountSamplelocations(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountServicerequests loads the count of Servicerequests into the C struct
func (o *Organization) LoadCountServicerequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Servicerequests(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Servicerequests = &count
	return nil
}

// LoadCountServicerequests loads the count of Servicerequests for a slice
func (os OrganizationSlice) LoadCountServicerequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountServicerequests(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountSpeciesabundances loads the count of Speciesabundances into the C struct
func (o *Organization) LoadCountSpeciesabundances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Speciesabundances(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Speciesabundances = &count
	return nil
}

// LoadCountSpeciesabundances loads the count of Speciesabundances for a slice
func (os OrganizationSlice) LoadCountSpeciesabundances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountSpeciesabundances(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountStormdrains loads the count of Stormdrains into the C struct
func (o *Organization) LoadCountStormdrains(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Stormdrains(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Stormdrains = &count
	return nil
}

// LoadCountStormdrains loads the count of Stormdrains for a slice
func (os OrganizationSlice) LoadCountStormdrains(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountStormdrains(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountTimecards loads the count of Timecards into the C struct
func (o *Organization) LoadCountTimecards(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Timecards(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Timecards = &count
	return nil
}

// LoadCountTimecards loads the count of Timecards for a slice
func (os OrganizationSlice) LoadCountTimecards(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountTimecards(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountTrapdata loads the count of Trapdata into the C struct
func (o *Organization) LoadCountTrapdata(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Trapdata(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Trapdata = &count
	return nil
}

// LoadCountTrapdata loads the count of Trapdata for a slice
func (os OrganizationSlice) LoadCountTrapdata(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountTrapdata(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountTraplocations loads the count of Traplocations into the C struct
func (o *Organization) LoadCountTraplocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Traplocations(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Traplocations = &count
	return nil
}

// LoadCountTraplocations loads the count of Traplocations for a slice
func (os OrganizationSlice) LoadCountTraplocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountTraplocations(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountTreatments loads the count of Treatments into the C struct
func (o *Organization) LoadCountTreatments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Treatments(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Treatments = &count
	return nil
}

// LoadCountTreatments loads the count of Treatments for a slice
func (os OrganizationSlice) LoadCountTreatments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountTreatments(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountTreatmentareas loads the count of Treatmentareas into the C struct
func (o *Organization) LoadCountTreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Treatmentareas(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Treatmentareas = &count
	return nil
}

// LoadCountTreatmentareas loads the count of Treatmentareas for a slice
func (os OrganizationSlice) LoadCountTreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountTreatmentareas(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountZones loads the count of Zones into the C struct
func (o *Organization) LoadCountZones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Zones(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Zones = &count
	return nil
}

// LoadCountZones loads the count of Zones for a slice
func (os OrganizationSlice) LoadCountZones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountZones(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountZones2s loads the count of Zones2s into the C struct
func (o *Organization) LoadCountZones2s(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Zones2s(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Zones2s = &count
	return nil
}

// LoadCountZones2s loads the count of Zones2s for a slice
func (os OrganizationSlice) LoadCountZones2s(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountZones2s(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountFieldseekerSyncs loads the count of FieldseekerSyncs into the C struct
func (o *Organization) LoadCountFieldseekerSyncs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.FieldseekerSyncs(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.FieldseekerSyncs = &count
	return nil
}

// LoadCountFieldseekerSyncs loads the count of FieldseekerSyncs for a slice
func (os OrganizationSlice) LoadCountFieldseekerSyncs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountFieldseekerSyncs(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountFiles loads the count of Files into the C struct
func (o *Organization) LoadCountFiles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Files(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Files = &count
	return nil
}

// LoadCountFiles loads the count of Files for a slice
func (os OrganizationSlice) LoadCountFiles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountFiles(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountH3Aggregations loads the count of H3Aggregations into the C struct
func (o *Organization) LoadCountH3Aggregations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.H3Aggregations(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.H3Aggregations = &count
	return nil
}

// LoadCountH3Aggregations loads the count of H3Aggregations for a slice
func (os OrganizationSlice) LoadCountH3Aggregations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountH3Aggregations(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountNoteAudios loads the count of NoteAudios into the C struct
func (o *Organization) LoadCountNoteAudios(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.NoteAudios(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.NoteAudios = &count
	return nil
}

// LoadCountNoteAudios loads the count of NoteAudios for a slice
func (os OrganizationSlice) LoadCountNoteAudios(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountNoteAudios(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountNoteImages loads the count of NoteImages into the C struct
func (o *Organization) LoadCountNoteImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.NoteImages(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.NoteImages = &count
	return nil
}

// LoadCountNoteImages loads the count of NoteImages for a slice
func (os OrganizationSlice) LoadCountNoteImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountNoteImages(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountPools loads the count of Pools into the C struct
func (o *Organization) LoadCountPools(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Pools(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Pools = &count
	return nil
}

// LoadCountPools loads the count of Pools for a slice
func (os OrganizationSlice) LoadCountPools(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountPools(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountNuisances loads the count of Nuisances into the C struct
func (o *Organization) LoadCountNuisances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Nuisances(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Nuisances = &count
	return nil
}

// LoadCountNuisances loads the count of Nuisances for a slice
func (os OrganizationSlice) LoadCountNuisances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountNuisances(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountPublicreportPool loads the count of PublicreportPool into the C struct
func (o *Organization) LoadCountPublicreportPool(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.PublicreportPool(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.PublicreportPool = &count
	return nil
}

// LoadCountPublicreportPool loads the count of PublicreportPool for a slice
func (os OrganizationSlice) LoadCountPublicreportPool(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountPublicreportPool(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountQuicks loads the count of Quicks into the C struct
func (o *Organization) LoadCountQuicks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Quicks(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Quicks = &count
	return nil
}

// LoadCountQuicks loads the count of Quicks for a slice
func (os OrganizationSlice) LoadCountQuicks(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountQuicks(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

// LoadCountUser loads the count of User into the C struct
func (o *Organization) LoadCountUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.User(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.User = &count
	return nil
}

// LoadCountUser loads the count of User for a slice
func (os OrganizationSlice) LoadCountUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountUser(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

type organizationJoins[Q dialect.Joinable] struct {
	typ                       string
	EmailContacts             modAs[Q, commsEmailContactColumns]
	Phones                    modAs[Q, commsPhoneColumns]
	Containerrelates          modAs[Q, fieldseekerContainerrelateColumns]
	Fieldscoutinglogs         modAs[Q, fieldseekerFieldscoutinglogColumns]
	Habitatrelates            modAs[Q, fieldseekerHabitatrelateColumns]
	Inspectionsamples         modAs[Q, fieldseekerInspectionsampleColumns]
	Inspectionsampledetails   modAs[Q, fieldseekerInspectionsampledetailColumns]
	Linelocations             modAs[Q, fieldseekerLinelocationColumns]
	Locationtrackings         modAs[Q, fieldseekerLocationtrackingColumns]
	Mosquitoinspections       modAs[Q, fieldseekerMosquitoinspectionColumns]
	Pointlocations            modAs[Q, fieldseekerPointlocationColumns]
	Polygonlocations          modAs[Q, fieldseekerPolygonlocationColumns]
	FieldseekerPool           modAs[Q, fieldseekerPoolColumns]
	Pooldetails               modAs[Q, fieldseekerPooldetailColumns]
	Proposedtreatmentareas    modAs[Q, fieldseekerProposedtreatmentareaColumns]
	Qamosquitoinspections     modAs[Q, fieldseekerQamosquitoinspectionColumns]
	Rodentlocations           modAs[Q, fieldseekerRodentlocationColumns]
	Samplecollections         modAs[Q, fieldseekerSamplecollectionColumns]
	Samplelocations           modAs[Q, fieldseekerSamplelocationColumns]
	Servicerequests           modAs[Q, fieldseekerServicerequestColumns]
	Speciesabundances         modAs[Q, fieldseekerSpeciesabundanceColumns]
	Stormdrains               modAs[Q, fieldseekerStormdrainColumns]
	Timecards                 modAs[Q, fieldseekerTimecardColumns]
	Trapdata                  modAs[Q, fieldseekerTrapdatumColumns]
	Traplocations             modAs[Q, fieldseekerTraplocationColumns]
	Treatments                modAs[Q, fieldseekerTreatmentColumns]
	Treatmentareas            modAs[Q, fieldseekerTreatmentareaColumns]
	Zones                     modAs[Q, fieldseekerZoneColumns]
	Zones2s                   modAs[Q, fieldseekerZones2Columns]
	FieldseekerSyncs          modAs[Q, fieldseekerSyncColumns]
	Files                     modAs[Q, fileuploadFileColumns]
	H3Aggregations            modAs[Q, h3AggregationColumns]
	NoteAudios                modAs[Q, noteAudioColumns]
	NoteImages                modAs[Q, noteImageColumns]
	ImportDistrictGidDistrict modAs[Q, importDistrictColumns]
	Pools                     modAs[Q, poolColumns]
	Nuisances                 modAs[Q, publicreportNuisanceColumns]
	PublicreportPool          modAs[Q, publicreportPoolColumns]
	Quicks                    modAs[Q, publicreportQuickColumns]
	User                      modAs[Q, userColumns]
}

func (j organizationJoins[Q]) aliasedAs(alias string) organizationJoins[Q] {
	return buildOrganizationJoins[Q](buildOrganizationColumns(alias), j.typ)
}

func buildOrganizationJoins[Q dialect.Joinable](cols organizationColumns, typ string) organizationJoins[Q] {
	return organizationJoins[Q]{
		typ: typ,
		EmailContacts: modAs[Q, commsEmailContactColumns]{
			c: CommsEmailContacts.Columns,
			f: func(to commsEmailContactColumns) bob.Mod[Q] {
				random := strconv.FormatInt(randInt(), 10)
				mods := make(mods.QueryMods[Q], 0, 2)

				{
					to := DistrictSubscriptionEmails.Columns.AliasedAs(DistrictSubscriptionEmails.Columns.Alias() + random)
					mods = append(mods, dialect.Join[Q](typ, DistrictSubscriptionEmails.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}
				{
					cols := DistrictSubscriptionEmails.Columns.AliasedAs(DistrictSubscriptionEmails.Columns.Alias() + random)
					mods = append(mods, dialect.Join[Q](typ, CommsEmailContacts.Name().As(to.Alias())).On(
						to.Address.EQ(cols.EmailContactAddress),
					))
				}

				return mods
			},
		},
		Phones: modAs[Q, commsPhoneColumns]{
			c: CommsPhones.Columns,
			f: func(to commsPhoneColumns) bob.Mod[Q] {
				random := strconv.FormatInt(randInt(), 10)
				mods := make(mods.QueryMods[Q], 0, 2)

				{
					to := DistrictSubscriptionPhones.Columns.AliasedAs(DistrictSubscriptionPhones.Columns.Alias() + random)
					mods = append(mods, dialect.Join[Q](typ, DistrictSubscriptionPhones.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}
				{
					cols := DistrictSubscriptionPhones.Columns.AliasedAs(DistrictSubscriptionPhones.Columns.Alias() + random)
					mods = append(mods, dialect.Join[Q](typ, CommsPhones.Name().As(to.Alias())).On(
						to.E164.EQ(cols.PhoneE164),
					))
				}

				return mods
			},
		},
		Containerrelates: modAs[Q, fieldseekerContainerrelateColumns]{
			c: FieldseekerContainerrelates.Columns,
			f: func(to fieldseekerContainerrelateColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerContainerrelates.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Fieldscoutinglogs: modAs[Q, fieldseekerFieldscoutinglogColumns]{
			c: FieldseekerFieldscoutinglogs.Columns,
			f: func(to fieldseekerFieldscoutinglogColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerFieldscoutinglogs.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Habitatrelates: modAs[Q, fieldseekerHabitatrelateColumns]{
			c: FieldseekerHabitatrelates.Columns,
			f: func(to fieldseekerHabitatrelateColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerHabitatrelates.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Inspectionsamples: modAs[Q, fieldseekerInspectionsampleColumns]{
			c: FieldseekerInspectionsamples.Columns,
			f: func(to fieldseekerInspectionsampleColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerInspectionsamples.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Inspectionsampledetails: modAs[Q, fieldseekerInspectionsampledetailColumns]{
			c: FieldseekerInspectionsampledetails.Columns,
			f: func(to fieldseekerInspectionsampledetailColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerInspectionsampledetails.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Linelocations: modAs[Q, fieldseekerLinelocationColumns]{
			c: FieldseekerLinelocations.Columns,
			f: func(to fieldseekerLinelocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerLinelocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Locationtrackings: modAs[Q, fieldseekerLocationtrackingColumns]{
			c: FieldseekerLocationtrackings.Columns,
			f: func(to fieldseekerLocationtrackingColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerLocationtrackings.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Mosquitoinspections: modAs[Q, fieldseekerMosquitoinspectionColumns]{
			c: FieldseekerMosquitoinspections.Columns,
			f: func(to fieldseekerMosquitoinspectionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerMosquitoinspections.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Pointlocations: modAs[Q, fieldseekerPointlocationColumns]{
			c: FieldseekerPointlocations.Columns,
			f: func(to fieldseekerPointlocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerPointlocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Polygonlocations: modAs[Q, fieldseekerPolygonlocationColumns]{
			c: FieldseekerPolygonlocations.Columns,
			f: func(to fieldseekerPolygonlocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerPolygonlocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FieldseekerPool: modAs[Q, fieldseekerPoolColumns]{
			c: FieldseekerPools.Columns,
			f: func(to fieldseekerPoolColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerPools.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Pooldetails: modAs[Q, fieldseekerPooldetailColumns]{
			c: FieldseekerPooldetails.Columns,
			f: func(to fieldseekerPooldetailColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerPooldetails.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Proposedtreatmentareas: modAs[Q, fieldseekerProposedtreatmentareaColumns]{
			c: FieldseekerProposedtreatmentareas.Columns,
			f: func(to fieldseekerProposedtreatmentareaColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerProposedtreatmentareas.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Qamosquitoinspections: modAs[Q, fieldseekerQamosquitoinspectionColumns]{
			c: FieldseekerQamosquitoinspections.Columns,
			f: func(to fieldseekerQamosquitoinspectionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerQamosquitoinspections.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Rodentlocations: modAs[Q, fieldseekerRodentlocationColumns]{
			c: FieldseekerRodentlocations.Columns,
			f: func(to fieldseekerRodentlocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerRodentlocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Samplecollections: modAs[Q, fieldseekerSamplecollectionColumns]{
			c: FieldseekerSamplecollections.Columns,
			f: func(to fieldseekerSamplecollectionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerSamplecollections.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Samplelocations: modAs[Q, fieldseekerSamplelocationColumns]{
			c: FieldseekerSamplelocations.Columns,
			f: func(to fieldseekerSamplelocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerSamplelocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Servicerequests: modAs[Q, fieldseekerServicerequestColumns]{
			c: FieldseekerServicerequests.Columns,
			f: func(to fieldseekerServicerequestColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerServicerequests.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Speciesabundances: modAs[Q, fieldseekerSpeciesabundanceColumns]{
			c: FieldseekerSpeciesabundances.Columns,
			f: func(to fieldseekerSpeciesabundanceColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerSpeciesabundances.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Stormdrains: modAs[Q, fieldseekerStormdrainColumns]{
			c: FieldseekerStormdrains.Columns,
			f: func(to fieldseekerStormdrainColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerStormdrains.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Timecards: modAs[Q, fieldseekerTimecardColumns]{
			c: FieldseekerTimecards.Columns,
			f: func(to fieldseekerTimecardColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerTimecards.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Trapdata: modAs[Q, fieldseekerTrapdatumColumns]{
			c: FieldseekerTrapdata.Columns,
			f: func(to fieldseekerTrapdatumColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerTrapdata.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Traplocations: modAs[Q, fieldseekerTraplocationColumns]{
			c: FieldseekerTraplocations.Columns,
			f: func(to fieldseekerTraplocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerTraplocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Treatments: modAs[Q, fieldseekerTreatmentColumns]{
			c: FieldseekerTreatments.Columns,
			f: func(to fieldseekerTreatmentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerTreatments.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Treatmentareas: modAs[Q, fieldseekerTreatmentareaColumns]{
			c: FieldseekerTreatmentareas.Columns,
			f: func(to fieldseekerTreatmentareaColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerTreatmentareas.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Zones: modAs[Q, fieldseekerZoneColumns]{
			c: FieldseekerZones.Columns,
			f: func(to fieldseekerZoneColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerZones.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Zones2s: modAs[Q, fieldseekerZones2Columns]{
			c: FieldseekerZones2s.Columns,
			f: func(to fieldseekerZones2Columns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerZones2s.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FieldseekerSyncs: modAs[Q, fieldseekerSyncColumns]{
			c: FieldseekerSyncs.Columns,
			f: func(to fieldseekerSyncColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FieldseekerSyncs.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Files: modAs[Q, fileuploadFileColumns]{
			c: FileuploadFiles.Columns,
			f: func(to fileuploadFileColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FileuploadFiles.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		H3Aggregations: modAs[Q, h3AggregationColumns]{
			c: H3Aggregations.Columns,
			f: func(to h3AggregationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, H3Aggregations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		NoteAudios: modAs[Q, noteAudioColumns]{
			c: NoteAudios.Columns,
			f: func(to noteAudioColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, NoteAudios.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		NoteImages: modAs[Q, noteImageColumns]{
			c: NoteImages.Columns,
			f: func(to noteImageColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, NoteImages.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		ImportDistrictGidDistrict: modAs[Q, importDistrictColumns]{
			c: ImportDistricts.Columns,
			f: func(to importDistrictColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ImportDistricts.Name().As(to.Alias())).On(
						to.Gid.EQ(cols.ImportDistrictGid),
					))
				}

				return mods
			},
		},
		Pools: modAs[Q, poolColumns]{
			c: Pools.Columns,
			f: func(to poolColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Pools.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Nuisances: modAs[Q, publicreportNuisanceColumns]{
			c: PublicreportNuisances.Columns,
			f: func(to publicreportNuisanceColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, PublicreportNuisances.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		PublicreportPool: modAs[Q, publicreportPoolColumns]{
			c: PublicreportPools.Columns,
			f: func(to publicreportPoolColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, PublicreportPools.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Quicks: modAs[Q, publicreportQuickColumns]{
			c: PublicreportQuicks.Columns,
			f: func(to publicreportQuickColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, PublicreportQuicks.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		User: modAs[Q, userColumns]{
			c: Users.Columns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
	}
}
