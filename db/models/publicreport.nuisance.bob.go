// Code generated by BobGen psql v0.42.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/Gleipnir-Technology/bob"
	"github.com/Gleipnir-Technology/bob/dialect/psql"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dialect"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dm"
	"github.com/Gleipnir-Technology/bob/dialect/psql/sm"
	"github.com/Gleipnir-Technology/bob/dialect/psql/um"
	"github.com/Gleipnir-Technology/bob/expr"
	"github.com/Gleipnir-Technology/bob/mods"
	"github.com/Gleipnir-Technology/bob/orm"
	"github.com/Gleipnir-Technology/bob/types/pgtypes"
	enums "github.com/Gleipnir-Technology/nidus-sync/db/enums"
	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/scan"
)

// PublicreportNuisance is an object representing the database table.
type PublicreportNuisance struct {
	ID                  int32                                  `db:"id,pk" `
	AdditionalInfo      string                                 `db:"additional_info" `
	Created             time.Time                              `db:"created" `
	Duration            enums.PublicreportNuisancedurationtype `db:"duration" `
	SourceContainer     bool                                   `db:"source_container" `
	SourceDescription   string                                 `db:"source_description" `
	SourceStagnant      bool                                   `db:"source_stagnant" `
	PublicID            string                                 `db:"public_id" `
	ReporterEmail       null.Val[string]                       `db:"reporter_email" `
	ReporterName        null.Val[string]                       `db:"reporter_name" `
	ReporterPhone       null.Val[string]                       `db:"reporter_phone" `
	Address             string                                 `db:"address" `
	Location            null.Val[string]                       `db:"location" `
	Status              enums.PublicreportReportstatustype     `db:"status" `
	OrganizationID      null.Val[int32]                        `db:"organization_id" `
	SourceGutter        bool                                   `db:"source_gutter" `
	H3cell              null.Val[string]                       `db:"h3cell" `
	AddressCountry      string                                 `db:"address_country" `
	AddressPlace        string                                 `db:"address_place" `
	AddressPostcode     string                                 `db:"address_postcode" `
	AddressRegion       string                                 `db:"address_region" `
	AddressStreet       string                                 `db:"address_street" `
	IsLocationBackyard  bool                                   `db:"is_location_backyard" `
	IsLocationFrontyard bool                                   `db:"is_location_frontyard" `
	IsLocationGarden    bool                                   `db:"is_location_garden" `
	IsLocationOther     bool                                   `db:"is_location_other" `
	IsLocationPool      bool                                   `db:"is_location_pool" `
	MapZoom             float32                                `db:"map_zoom" `
	TodEarly            bool                                   `db:"tod_early" `
	TodDay              bool                                   `db:"tod_day" `
	TodEvening          bool                                   `db:"tod_evening" `
	TodNight            bool                                   `db:"tod_night" `
	LatlngAccuracyType  enums.PublicreportAccuracytype         `db:"latlng_accuracy_type" `
	LatlngAccuracyValue float32                                `db:"latlng_accuracy_value" `

	R publicreportNuisanceR `db:"-" `

	C publicreportNuisanceC `db:"-" `
}

// PublicreportNuisanceSlice is an alias for a slice of pointers to PublicreportNuisance.
// This should almost always be used instead of []*PublicreportNuisance.
type PublicreportNuisanceSlice []*PublicreportNuisance

// PublicreportNuisances contains methods to work with the nuisance table
var PublicreportNuisances = psql.NewTablex[*PublicreportNuisance, PublicreportNuisanceSlice, *PublicreportNuisanceSetter]("publicreport", "nuisance", buildPublicreportNuisanceColumns("publicreport.nuisance"))

// PublicreportNuisancesQuery is a query on the nuisance table
type PublicreportNuisancesQuery = *psql.ViewQuery[*PublicreportNuisance, PublicreportNuisanceSlice]

// publicreportNuisanceR is where relationships are stored.
type publicreportNuisanceR struct {
	Organization *Organization          // publicreport.nuisance.nuisance_organization_id_fkey
	Images       PublicreportImageSlice // publicreport.nuisance_image.nuisance_image_image_id_fkeypublicreport.nuisance_image.nuisance_image_nuisance_id_fkey
}

func buildPublicreportNuisanceColumns(alias string) publicreportNuisanceColumns {
	return publicreportNuisanceColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "additional_info", "created", "duration", "source_container", "source_description", "source_stagnant", "public_id", "reporter_email", "reporter_name", "reporter_phone", "address", "location", "status", "organization_id", "source_gutter", "h3cell", "address_country", "address_place", "address_postcode", "address_region", "address_street", "is_location_backyard", "is_location_frontyard", "is_location_garden", "is_location_other", "is_location_pool", "map_zoom", "tod_early", "tod_day", "tod_evening", "tod_night", "latlng_accuracy_type", "latlng_accuracy_value",
		).WithParent("publicreport.nuisance"),
		tableAlias:          alias,
		ID:                  psql.Quote(alias, "id"),
		AdditionalInfo:      psql.Quote(alias, "additional_info"),
		Created:             psql.Quote(alias, "created"),
		Duration:            psql.Quote(alias, "duration"),
		SourceContainer:     psql.Quote(alias, "source_container"),
		SourceDescription:   psql.Quote(alias, "source_description"),
		SourceStagnant:      psql.Quote(alias, "source_stagnant"),
		PublicID:            psql.Quote(alias, "public_id"),
		ReporterEmail:       psql.Quote(alias, "reporter_email"),
		ReporterName:        psql.Quote(alias, "reporter_name"),
		ReporterPhone:       psql.Quote(alias, "reporter_phone"),
		Address:             psql.Quote(alias, "address"),
		Location:            psql.Quote(alias, "location"),
		Status:              psql.Quote(alias, "status"),
		OrganizationID:      psql.Quote(alias, "organization_id"),
		SourceGutter:        psql.Quote(alias, "source_gutter"),
		H3cell:              psql.Quote(alias, "h3cell"),
		AddressCountry:      psql.Quote(alias, "address_country"),
		AddressPlace:        psql.Quote(alias, "address_place"),
		AddressPostcode:     psql.Quote(alias, "address_postcode"),
		AddressRegion:       psql.Quote(alias, "address_region"),
		AddressStreet:       psql.Quote(alias, "address_street"),
		IsLocationBackyard:  psql.Quote(alias, "is_location_backyard"),
		IsLocationFrontyard: psql.Quote(alias, "is_location_frontyard"),
		IsLocationGarden:    psql.Quote(alias, "is_location_garden"),
		IsLocationOther:     psql.Quote(alias, "is_location_other"),
		IsLocationPool:      psql.Quote(alias, "is_location_pool"),
		MapZoom:             psql.Quote(alias, "map_zoom"),
		TodEarly:            psql.Quote(alias, "tod_early"),
		TodDay:              psql.Quote(alias, "tod_day"),
		TodEvening:          psql.Quote(alias, "tod_evening"),
		TodNight:            psql.Quote(alias, "tod_night"),
		LatlngAccuracyType:  psql.Quote(alias, "latlng_accuracy_type"),
		LatlngAccuracyValue: psql.Quote(alias, "latlng_accuracy_value"),
	}
}

type publicreportNuisanceColumns struct {
	expr.ColumnsExpr
	tableAlias          string
	ID                  psql.Expression
	AdditionalInfo      psql.Expression
	Created             psql.Expression
	Duration            psql.Expression
	SourceContainer     psql.Expression
	SourceDescription   psql.Expression
	SourceStagnant      psql.Expression
	PublicID            psql.Expression
	ReporterEmail       psql.Expression
	ReporterName        psql.Expression
	ReporterPhone       psql.Expression
	Address             psql.Expression
	Location            psql.Expression
	Status              psql.Expression
	OrganizationID      psql.Expression
	SourceGutter        psql.Expression
	H3cell              psql.Expression
	AddressCountry      psql.Expression
	AddressPlace        psql.Expression
	AddressPostcode     psql.Expression
	AddressRegion       psql.Expression
	AddressStreet       psql.Expression
	IsLocationBackyard  psql.Expression
	IsLocationFrontyard psql.Expression
	IsLocationGarden    psql.Expression
	IsLocationOther     psql.Expression
	IsLocationPool      psql.Expression
	MapZoom             psql.Expression
	TodEarly            psql.Expression
	TodDay              psql.Expression
	TodEvening          psql.Expression
	TodNight            psql.Expression
	LatlngAccuracyType  psql.Expression
	LatlngAccuracyValue psql.Expression
}

func (c publicreportNuisanceColumns) Alias() string {
	return c.tableAlias
}

func (publicreportNuisanceColumns) AliasedAs(alias string) publicreportNuisanceColumns {
	return buildPublicreportNuisanceColumns(alias)
}

// PublicreportNuisanceSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type PublicreportNuisanceSetter struct {
	ID                  omit.Val[int32]                                  `db:"id,pk" `
	AdditionalInfo      omit.Val[string]                                 `db:"additional_info" `
	Created             omit.Val[time.Time]                              `db:"created" `
	Duration            omit.Val[enums.PublicreportNuisancedurationtype] `db:"duration" `
	SourceContainer     omit.Val[bool]                                   `db:"source_container" `
	SourceDescription   omit.Val[string]                                 `db:"source_description" `
	SourceStagnant      omit.Val[bool]                                   `db:"source_stagnant" `
	PublicID            omit.Val[string]                                 `db:"public_id" `
	ReporterEmail       omitnull.Val[string]                             `db:"reporter_email" `
	ReporterName        omitnull.Val[string]                             `db:"reporter_name" `
	ReporterPhone       omitnull.Val[string]                             `db:"reporter_phone" `
	Address             omit.Val[string]                                 `db:"address" `
	Location            omitnull.Val[string]                             `db:"location" `
	Status              omit.Val[enums.PublicreportReportstatustype]     `db:"status" `
	OrganizationID      omitnull.Val[int32]                              `db:"organization_id" `
	SourceGutter        omit.Val[bool]                                   `db:"source_gutter" `
	H3cell              omitnull.Val[string]                             `db:"h3cell" `
	AddressCountry      omit.Val[string]                                 `db:"address_country" `
	AddressPlace        omit.Val[string]                                 `db:"address_place" `
	AddressPostcode     omit.Val[string]                                 `db:"address_postcode" `
	AddressRegion       omit.Val[string]                                 `db:"address_region" `
	AddressStreet       omit.Val[string]                                 `db:"address_street" `
	IsLocationBackyard  omit.Val[bool]                                   `db:"is_location_backyard" `
	IsLocationFrontyard omit.Val[bool]                                   `db:"is_location_frontyard" `
	IsLocationGarden    omit.Val[bool]                                   `db:"is_location_garden" `
	IsLocationOther     omit.Val[bool]                                   `db:"is_location_other" `
	IsLocationPool      omit.Val[bool]                                   `db:"is_location_pool" `
	MapZoom             omit.Val[float32]                                `db:"map_zoom" `
	TodEarly            omit.Val[bool]                                   `db:"tod_early" `
	TodDay              omit.Val[bool]                                   `db:"tod_day" `
	TodEvening          omit.Val[bool]                                   `db:"tod_evening" `
	TodNight            omit.Val[bool]                                   `db:"tod_night" `
	LatlngAccuracyType  omit.Val[enums.PublicreportAccuracytype]         `db:"latlng_accuracy_type" `
	LatlngAccuracyValue omit.Val[float32]                                `db:"latlng_accuracy_value" `
}

func (s PublicreportNuisanceSetter) SetColumns() []string {
	vals := make([]string, 0, 34)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if s.AdditionalInfo.IsValue() {
		vals = append(vals, "additional_info")
	}
	if s.Created.IsValue() {
		vals = append(vals, "created")
	}
	if s.Duration.IsValue() {
		vals = append(vals, "duration")
	}
	if s.SourceContainer.IsValue() {
		vals = append(vals, "source_container")
	}
	if s.SourceDescription.IsValue() {
		vals = append(vals, "source_description")
	}
	if s.SourceStagnant.IsValue() {
		vals = append(vals, "source_stagnant")
	}
	if s.PublicID.IsValue() {
		vals = append(vals, "public_id")
	}
	if !s.ReporterEmail.IsUnset() {
		vals = append(vals, "reporter_email")
	}
	if !s.ReporterName.IsUnset() {
		vals = append(vals, "reporter_name")
	}
	if !s.ReporterPhone.IsUnset() {
		vals = append(vals, "reporter_phone")
	}
	if s.Address.IsValue() {
		vals = append(vals, "address")
	}
	if !s.Location.IsUnset() {
		vals = append(vals, "location")
	}
	if s.Status.IsValue() {
		vals = append(vals, "status")
	}
	if !s.OrganizationID.IsUnset() {
		vals = append(vals, "organization_id")
	}
	if s.SourceGutter.IsValue() {
		vals = append(vals, "source_gutter")
	}
	if !s.H3cell.IsUnset() {
		vals = append(vals, "h3cell")
	}
	if s.AddressCountry.IsValue() {
		vals = append(vals, "address_country")
	}
	if s.AddressPlace.IsValue() {
		vals = append(vals, "address_place")
	}
	if s.AddressPostcode.IsValue() {
		vals = append(vals, "address_postcode")
	}
	if s.AddressRegion.IsValue() {
		vals = append(vals, "address_region")
	}
	if s.AddressStreet.IsValue() {
		vals = append(vals, "address_street")
	}
	if s.IsLocationBackyard.IsValue() {
		vals = append(vals, "is_location_backyard")
	}
	if s.IsLocationFrontyard.IsValue() {
		vals = append(vals, "is_location_frontyard")
	}
	if s.IsLocationGarden.IsValue() {
		vals = append(vals, "is_location_garden")
	}
	if s.IsLocationOther.IsValue() {
		vals = append(vals, "is_location_other")
	}
	if s.IsLocationPool.IsValue() {
		vals = append(vals, "is_location_pool")
	}
	if s.MapZoom.IsValue() {
		vals = append(vals, "map_zoom")
	}
	if s.TodEarly.IsValue() {
		vals = append(vals, "tod_early")
	}
	if s.TodDay.IsValue() {
		vals = append(vals, "tod_day")
	}
	if s.TodEvening.IsValue() {
		vals = append(vals, "tod_evening")
	}
	if s.TodNight.IsValue() {
		vals = append(vals, "tod_night")
	}
	if s.LatlngAccuracyType.IsValue() {
		vals = append(vals, "latlng_accuracy_type")
	}
	if s.LatlngAccuracyValue.IsValue() {
		vals = append(vals, "latlng_accuracy_value")
	}
	return vals
}

func (s PublicreportNuisanceSetter) Overwrite(t *PublicreportNuisance) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if s.AdditionalInfo.IsValue() {
		t.AdditionalInfo = s.AdditionalInfo.MustGet()
	}
	if s.Created.IsValue() {
		t.Created = s.Created.MustGet()
	}
	if s.Duration.IsValue() {
		t.Duration = s.Duration.MustGet()
	}
	if s.SourceContainer.IsValue() {
		t.SourceContainer = s.SourceContainer.MustGet()
	}
	if s.SourceDescription.IsValue() {
		t.SourceDescription = s.SourceDescription.MustGet()
	}
	if s.SourceStagnant.IsValue() {
		t.SourceStagnant = s.SourceStagnant.MustGet()
	}
	if s.PublicID.IsValue() {
		t.PublicID = s.PublicID.MustGet()
	}
	if !s.ReporterEmail.IsUnset() {
		t.ReporterEmail = s.ReporterEmail.MustGetNull()
	}
	if !s.ReporterName.IsUnset() {
		t.ReporterName = s.ReporterName.MustGetNull()
	}
	if !s.ReporterPhone.IsUnset() {
		t.ReporterPhone = s.ReporterPhone.MustGetNull()
	}
	if s.Address.IsValue() {
		t.Address = s.Address.MustGet()
	}
	if !s.Location.IsUnset() {
		t.Location = s.Location.MustGetNull()
	}
	if s.Status.IsValue() {
		t.Status = s.Status.MustGet()
	}
	if !s.OrganizationID.IsUnset() {
		t.OrganizationID = s.OrganizationID.MustGetNull()
	}
	if s.SourceGutter.IsValue() {
		t.SourceGutter = s.SourceGutter.MustGet()
	}
	if !s.H3cell.IsUnset() {
		t.H3cell = s.H3cell.MustGetNull()
	}
	if s.AddressCountry.IsValue() {
		t.AddressCountry = s.AddressCountry.MustGet()
	}
	if s.AddressPlace.IsValue() {
		t.AddressPlace = s.AddressPlace.MustGet()
	}
	if s.AddressPostcode.IsValue() {
		t.AddressPostcode = s.AddressPostcode.MustGet()
	}
	if s.AddressRegion.IsValue() {
		t.AddressRegion = s.AddressRegion.MustGet()
	}
	if s.AddressStreet.IsValue() {
		t.AddressStreet = s.AddressStreet.MustGet()
	}
	if s.IsLocationBackyard.IsValue() {
		t.IsLocationBackyard = s.IsLocationBackyard.MustGet()
	}
	if s.IsLocationFrontyard.IsValue() {
		t.IsLocationFrontyard = s.IsLocationFrontyard.MustGet()
	}
	if s.IsLocationGarden.IsValue() {
		t.IsLocationGarden = s.IsLocationGarden.MustGet()
	}
	if s.IsLocationOther.IsValue() {
		t.IsLocationOther = s.IsLocationOther.MustGet()
	}
	if s.IsLocationPool.IsValue() {
		t.IsLocationPool = s.IsLocationPool.MustGet()
	}
	if s.MapZoom.IsValue() {
		t.MapZoom = s.MapZoom.MustGet()
	}
	if s.TodEarly.IsValue() {
		t.TodEarly = s.TodEarly.MustGet()
	}
	if s.TodDay.IsValue() {
		t.TodDay = s.TodDay.MustGet()
	}
	if s.TodEvening.IsValue() {
		t.TodEvening = s.TodEvening.MustGet()
	}
	if s.TodNight.IsValue() {
		t.TodNight = s.TodNight.MustGet()
	}
	if s.LatlngAccuracyType.IsValue() {
		t.LatlngAccuracyType = s.LatlngAccuracyType.MustGet()
	}
	if s.LatlngAccuracyValue.IsValue() {
		t.LatlngAccuracyValue = s.LatlngAccuracyValue.MustGet()
	}
}

func (s *PublicreportNuisanceSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return PublicreportNuisances.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 34)
		if s.ID.IsValue() {
			vals[0] = psql.Arg(s.ID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.AdditionalInfo.IsValue() {
			vals[1] = psql.Arg(s.AdditionalInfo.MustGet())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.Created.IsValue() {
			vals[2] = psql.Arg(s.Created.MustGet())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.Duration.IsValue() {
			vals[3] = psql.Arg(s.Duration.MustGet())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.SourceContainer.IsValue() {
			vals[4] = psql.Arg(s.SourceContainer.MustGet())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.SourceDescription.IsValue() {
			vals[5] = psql.Arg(s.SourceDescription.MustGet())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.SourceStagnant.IsValue() {
			vals[6] = psql.Arg(s.SourceStagnant.MustGet())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.PublicID.IsValue() {
			vals[7] = psql.Arg(s.PublicID.MustGet())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.ReporterEmail.IsUnset() {
			vals[8] = psql.Arg(s.ReporterEmail.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.ReporterName.IsUnset() {
			vals[9] = psql.Arg(s.ReporterName.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.ReporterPhone.IsUnset() {
			vals[10] = psql.Arg(s.ReporterPhone.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.Address.IsValue() {
			vals[11] = psql.Arg(s.Address.MustGet())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.Location.IsUnset() {
			vals[12] = psql.Arg(s.Location.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.Status.IsValue() {
			vals[13] = psql.Arg(s.Status.MustGet())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.OrganizationID.IsUnset() {
			vals[14] = psql.Arg(s.OrganizationID.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.SourceGutter.IsValue() {
			vals[15] = psql.Arg(s.SourceGutter.MustGet())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.H3cell.IsUnset() {
			vals[16] = psql.Arg(s.H3cell.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if s.AddressCountry.IsValue() {
			vals[17] = psql.Arg(s.AddressCountry.MustGet())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if s.AddressPlace.IsValue() {
			vals[18] = psql.Arg(s.AddressPlace.MustGet())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if s.AddressPostcode.IsValue() {
			vals[19] = psql.Arg(s.AddressPostcode.MustGet())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if s.AddressRegion.IsValue() {
			vals[20] = psql.Arg(s.AddressRegion.MustGet())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if s.AddressStreet.IsValue() {
			vals[21] = psql.Arg(s.AddressStreet.MustGet())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if s.IsLocationBackyard.IsValue() {
			vals[22] = psql.Arg(s.IsLocationBackyard.MustGet())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if s.IsLocationFrontyard.IsValue() {
			vals[23] = psql.Arg(s.IsLocationFrontyard.MustGet())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if s.IsLocationGarden.IsValue() {
			vals[24] = psql.Arg(s.IsLocationGarden.MustGet())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if s.IsLocationOther.IsValue() {
			vals[25] = psql.Arg(s.IsLocationOther.MustGet())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if s.IsLocationPool.IsValue() {
			vals[26] = psql.Arg(s.IsLocationPool.MustGet())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if s.MapZoom.IsValue() {
			vals[27] = psql.Arg(s.MapZoom.MustGet())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if s.TodEarly.IsValue() {
			vals[28] = psql.Arg(s.TodEarly.MustGet())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if s.TodDay.IsValue() {
			vals[29] = psql.Arg(s.TodDay.MustGet())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if s.TodEvening.IsValue() {
			vals[30] = psql.Arg(s.TodEvening.MustGet())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		if s.TodNight.IsValue() {
			vals[31] = psql.Arg(s.TodNight.MustGet())
		} else {
			vals[31] = psql.Raw("DEFAULT")
		}

		if s.LatlngAccuracyType.IsValue() {
			vals[32] = psql.Arg(s.LatlngAccuracyType.MustGet())
		} else {
			vals[32] = psql.Raw("DEFAULT")
		}

		if s.LatlngAccuracyValue.IsValue() {
			vals[33] = psql.Arg(s.LatlngAccuracyValue.MustGet())
		} else {
			vals[33] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s PublicreportNuisanceSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s PublicreportNuisanceSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 34)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if s.AdditionalInfo.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "additional_info")...),
			psql.Arg(s.AdditionalInfo),
		}})
	}

	if s.Created.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created")...),
			psql.Arg(s.Created),
		}})
	}

	if s.Duration.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "duration")...),
			psql.Arg(s.Duration),
		}})
	}

	if s.SourceContainer.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "source_container")...),
			psql.Arg(s.SourceContainer),
		}})
	}

	if s.SourceDescription.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "source_description")...),
			psql.Arg(s.SourceDescription),
		}})
	}

	if s.SourceStagnant.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "source_stagnant")...),
			psql.Arg(s.SourceStagnant),
		}})
	}

	if s.PublicID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "public_id")...),
			psql.Arg(s.PublicID),
		}})
	}

	if !s.ReporterEmail.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_email")...),
			psql.Arg(s.ReporterEmail),
		}})
	}

	if !s.ReporterName.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_name")...),
			psql.Arg(s.ReporterName),
		}})
	}

	if !s.ReporterPhone.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_phone")...),
			psql.Arg(s.ReporterPhone),
		}})
	}

	if s.Address.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address")...),
			psql.Arg(s.Address),
		}})
	}

	if !s.Location.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "location")...),
			psql.Arg(s.Location),
		}})
	}

	if s.Status.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "status")...),
			psql.Arg(s.Status),
		}})
	}

	if !s.OrganizationID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "organization_id")...),
			psql.Arg(s.OrganizationID),
		}})
	}

	if s.SourceGutter.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "source_gutter")...),
			psql.Arg(s.SourceGutter),
		}})
	}

	if !s.H3cell.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "h3cell")...),
			psql.Arg(s.H3cell),
		}})
	}

	if s.AddressCountry.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_country")...),
			psql.Arg(s.AddressCountry),
		}})
	}

	if s.AddressPlace.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_place")...),
			psql.Arg(s.AddressPlace),
		}})
	}

	if s.AddressPostcode.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_postcode")...),
			psql.Arg(s.AddressPostcode),
		}})
	}

	if s.AddressRegion.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_region")...),
			psql.Arg(s.AddressRegion),
		}})
	}

	if s.AddressStreet.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_street")...),
			psql.Arg(s.AddressStreet),
		}})
	}

	if s.IsLocationBackyard.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_location_backyard")...),
			psql.Arg(s.IsLocationBackyard),
		}})
	}

	if s.IsLocationFrontyard.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_location_frontyard")...),
			psql.Arg(s.IsLocationFrontyard),
		}})
	}

	if s.IsLocationGarden.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_location_garden")...),
			psql.Arg(s.IsLocationGarden),
		}})
	}

	if s.IsLocationOther.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_location_other")...),
			psql.Arg(s.IsLocationOther),
		}})
	}

	if s.IsLocationPool.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_location_pool")...),
			psql.Arg(s.IsLocationPool),
		}})
	}

	if s.MapZoom.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "map_zoom")...),
			psql.Arg(s.MapZoom),
		}})
	}

	if s.TodEarly.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "tod_early")...),
			psql.Arg(s.TodEarly),
		}})
	}

	if s.TodDay.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "tod_day")...),
			psql.Arg(s.TodDay),
		}})
	}

	if s.TodEvening.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "tod_evening")...),
			psql.Arg(s.TodEvening),
		}})
	}

	if s.TodNight.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "tod_night")...),
			psql.Arg(s.TodNight),
		}})
	}

	if s.LatlngAccuracyType.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "latlng_accuracy_type")...),
			psql.Arg(s.LatlngAccuracyType),
		}})
	}

	if s.LatlngAccuracyValue.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "latlng_accuracy_value")...),
			psql.Arg(s.LatlngAccuracyValue),
		}})
	}

	return exprs
}

// FindPublicreportNuisance retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindPublicreportNuisance(ctx context.Context, exec bob.Executor, IDPK int32, cols ...string) (*PublicreportNuisance, error) {
	if len(cols) == 0 {
		return PublicreportNuisances.Query(
			sm.Where(PublicreportNuisances.Columns.ID.EQ(psql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return PublicreportNuisances.Query(
		sm.Where(PublicreportNuisances.Columns.ID.EQ(psql.Arg(IDPK))),
		sm.Columns(PublicreportNuisances.Columns.Only(cols...)),
	).One(ctx, exec)
}

// PublicreportNuisanceExists checks the presence of a single record by primary key
func PublicreportNuisanceExists(ctx context.Context, exec bob.Executor, IDPK int32) (bool, error) {
	return PublicreportNuisances.Query(
		sm.Where(PublicreportNuisances.Columns.ID.EQ(psql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after PublicreportNuisance is retrieved from the database
func (o *PublicreportNuisance) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = PublicreportNuisances.AfterSelectHooks.RunHooks(ctx, exec, PublicreportNuisanceSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = PublicreportNuisances.AfterInsertHooks.RunHooks(ctx, exec, PublicreportNuisanceSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = PublicreportNuisances.AfterUpdateHooks.RunHooks(ctx, exec, PublicreportNuisanceSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = PublicreportNuisances.AfterDeleteHooks.RunHooks(ctx, exec, PublicreportNuisanceSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the PublicreportNuisance
func (o *PublicreportNuisance) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *PublicreportNuisance) pkEQ() dialect.Expression {
	return psql.Quote("publicreport.nuisance", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the PublicreportNuisance
func (o *PublicreportNuisance) Update(ctx context.Context, exec bob.Executor, s *PublicreportNuisanceSetter) error {
	v, err := PublicreportNuisances.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single PublicreportNuisance record with an executor
func (o *PublicreportNuisance) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := PublicreportNuisances.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the PublicreportNuisance using the executor
func (o *PublicreportNuisance) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := PublicreportNuisances.Query(
		sm.Where(PublicreportNuisances.Columns.ID.EQ(psql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after PublicreportNuisanceSlice is retrieved from the database
func (o PublicreportNuisanceSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = PublicreportNuisances.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = PublicreportNuisances.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = PublicreportNuisances.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = PublicreportNuisances.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o PublicreportNuisanceSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("publicreport.nuisance", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o PublicreportNuisanceSlice) copyMatchingRows(from ...*PublicreportNuisance) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o PublicreportNuisanceSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return PublicreportNuisances.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *PublicreportNuisance:
				o.copyMatchingRows(retrieved)
			case []*PublicreportNuisance:
				o.copyMatchingRows(retrieved...)
			case PublicreportNuisanceSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a PublicreportNuisance or a slice of PublicreportNuisance
				// then run the AfterUpdateHooks on the slice
				_, err = PublicreportNuisances.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o PublicreportNuisanceSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return PublicreportNuisances.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *PublicreportNuisance:
				o.copyMatchingRows(retrieved)
			case []*PublicreportNuisance:
				o.copyMatchingRows(retrieved...)
			case PublicreportNuisanceSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a PublicreportNuisance or a slice of PublicreportNuisance
				// then run the AfterDeleteHooks on the slice
				_, err = PublicreportNuisances.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o PublicreportNuisanceSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals PublicreportNuisanceSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := PublicreportNuisances.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o PublicreportNuisanceSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := PublicreportNuisances.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o PublicreportNuisanceSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := PublicreportNuisances.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// Organization starts a query for related objects on organization
func (o *PublicreportNuisance) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	return Organizations.Query(append(mods,
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.OrganizationID))),
	)...)
}

func (os PublicreportNuisanceSlice) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	pkOrganizationID := make(pgtypes.Array[null.Val[int32]], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkOrganizationID = append(pkOrganizationID, o.OrganizationID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkOrganizationID), "integer[]")),
	))

	return Organizations.Query(append(mods,
		sm.Where(psql.Group(Organizations.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// Images starts a query for related objects on publicreport.image
func (o *PublicreportNuisance) Images(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportImagesQuery {
	return PublicreportImages.Query(append(mods,
		sm.InnerJoin(PublicreportNuisanceImages.NameAs()).On(
			PublicreportImages.Columns.ID.EQ(PublicreportNuisanceImages.Columns.ImageID)),
		sm.Where(PublicreportNuisanceImages.Columns.NuisanceID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os PublicreportNuisanceSlice) Images(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportImagesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return PublicreportImages.Query(append(mods,
		sm.InnerJoin(PublicreportNuisanceImages.NameAs()).On(
			PublicreportImages.Columns.ID.EQ(PublicreportNuisanceImages.Columns.ImageID),
		),
		sm.Where(psql.Group(PublicreportNuisanceImages.Columns.NuisanceID).OP("IN", PKArgExpr)),
	)...)
}

func attachPublicreportNuisanceOrganization0(ctx context.Context, exec bob.Executor, count int, publicreportNuisance0 *PublicreportNuisance, organization1 *Organization) (*PublicreportNuisance, error) {
	setter := &PublicreportNuisanceSetter{
		OrganizationID: omitnull.From(organization1.ID),
	}

	err := publicreportNuisance0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachPublicreportNuisanceOrganization0: %w", err)
	}

	return publicreportNuisance0, nil
}

func (publicreportNuisance0 *PublicreportNuisance) InsertOrganization(ctx context.Context, exec bob.Executor, related *OrganizationSetter) error {
	var err error

	organization1, err := Organizations.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachPublicreportNuisanceOrganization0(ctx, exec, 1, publicreportNuisance0, organization1)
	if err != nil {
		return err
	}

	publicreportNuisance0.R.Organization = organization1

	organization1.R.Nuisances = append(organization1.R.Nuisances, publicreportNuisance0)

	return nil
}

func (publicreportNuisance0 *PublicreportNuisance) AttachOrganization(ctx context.Context, exec bob.Executor, organization1 *Organization) error {
	var err error

	_, err = attachPublicreportNuisanceOrganization0(ctx, exec, 1, publicreportNuisance0, organization1)
	if err != nil {
		return err
	}

	publicreportNuisance0.R.Organization = organization1

	organization1.R.Nuisances = append(organization1.R.Nuisances, publicreportNuisance0)

	return nil
}

func attachPublicreportNuisanceImages0(ctx context.Context, exec bob.Executor, count int, publicreportNuisance0 *PublicreportNuisance, publicreportImages2 PublicreportImageSlice) (PublicreportNuisanceImageSlice, error) {
	setters := make([]*PublicreportNuisanceImageSetter, count)
	for i := range count {
		setters[i] = &PublicreportNuisanceImageSetter{
			NuisanceID: omit.From(publicreportNuisance0.ID),
			ImageID:    omit.From(publicreportImages2[i].ID),
		}
	}

	publicreportNuisanceImages1, err := PublicreportNuisanceImages.Insert(bob.ToMods(setters...)).All(ctx, exec)
	if err != nil {
		return nil, fmt.Errorf("attachPublicreportNuisanceImages0: %w", err)
	}

	return publicreportNuisanceImages1, nil
}

func (publicreportNuisance0 *PublicreportNuisance) InsertImages(ctx context.Context, exec bob.Executor, related ...*PublicreportImageSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	inserted, err := PublicreportImages.Insert(bob.ToMods(related...)).All(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	publicreportImages2 := PublicreportImageSlice(inserted)

	_, err = attachPublicreportNuisanceImages0(ctx, exec, len(related), publicreportNuisance0, publicreportImages2)
	if err != nil {
		return err
	}

	publicreportNuisance0.R.Images = append(publicreportNuisance0.R.Images, publicreportImages2...)

	for _, rel := range publicreportImages2 {
		rel.R.Nuisances = append(rel.R.Nuisances, publicreportNuisance0)
	}
	return nil
}

func (publicreportNuisance0 *PublicreportNuisance) AttachImages(ctx context.Context, exec bob.Executor, related ...*PublicreportImage) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	publicreportImages2 := PublicreportImageSlice(related)

	_, err = attachPublicreportNuisanceImages0(ctx, exec, len(related), publicreportNuisance0, publicreportImages2)
	if err != nil {
		return err
	}

	publicreportNuisance0.R.Images = append(publicreportNuisance0.R.Images, publicreportImages2...)

	for _, rel := range related {
		rel.R.Nuisances = append(rel.R.Nuisances, publicreportNuisance0)
	}

	return nil
}

type publicreportNuisanceWhere[Q psql.Filterable] struct {
	ID                  psql.WhereMod[Q, int32]
	AdditionalInfo      psql.WhereMod[Q, string]
	Created             psql.WhereMod[Q, time.Time]
	Duration            psql.WhereMod[Q, enums.PublicreportNuisancedurationtype]
	SourceContainer     psql.WhereMod[Q, bool]
	SourceDescription   psql.WhereMod[Q, string]
	SourceStagnant      psql.WhereMod[Q, bool]
	PublicID            psql.WhereMod[Q, string]
	ReporterEmail       psql.WhereNullMod[Q, string]
	ReporterName        psql.WhereNullMod[Q, string]
	ReporterPhone       psql.WhereNullMod[Q, string]
	Address             psql.WhereMod[Q, string]
	Location            psql.WhereNullMod[Q, string]
	Status              psql.WhereMod[Q, enums.PublicreportReportstatustype]
	OrganizationID      psql.WhereNullMod[Q, int32]
	SourceGutter        psql.WhereMod[Q, bool]
	H3cell              psql.WhereNullMod[Q, string]
	AddressCountry      psql.WhereMod[Q, string]
	AddressPlace        psql.WhereMod[Q, string]
	AddressPostcode     psql.WhereMod[Q, string]
	AddressRegion       psql.WhereMod[Q, string]
	AddressStreet       psql.WhereMod[Q, string]
	IsLocationBackyard  psql.WhereMod[Q, bool]
	IsLocationFrontyard psql.WhereMod[Q, bool]
	IsLocationGarden    psql.WhereMod[Q, bool]
	IsLocationOther     psql.WhereMod[Q, bool]
	IsLocationPool      psql.WhereMod[Q, bool]
	MapZoom             psql.WhereMod[Q, float32]
	TodEarly            psql.WhereMod[Q, bool]
	TodDay              psql.WhereMod[Q, bool]
	TodEvening          psql.WhereMod[Q, bool]
	TodNight            psql.WhereMod[Q, bool]
	LatlngAccuracyType  psql.WhereMod[Q, enums.PublicreportAccuracytype]
	LatlngAccuracyValue psql.WhereMod[Q, float32]
}

func (publicreportNuisanceWhere[Q]) AliasedAs(alias string) publicreportNuisanceWhere[Q] {
	return buildPublicreportNuisanceWhere[Q](buildPublicreportNuisanceColumns(alias))
}

func buildPublicreportNuisanceWhere[Q psql.Filterable](cols publicreportNuisanceColumns) publicreportNuisanceWhere[Q] {
	return publicreportNuisanceWhere[Q]{
		ID:                  psql.Where[Q, int32](cols.ID),
		AdditionalInfo:      psql.Where[Q, string](cols.AdditionalInfo),
		Created:             psql.Where[Q, time.Time](cols.Created),
		Duration:            psql.Where[Q, enums.PublicreportNuisancedurationtype](cols.Duration),
		SourceContainer:     psql.Where[Q, bool](cols.SourceContainer),
		SourceDescription:   psql.Where[Q, string](cols.SourceDescription),
		SourceStagnant:      psql.Where[Q, bool](cols.SourceStagnant),
		PublicID:            psql.Where[Q, string](cols.PublicID),
		ReporterEmail:       psql.WhereNull[Q, string](cols.ReporterEmail),
		ReporterName:        psql.WhereNull[Q, string](cols.ReporterName),
		ReporterPhone:       psql.WhereNull[Q, string](cols.ReporterPhone),
		Address:             psql.Where[Q, string](cols.Address),
		Location:            psql.WhereNull[Q, string](cols.Location),
		Status:              psql.Where[Q, enums.PublicreportReportstatustype](cols.Status),
		OrganizationID:      psql.WhereNull[Q, int32](cols.OrganizationID),
		SourceGutter:        psql.Where[Q, bool](cols.SourceGutter),
		H3cell:              psql.WhereNull[Q, string](cols.H3cell),
		AddressCountry:      psql.Where[Q, string](cols.AddressCountry),
		AddressPlace:        psql.Where[Q, string](cols.AddressPlace),
		AddressPostcode:     psql.Where[Q, string](cols.AddressPostcode),
		AddressRegion:       psql.Where[Q, string](cols.AddressRegion),
		AddressStreet:       psql.Where[Q, string](cols.AddressStreet),
		IsLocationBackyard:  psql.Where[Q, bool](cols.IsLocationBackyard),
		IsLocationFrontyard: psql.Where[Q, bool](cols.IsLocationFrontyard),
		IsLocationGarden:    psql.Where[Q, bool](cols.IsLocationGarden),
		IsLocationOther:     psql.Where[Q, bool](cols.IsLocationOther),
		IsLocationPool:      psql.Where[Q, bool](cols.IsLocationPool),
		MapZoom:             psql.Where[Q, float32](cols.MapZoom),
		TodEarly:            psql.Where[Q, bool](cols.TodEarly),
		TodDay:              psql.Where[Q, bool](cols.TodDay),
		TodEvening:          psql.Where[Q, bool](cols.TodEvening),
		TodNight:            psql.Where[Q, bool](cols.TodNight),
		LatlngAccuracyType:  psql.Where[Q, enums.PublicreportAccuracytype](cols.LatlngAccuracyType),
		LatlngAccuracyValue: psql.Where[Q, float32](cols.LatlngAccuracyValue),
	}
}

func (o *PublicreportNuisance) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Organization":
		rel, ok := retrieved.(*Organization)
		if !ok {
			return fmt.Errorf("publicreportNuisance cannot load %T as %q", retrieved, name)
		}

		o.R.Organization = rel

		if rel != nil {
			rel.R.Nuisances = PublicreportNuisanceSlice{o}
		}
		return nil
	case "Images":
		rels, ok := retrieved.(PublicreportImageSlice)
		if !ok {
			return fmt.Errorf("publicreportNuisance cannot load %T as %q", retrieved, name)
		}

		o.R.Images = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Nuisances = PublicreportNuisanceSlice{o}
			}
		}
		return nil
	default:
		return fmt.Errorf("publicreportNuisance has no relationship %q", name)
	}
}

type publicreportNuisancePreloader struct {
	Organization func(...psql.PreloadOption) psql.Preloader
}

func buildPublicreportNuisancePreloader() publicreportNuisancePreloader {
	return publicreportNuisancePreloader{
		Organization: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Organization, OrganizationSlice](psql.PreloadRel{
				Name: "Organization",
				Sides: []psql.PreloadSide{
					{
						From:        PublicreportNuisances,
						To:          Organizations,
						FromColumns: []string{"organization_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Organizations.Columns.Names(), opts...)
		},
	}
}

type publicreportNuisanceThenLoader[Q orm.Loadable] struct {
	Organization func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Images       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildPublicreportNuisanceThenLoader[Q orm.Loadable]() publicreportNuisanceThenLoader[Q] {
	type OrganizationLoadInterface interface {
		LoadOrganization(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ImagesLoadInterface interface {
		LoadImages(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return publicreportNuisanceThenLoader[Q]{
		Organization: thenLoadBuilder[Q](
			"Organization",
			func(ctx context.Context, exec bob.Executor, retrieved OrganizationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrganization(ctx, exec, mods...)
			},
		),
		Images: thenLoadBuilder[Q](
			"Images",
			func(ctx context.Context, exec bob.Executor, retrieved ImagesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadImages(ctx, exec, mods...)
			},
		),
	}
}

// LoadOrganization loads the publicreportNuisance's Organization into the .R struct
func (o *PublicreportNuisance) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Organization = nil

	related, err := o.Organization(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Nuisances = PublicreportNuisanceSlice{o}

	o.R.Organization = related
	return nil
}

// LoadOrganization loads the publicreportNuisance's Organization into the .R struct
func (os PublicreportNuisanceSlice) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	organizations, err := os.Organization(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range organizations {
			if !o.OrganizationID.IsValue() {
				continue
			}

			if !(o.OrganizationID.IsValue() && o.OrganizationID.MustGet() == rel.ID) {
				continue
			}

			rel.R.Nuisances = append(rel.R.Nuisances, o)

			o.R.Organization = rel
			break
		}
	}

	return nil
}

// LoadImages loads the publicreportNuisance's Images into the .R struct
func (o *PublicreportNuisance) LoadImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Images = nil

	related, err := o.Images(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Nuisances = PublicreportNuisanceSlice{o}
	}

	o.R.Images = related
	return nil
}

// LoadImages loads the publicreportNuisance's Images into the .R struct
func (os PublicreportNuisanceSlice) LoadImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	// since we are changing the columns, we need to check if the original columns were set or add the defaults
	sq := dialect.SelectQuery{}
	for _, mod := range mods {
		mod.Apply(&sq)
	}

	if len(sq.SelectList.Columns) == 0 {
		mods = append(mods, sm.Columns(PublicreportImages.Columns))
	}

	q := os.Images(append(
		mods,
		sm.Columns(PublicreportNuisanceImages.Columns.NuisanceID.As("related_publicreport.nuisance.ID")),
	)...)

	IDSlice := []int32{}

	mapper := scan.Mod(scan.StructMapper[*PublicreportImage](), func(ctx context.Context, cols []string) (scan.BeforeFunc, func(any, any) error) {
		return func(row *scan.Row) (any, error) {
				IDSlice = append(IDSlice, *new(int32))
				row.ScheduleScanByName("related_publicreport.nuisance.ID", &IDSlice[len(IDSlice)-1])

				return nil, nil
			},
			func(any, any) error {
				return nil
			}
	})

	publicreportImages, err := bob.Allx[bob.SliceTransformer[*PublicreportImage, PublicreportImageSlice]](ctx, exec, q, mapper)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.Images = nil
	}

	for _, o := range os {
		for i, rel := range publicreportImages {
			if !(o.ID == IDSlice[i]) {
				continue
			}

			rel.R.Nuisances = append(rel.R.Nuisances, o)

			o.R.Images = append(o.R.Images, rel)
		}
	}

	return nil
}

// publicreportNuisanceC is where relationship counts are stored.
type publicreportNuisanceC struct {
	Images *int64
}

// PreloadCount sets a count in the C struct by name
func (o *PublicreportNuisance) PreloadCount(name string, count int64) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Images":
		o.C.Images = &count
	}
	return nil
}

type publicreportNuisanceCountPreloader struct {
	Images func(...bob.Mod[*dialect.SelectQuery]) psql.Preloader
}

func buildPublicreportNuisanceCountPreloader() publicreportNuisanceCountPreloader {
	return publicreportNuisanceCountPreloader{
		Images: func(mods ...bob.Mod[*dialect.SelectQuery]) psql.Preloader {
			return countPreloader[*PublicreportNuisance]("Images", func(parent string) bob.Expression {
				// Build a correlated subquery: (SELECT COUNT(*) FROM related WHERE fk = parent.pk)
				if parent == "" {
					parent = PublicreportNuisances.Alias()
				}

				subqueryMods := []bob.Mod[*dialect.SelectQuery]{
					sm.Columns(psql.Raw("count(*)")),

					sm.From(PublicreportNuisanceImages.Name()),
					sm.Where(psql.Quote(PublicreportNuisanceImages.Alias(), "nuisance_id").EQ(psql.Quote(parent, "id"))),
					sm.InnerJoin(PublicreportImages.Name()).On(
						psql.Quote(PublicreportImages.Alias(), "id").EQ(psql.Quote(PublicreportNuisanceImages.Alias(), "image_id")),
					),
				}
				subqueryMods = append(subqueryMods, mods...)
				return psql.Group(psql.Select(subqueryMods...).Expression)
			})
		},
	}
}

type publicreportNuisanceCountThenLoader[Q orm.Loadable] struct {
	Images func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildPublicreportNuisanceCountThenLoader[Q orm.Loadable]() publicreportNuisanceCountThenLoader[Q] {
	type ImagesCountInterface interface {
		LoadCountImages(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return publicreportNuisanceCountThenLoader[Q]{
		Images: countThenLoadBuilder[Q](
			"Images",
			func(ctx context.Context, exec bob.Executor, retrieved ImagesCountInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCountImages(ctx, exec, mods...)
			},
		),
	}
}

// LoadCountImages loads the count of Images into the C struct
func (o *PublicreportNuisance) LoadCountImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	count, err := o.Images(mods...).Count(ctx, exec)
	if err != nil {
		return err
	}

	o.C.Images = &count
	return nil
}

// LoadCountImages loads the count of Images for a slice
func (os PublicreportNuisanceSlice) LoadCountImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	for _, o := range os {
		if err := o.LoadCountImages(ctx, exec, mods...); err != nil {
			return err
		}
	}

	return nil
}

type publicreportNuisanceJoins[Q dialect.Joinable] struct {
	typ          string
	Organization modAs[Q, organizationColumns]
	Images       modAs[Q, publicreportImageColumns]
}

func (j publicreportNuisanceJoins[Q]) aliasedAs(alias string) publicreportNuisanceJoins[Q] {
	return buildPublicreportNuisanceJoins[Q](buildPublicreportNuisanceColumns(alias), j.typ)
}

func buildPublicreportNuisanceJoins[Q dialect.Joinable](cols publicreportNuisanceColumns, typ string) publicreportNuisanceJoins[Q] {
	return publicreportNuisanceJoins[Q]{
		typ: typ,
		Organization: modAs[Q, organizationColumns]{
			c: Organizations.Columns,
			f: func(to organizationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Organizations.Name().As(to.Alias())).On(
						to.ID.EQ(cols.OrganizationID),
					))
				}

				return mods
			},
		},
		Images: modAs[Q, publicreportImageColumns]{
			c: PublicreportImages.Columns,
			f: func(to publicreportImageColumns) bob.Mod[Q] {
				random := strconv.FormatInt(randInt(), 10)
				mods := make(mods.QueryMods[Q], 0, 2)

				{
					to := PublicreportNuisanceImages.Columns.AliasedAs(PublicreportNuisanceImages.Columns.Alias() + random)
					mods = append(mods, dialect.Join[Q](typ, PublicreportNuisanceImages.Name().As(to.Alias())).On(
						to.NuisanceID.EQ(cols.ID),
					))
				}
				{
					cols := PublicreportNuisanceImages.Columns.AliasedAs(PublicreportNuisanceImages.Columns.Alias() + random)
					mods = append(mods, dialect.Join[Q](typ, PublicreportImages.Name().As(to.Alias())).On(
						to.ID.EQ(cols.ImageID),
					))
				}

				return mods
			},
		},
	}
}
