// Code generated by BobGen psql v0.42.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/Gleipnir-Technology/bob"
	"github.com/Gleipnir-Technology/bob/dialect/psql"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dialect"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dm"
	"github.com/Gleipnir-Technology/bob/dialect/psql/sm"
	"github.com/Gleipnir-Technology/bob/dialect/psql/um"
	"github.com/Gleipnir-Technology/bob/expr"
	"github.com/Gleipnir-Technology/bob/mods"
	"github.com/Gleipnir-Technology/bob/orm"
	"github.com/Gleipnir-Technology/bob/types/pgtypes"
	enums "github.com/Gleipnir-Technology/nidus-sync/db/enums"
	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
)

// PublicreportNuisance is an object representing the database table.
type PublicreportNuisance struct {
	ID                int32                                  `db:"id,pk" `
	AdditionalInfo    string                                 `db:"additional_info" `
	Created           time.Time                              `db:"created" `
	Duration          enums.PublicreportNuisancedurationtype `db:"duration" `
	SourceLocation    enums.PublicreportNuisancelocationtype `db:"source_location" `
	SourceContainer   bool                                   `db:"source_container" `
	SourceDescription string                                 `db:"source_description" `
	SourceStagnant    bool                                   `db:"source_stagnant" `
	PublicID          string                                 `db:"public_id" `
	ReporterAddress   string                                 `db:"reporter_address" `
	ReporterEmail     string                                 `db:"reporter_email" `
	ReporterName      string                                 `db:"reporter_name" `
	ReporterPhone     string                                 `db:"reporter_phone" `
	Address           string                                 `db:"address" `
	Location          null.Val[string]                       `db:"location" `
	Status            enums.PublicreportReportstatustype     `db:"status" `
	OrganizationID    null.Val[int32]                        `db:"organization_id" `
	SourceGutter      bool                                   `db:"source_gutter" `

	R publicreportNuisanceR `db:"-" `
}

// PublicreportNuisanceSlice is an alias for a slice of pointers to PublicreportNuisance.
// This should almost always be used instead of []*PublicreportNuisance.
type PublicreportNuisanceSlice []*PublicreportNuisance

// PublicreportNuisances contains methods to work with the nuisance table
var PublicreportNuisances = psql.NewTablex[*PublicreportNuisance, PublicreportNuisanceSlice, *PublicreportNuisanceSetter]("publicreport", "nuisance", buildPublicreportNuisanceColumns("publicreport.nuisance"))

// PublicreportNuisancesQuery is a query on the nuisance table
type PublicreportNuisancesQuery = *psql.ViewQuery[*PublicreportNuisance, PublicreportNuisanceSlice]

// publicreportNuisanceR is where relationships are stored.
type publicreportNuisanceR struct {
	Organization *Organization // publicreport.nuisance.nuisance_organization_id_fkey
}

func buildPublicreportNuisanceColumns(alias string) publicreportNuisanceColumns {
	return publicreportNuisanceColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "additional_info", "created", "duration", "source_location", "source_container", "source_description", "source_stagnant", "public_id", "reporter_address", "reporter_email", "reporter_name", "reporter_phone", "address", "location", "status", "organization_id", "source_gutter",
		).WithParent("publicreport.nuisance"),
		tableAlias:        alias,
		ID:                psql.Quote(alias, "id"),
		AdditionalInfo:    psql.Quote(alias, "additional_info"),
		Created:           psql.Quote(alias, "created"),
		Duration:          psql.Quote(alias, "duration"),
		SourceLocation:    psql.Quote(alias, "source_location"),
		SourceContainer:   psql.Quote(alias, "source_container"),
		SourceDescription: psql.Quote(alias, "source_description"),
		SourceStagnant:    psql.Quote(alias, "source_stagnant"),
		PublicID:          psql.Quote(alias, "public_id"),
		ReporterAddress:   psql.Quote(alias, "reporter_address"),
		ReporterEmail:     psql.Quote(alias, "reporter_email"),
		ReporterName:      psql.Quote(alias, "reporter_name"),
		ReporterPhone:     psql.Quote(alias, "reporter_phone"),
		Address:           psql.Quote(alias, "address"),
		Location:          psql.Quote(alias, "location"),
		Status:            psql.Quote(alias, "status"),
		OrganizationID:    psql.Quote(alias, "organization_id"),
		SourceGutter:      psql.Quote(alias, "source_gutter"),
	}
}

type publicreportNuisanceColumns struct {
	expr.ColumnsExpr
	tableAlias        string
	ID                psql.Expression
	AdditionalInfo    psql.Expression
	Created           psql.Expression
	Duration          psql.Expression
	SourceLocation    psql.Expression
	SourceContainer   psql.Expression
	SourceDescription psql.Expression
	SourceStagnant    psql.Expression
	PublicID          psql.Expression
	ReporterAddress   psql.Expression
	ReporterEmail     psql.Expression
	ReporterName      psql.Expression
	ReporterPhone     psql.Expression
	Address           psql.Expression
	Location          psql.Expression
	Status            psql.Expression
	OrganizationID    psql.Expression
	SourceGutter      psql.Expression
}

func (c publicreportNuisanceColumns) Alias() string {
	return c.tableAlias
}

func (publicreportNuisanceColumns) AliasedAs(alias string) publicreportNuisanceColumns {
	return buildPublicreportNuisanceColumns(alias)
}

// PublicreportNuisanceSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type PublicreportNuisanceSetter struct {
	ID                omit.Val[int32]                                  `db:"id,pk" `
	AdditionalInfo    omit.Val[string]                                 `db:"additional_info" `
	Created           omit.Val[time.Time]                              `db:"created" `
	Duration          omit.Val[enums.PublicreportNuisancedurationtype] `db:"duration" `
	SourceLocation    omit.Val[enums.PublicreportNuisancelocationtype] `db:"source_location" `
	SourceContainer   omit.Val[bool]                                   `db:"source_container" `
	SourceDescription omit.Val[string]                                 `db:"source_description" `
	SourceStagnant    omit.Val[bool]                                   `db:"source_stagnant" `
	PublicID          omit.Val[string]                                 `db:"public_id" `
	ReporterAddress   omit.Val[string]                                 `db:"reporter_address" `
	ReporterEmail     omit.Val[string]                                 `db:"reporter_email" `
	ReporterName      omit.Val[string]                                 `db:"reporter_name" `
	ReporterPhone     omit.Val[string]                                 `db:"reporter_phone" `
	Address           omit.Val[string]                                 `db:"address" `
	Location          omitnull.Val[string]                             `db:"location" `
	Status            omit.Val[enums.PublicreportReportstatustype]     `db:"status" `
	OrganizationID    omitnull.Val[int32]                              `db:"organization_id" `
	SourceGutter      omit.Val[bool]                                   `db:"source_gutter" `
}

func (s PublicreportNuisanceSetter) SetColumns() []string {
	vals := make([]string, 0, 18)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if s.AdditionalInfo.IsValue() {
		vals = append(vals, "additional_info")
	}
	if s.Created.IsValue() {
		vals = append(vals, "created")
	}
	if s.Duration.IsValue() {
		vals = append(vals, "duration")
	}
	if s.SourceLocation.IsValue() {
		vals = append(vals, "source_location")
	}
	if s.SourceContainer.IsValue() {
		vals = append(vals, "source_container")
	}
	if s.SourceDescription.IsValue() {
		vals = append(vals, "source_description")
	}
	if s.SourceStagnant.IsValue() {
		vals = append(vals, "source_stagnant")
	}
	if s.PublicID.IsValue() {
		vals = append(vals, "public_id")
	}
	if s.ReporterAddress.IsValue() {
		vals = append(vals, "reporter_address")
	}
	if s.ReporterEmail.IsValue() {
		vals = append(vals, "reporter_email")
	}
	if s.ReporterName.IsValue() {
		vals = append(vals, "reporter_name")
	}
	if s.ReporterPhone.IsValue() {
		vals = append(vals, "reporter_phone")
	}
	if s.Address.IsValue() {
		vals = append(vals, "address")
	}
	if !s.Location.IsUnset() {
		vals = append(vals, "location")
	}
	if s.Status.IsValue() {
		vals = append(vals, "status")
	}
	if !s.OrganizationID.IsUnset() {
		vals = append(vals, "organization_id")
	}
	if s.SourceGutter.IsValue() {
		vals = append(vals, "source_gutter")
	}
	return vals
}

func (s PublicreportNuisanceSetter) Overwrite(t *PublicreportNuisance) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if s.AdditionalInfo.IsValue() {
		t.AdditionalInfo = s.AdditionalInfo.MustGet()
	}
	if s.Created.IsValue() {
		t.Created = s.Created.MustGet()
	}
	if s.Duration.IsValue() {
		t.Duration = s.Duration.MustGet()
	}
	if s.SourceLocation.IsValue() {
		t.SourceLocation = s.SourceLocation.MustGet()
	}
	if s.SourceContainer.IsValue() {
		t.SourceContainer = s.SourceContainer.MustGet()
	}
	if s.SourceDescription.IsValue() {
		t.SourceDescription = s.SourceDescription.MustGet()
	}
	if s.SourceStagnant.IsValue() {
		t.SourceStagnant = s.SourceStagnant.MustGet()
	}
	if s.PublicID.IsValue() {
		t.PublicID = s.PublicID.MustGet()
	}
	if s.ReporterAddress.IsValue() {
		t.ReporterAddress = s.ReporterAddress.MustGet()
	}
	if s.ReporterEmail.IsValue() {
		t.ReporterEmail = s.ReporterEmail.MustGet()
	}
	if s.ReporterName.IsValue() {
		t.ReporterName = s.ReporterName.MustGet()
	}
	if s.ReporterPhone.IsValue() {
		t.ReporterPhone = s.ReporterPhone.MustGet()
	}
	if s.Address.IsValue() {
		t.Address = s.Address.MustGet()
	}
	if !s.Location.IsUnset() {
		t.Location = s.Location.MustGetNull()
	}
	if s.Status.IsValue() {
		t.Status = s.Status.MustGet()
	}
	if !s.OrganizationID.IsUnset() {
		t.OrganizationID = s.OrganizationID.MustGetNull()
	}
	if s.SourceGutter.IsValue() {
		t.SourceGutter = s.SourceGutter.MustGet()
	}
}

func (s *PublicreportNuisanceSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return PublicreportNuisances.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 18)
		if s.ID.IsValue() {
			vals[0] = psql.Arg(s.ID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.AdditionalInfo.IsValue() {
			vals[1] = psql.Arg(s.AdditionalInfo.MustGet())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.Created.IsValue() {
			vals[2] = psql.Arg(s.Created.MustGet())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.Duration.IsValue() {
			vals[3] = psql.Arg(s.Duration.MustGet())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.SourceLocation.IsValue() {
			vals[4] = psql.Arg(s.SourceLocation.MustGet())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.SourceContainer.IsValue() {
			vals[5] = psql.Arg(s.SourceContainer.MustGet())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.SourceDescription.IsValue() {
			vals[6] = psql.Arg(s.SourceDescription.MustGet())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.SourceStagnant.IsValue() {
			vals[7] = psql.Arg(s.SourceStagnant.MustGet())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.PublicID.IsValue() {
			vals[8] = psql.Arg(s.PublicID.MustGet())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.ReporterAddress.IsValue() {
			vals[9] = psql.Arg(s.ReporterAddress.MustGet())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.ReporterEmail.IsValue() {
			vals[10] = psql.Arg(s.ReporterEmail.MustGet())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.ReporterName.IsValue() {
			vals[11] = psql.Arg(s.ReporterName.MustGet())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.ReporterPhone.IsValue() {
			vals[12] = psql.Arg(s.ReporterPhone.MustGet())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.Address.IsValue() {
			vals[13] = psql.Arg(s.Address.MustGet())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.Location.IsUnset() {
			vals[14] = psql.Arg(s.Location.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.Status.IsValue() {
			vals[15] = psql.Arg(s.Status.MustGet())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.OrganizationID.IsUnset() {
			vals[16] = psql.Arg(s.OrganizationID.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if s.SourceGutter.IsValue() {
			vals[17] = psql.Arg(s.SourceGutter.MustGet())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s PublicreportNuisanceSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s PublicreportNuisanceSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 18)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if s.AdditionalInfo.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "additional_info")...),
			psql.Arg(s.AdditionalInfo),
		}})
	}

	if s.Created.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created")...),
			psql.Arg(s.Created),
		}})
	}

	if s.Duration.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "duration")...),
			psql.Arg(s.Duration),
		}})
	}

	if s.SourceLocation.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "source_location")...),
			psql.Arg(s.SourceLocation),
		}})
	}

	if s.SourceContainer.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "source_container")...),
			psql.Arg(s.SourceContainer),
		}})
	}

	if s.SourceDescription.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "source_description")...),
			psql.Arg(s.SourceDescription),
		}})
	}

	if s.SourceStagnant.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "source_stagnant")...),
			psql.Arg(s.SourceStagnant),
		}})
	}

	if s.PublicID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "public_id")...),
			psql.Arg(s.PublicID),
		}})
	}

	if s.ReporterAddress.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_address")...),
			psql.Arg(s.ReporterAddress),
		}})
	}

	if s.ReporterEmail.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_email")...),
			psql.Arg(s.ReporterEmail),
		}})
	}

	if s.ReporterName.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_name")...),
			psql.Arg(s.ReporterName),
		}})
	}

	if s.ReporterPhone.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_phone")...),
			psql.Arg(s.ReporterPhone),
		}})
	}

	if s.Address.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address")...),
			psql.Arg(s.Address),
		}})
	}

	if !s.Location.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "location")...),
			psql.Arg(s.Location),
		}})
	}

	if s.Status.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "status")...),
			psql.Arg(s.Status),
		}})
	}

	if !s.OrganizationID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "organization_id")...),
			psql.Arg(s.OrganizationID),
		}})
	}

	if s.SourceGutter.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "source_gutter")...),
			psql.Arg(s.SourceGutter),
		}})
	}

	return exprs
}

// FindPublicreportNuisance retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindPublicreportNuisance(ctx context.Context, exec bob.Executor, IDPK int32, cols ...string) (*PublicreportNuisance, error) {
	if len(cols) == 0 {
		return PublicreportNuisances.Query(
			sm.Where(PublicreportNuisances.Columns.ID.EQ(psql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return PublicreportNuisances.Query(
		sm.Where(PublicreportNuisances.Columns.ID.EQ(psql.Arg(IDPK))),
		sm.Columns(PublicreportNuisances.Columns.Only(cols...)),
	).One(ctx, exec)
}

// PublicreportNuisanceExists checks the presence of a single record by primary key
func PublicreportNuisanceExists(ctx context.Context, exec bob.Executor, IDPK int32) (bool, error) {
	return PublicreportNuisances.Query(
		sm.Where(PublicreportNuisances.Columns.ID.EQ(psql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after PublicreportNuisance is retrieved from the database
func (o *PublicreportNuisance) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = PublicreportNuisances.AfterSelectHooks.RunHooks(ctx, exec, PublicreportNuisanceSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = PublicreportNuisances.AfterInsertHooks.RunHooks(ctx, exec, PublicreportNuisanceSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = PublicreportNuisances.AfterUpdateHooks.RunHooks(ctx, exec, PublicreportNuisanceSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = PublicreportNuisances.AfterDeleteHooks.RunHooks(ctx, exec, PublicreportNuisanceSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the PublicreportNuisance
func (o *PublicreportNuisance) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *PublicreportNuisance) pkEQ() dialect.Expression {
	return psql.Quote("publicreport.nuisance", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the PublicreportNuisance
func (o *PublicreportNuisance) Update(ctx context.Context, exec bob.Executor, s *PublicreportNuisanceSetter) error {
	v, err := PublicreportNuisances.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single PublicreportNuisance record with an executor
func (o *PublicreportNuisance) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := PublicreportNuisances.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the PublicreportNuisance using the executor
func (o *PublicreportNuisance) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := PublicreportNuisances.Query(
		sm.Where(PublicreportNuisances.Columns.ID.EQ(psql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after PublicreportNuisanceSlice is retrieved from the database
func (o PublicreportNuisanceSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = PublicreportNuisances.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = PublicreportNuisances.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = PublicreportNuisances.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = PublicreportNuisances.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o PublicreportNuisanceSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("publicreport.nuisance", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o PublicreportNuisanceSlice) copyMatchingRows(from ...*PublicreportNuisance) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o PublicreportNuisanceSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return PublicreportNuisances.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *PublicreportNuisance:
				o.copyMatchingRows(retrieved)
			case []*PublicreportNuisance:
				o.copyMatchingRows(retrieved...)
			case PublicreportNuisanceSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a PublicreportNuisance or a slice of PublicreportNuisance
				// then run the AfterUpdateHooks on the slice
				_, err = PublicreportNuisances.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o PublicreportNuisanceSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return PublicreportNuisances.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *PublicreportNuisance:
				o.copyMatchingRows(retrieved)
			case []*PublicreportNuisance:
				o.copyMatchingRows(retrieved...)
			case PublicreportNuisanceSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a PublicreportNuisance or a slice of PublicreportNuisance
				// then run the AfterDeleteHooks on the slice
				_, err = PublicreportNuisances.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o PublicreportNuisanceSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals PublicreportNuisanceSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := PublicreportNuisances.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o PublicreportNuisanceSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := PublicreportNuisances.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o PublicreportNuisanceSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := PublicreportNuisances.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// Organization starts a query for related objects on organization
func (o *PublicreportNuisance) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	return Organizations.Query(append(mods,
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.OrganizationID))),
	)...)
}

func (os PublicreportNuisanceSlice) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	pkOrganizationID := make(pgtypes.Array[null.Val[int32]], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkOrganizationID = append(pkOrganizationID, o.OrganizationID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkOrganizationID), "integer[]")),
	))

	return Organizations.Query(append(mods,
		sm.Where(psql.Group(Organizations.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

func attachPublicreportNuisanceOrganization0(ctx context.Context, exec bob.Executor, count int, publicreportNuisance0 *PublicreportNuisance, organization1 *Organization) (*PublicreportNuisance, error) {
	setter := &PublicreportNuisanceSetter{
		OrganizationID: omitnull.From(organization1.ID),
	}

	err := publicreportNuisance0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachPublicreportNuisanceOrganization0: %w", err)
	}

	return publicreportNuisance0, nil
}

func (publicreportNuisance0 *PublicreportNuisance) InsertOrganization(ctx context.Context, exec bob.Executor, related *OrganizationSetter) error {
	var err error

	organization1, err := Organizations.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachPublicreportNuisanceOrganization0(ctx, exec, 1, publicreportNuisance0, organization1)
	if err != nil {
		return err
	}

	publicreportNuisance0.R.Organization = organization1

	organization1.R.Nuisances = append(organization1.R.Nuisances, publicreportNuisance0)

	return nil
}

func (publicreportNuisance0 *PublicreportNuisance) AttachOrganization(ctx context.Context, exec bob.Executor, organization1 *Organization) error {
	var err error

	_, err = attachPublicreportNuisanceOrganization0(ctx, exec, 1, publicreportNuisance0, organization1)
	if err != nil {
		return err
	}

	publicreportNuisance0.R.Organization = organization1

	organization1.R.Nuisances = append(organization1.R.Nuisances, publicreportNuisance0)

	return nil
}

type publicreportNuisanceWhere[Q psql.Filterable] struct {
	ID                psql.WhereMod[Q, int32]
	AdditionalInfo    psql.WhereMod[Q, string]
	Created           psql.WhereMod[Q, time.Time]
	Duration          psql.WhereMod[Q, enums.PublicreportNuisancedurationtype]
	SourceLocation    psql.WhereMod[Q, enums.PublicreportNuisancelocationtype]
	SourceContainer   psql.WhereMod[Q, bool]
	SourceDescription psql.WhereMod[Q, string]
	SourceStagnant    psql.WhereMod[Q, bool]
	PublicID          psql.WhereMod[Q, string]
	ReporterAddress   psql.WhereMod[Q, string]
	ReporterEmail     psql.WhereMod[Q, string]
	ReporterName      psql.WhereMod[Q, string]
	ReporterPhone     psql.WhereMod[Q, string]
	Address           psql.WhereMod[Q, string]
	Location          psql.WhereNullMod[Q, string]
	Status            psql.WhereMod[Q, enums.PublicreportReportstatustype]
	OrganizationID    psql.WhereNullMod[Q, int32]
	SourceGutter      psql.WhereMod[Q, bool]
}

func (publicreportNuisanceWhere[Q]) AliasedAs(alias string) publicreportNuisanceWhere[Q] {
	return buildPublicreportNuisanceWhere[Q](buildPublicreportNuisanceColumns(alias))
}

func buildPublicreportNuisanceWhere[Q psql.Filterable](cols publicreportNuisanceColumns) publicreportNuisanceWhere[Q] {
	return publicreportNuisanceWhere[Q]{
		ID:                psql.Where[Q, int32](cols.ID),
		AdditionalInfo:    psql.Where[Q, string](cols.AdditionalInfo),
		Created:           psql.Where[Q, time.Time](cols.Created),
		Duration:          psql.Where[Q, enums.PublicreportNuisancedurationtype](cols.Duration),
		SourceLocation:    psql.Where[Q, enums.PublicreportNuisancelocationtype](cols.SourceLocation),
		SourceContainer:   psql.Where[Q, bool](cols.SourceContainer),
		SourceDescription: psql.Where[Q, string](cols.SourceDescription),
		SourceStagnant:    psql.Where[Q, bool](cols.SourceStagnant),
		PublicID:          psql.Where[Q, string](cols.PublicID),
		ReporterAddress:   psql.Where[Q, string](cols.ReporterAddress),
		ReporterEmail:     psql.Where[Q, string](cols.ReporterEmail),
		ReporterName:      psql.Where[Q, string](cols.ReporterName),
		ReporterPhone:     psql.Where[Q, string](cols.ReporterPhone),
		Address:           psql.Where[Q, string](cols.Address),
		Location:          psql.WhereNull[Q, string](cols.Location),
		Status:            psql.Where[Q, enums.PublicreportReportstatustype](cols.Status),
		OrganizationID:    psql.WhereNull[Q, int32](cols.OrganizationID),
		SourceGutter:      psql.Where[Q, bool](cols.SourceGutter),
	}
}

func (o *PublicreportNuisance) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Organization":
		rel, ok := retrieved.(*Organization)
		if !ok {
			return fmt.Errorf("publicreportNuisance cannot load %T as %q", retrieved, name)
		}

		o.R.Organization = rel

		if rel != nil {
			rel.R.Nuisances = PublicreportNuisanceSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("publicreportNuisance has no relationship %q", name)
	}
}

type publicreportNuisancePreloader struct {
	Organization func(...psql.PreloadOption) psql.Preloader
}

func buildPublicreportNuisancePreloader() publicreportNuisancePreloader {
	return publicreportNuisancePreloader{
		Organization: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Organization, OrganizationSlice](psql.PreloadRel{
				Name: "Organization",
				Sides: []psql.PreloadSide{
					{
						From:        PublicreportNuisances,
						To:          Organizations,
						FromColumns: []string{"organization_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Organizations.Columns.Names(), opts...)
		},
	}
}

type publicreportNuisanceThenLoader[Q orm.Loadable] struct {
	Organization func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildPublicreportNuisanceThenLoader[Q orm.Loadable]() publicreportNuisanceThenLoader[Q] {
	type OrganizationLoadInterface interface {
		LoadOrganization(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return publicreportNuisanceThenLoader[Q]{
		Organization: thenLoadBuilder[Q](
			"Organization",
			func(ctx context.Context, exec bob.Executor, retrieved OrganizationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrganization(ctx, exec, mods...)
			},
		),
	}
}

// LoadOrganization loads the publicreportNuisance's Organization into the .R struct
func (o *PublicreportNuisance) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Organization = nil

	related, err := o.Organization(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Nuisances = PublicreportNuisanceSlice{o}

	o.R.Organization = related
	return nil
}

// LoadOrganization loads the publicreportNuisance's Organization into the .R struct
func (os PublicreportNuisanceSlice) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	organizations, err := os.Organization(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range organizations {
			if !o.OrganizationID.IsValue() {
				continue
			}

			if !(o.OrganizationID.IsValue() && o.OrganizationID.MustGet() == rel.ID) {
				continue
			}

			rel.R.Nuisances = append(rel.R.Nuisances, o)

			o.R.Organization = rel
			break
		}
	}

	return nil
}

type publicreportNuisanceJoins[Q dialect.Joinable] struct {
	typ          string
	Organization modAs[Q, organizationColumns]
}

func (j publicreportNuisanceJoins[Q]) aliasedAs(alias string) publicreportNuisanceJoins[Q] {
	return buildPublicreportNuisanceJoins[Q](buildPublicreportNuisanceColumns(alias), j.typ)
}

func buildPublicreportNuisanceJoins[Q dialect.Joinable](cols publicreportNuisanceColumns, typ string) publicreportNuisanceJoins[Q] {
	return publicreportNuisanceJoins[Q]{
		typ: typ,
		Organization: modAs[Q, organizationColumns]{
			c: Organizations.Columns,
			f: func(to organizationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Organizations.Name().As(to.Alias())).On(
						to.ID.EQ(cols.OrganizationID),
					))
				}

				return mods
			},
		},
	}
}
