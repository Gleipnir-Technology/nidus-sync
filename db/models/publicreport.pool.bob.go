// Code generated by BobGen psql v0.0.4-0.20260105020634-53e08d840e47+dirty. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"time"

	enums "github.com/Gleipnir-Technology/nidus-sync/db/enums"
	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// PublicreportPool is an object representing the database table.
type PublicreportPool struct {
	ID              int32                              `db:"id,pk" `
	AccessComments  string                             `db:"access_comments" `
	AccessGate      bool                               `db:"access_gate" `
	AccessFence     bool                               `db:"access_fence" `
	AccessLocked    bool                               `db:"access_locked" `
	AccessDog       bool                               `db:"access_dog" `
	AccessOther     bool                               `db:"access_other" `
	Address         string                             `db:"address" `
	AddressCountry  string                             `db:"address_country" `
	AddressPostCode string                             `db:"address_post_code" `
	AddressPlace    string                             `db:"address_place" `
	AddressStreet   string                             `db:"address_street" `
	AddressRegion   string                             `db:"address_region" `
	Comments        string                             `db:"comments" `
	Created         time.Time                          `db:"created" `
	H3cell          null.Val[string]                   `db:"h3cell" `
	HasAdult        bool                               `db:"has_adult" `
	HasLarvae       bool                               `db:"has_larvae" `
	HasPupae        bool                               `db:"has_pupae" `
	Location        null.Val[string]                   `db:"location" `
	MapZoom         float64                            `db:"map_zoom" `
	OwnerEmail      string                             `db:"owner_email" `
	OwnerName       string                             `db:"owner_name" `
	OwnerPhone      string                             `db:"owner_phone" `
	PublicID        string                             `db:"public_id" `
	ReporterEmail   string                             `db:"reporter_email" `
	ReporterName    string                             `db:"reporter_name" `
	ReporterPhone   string                             `db:"reporter_phone" `
	Subscribe       bool                               `db:"subscribe" `
	Status          enums.PublicreportReportstatustype `db:"status" `

	R publicreportPoolR `db:"-" `
}

// PublicreportPoolSlice is an alias for a slice of pointers to PublicreportPool.
// This should almost always be used instead of []*PublicreportPool.
type PublicreportPoolSlice []*PublicreportPool

// PublicreportPools contains methods to work with the pool table
var PublicreportPools = psql.NewTablex[*PublicreportPool, PublicreportPoolSlice, *PublicreportPoolSetter]("publicreport", "pool", buildPublicreportPoolColumns("publicreport.pool"))

// PublicreportPoolsQuery is a query on the pool table
type PublicreportPoolsQuery = *psql.ViewQuery[*PublicreportPool, PublicreportPoolSlice]

// publicreportPoolR is where relationships are stored.
type publicreportPoolR struct {
	PoolPhotos PublicreportPoolPhotoSlice // publicreport.pool_photo.pool_photo_pool_id_fkey
}

func buildPublicreportPoolColumns(alias string) publicreportPoolColumns {
	return publicreportPoolColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "access_comments", "access_gate", "access_fence", "access_locked", "access_dog", "access_other", "address", "address_country", "address_post_code", "address_place", "address_street", "address_region", "comments", "created", "h3cell", "has_adult", "has_larvae", "has_pupae", "location", "map_zoom", "owner_email", "owner_name", "owner_phone", "public_id", "reporter_email", "reporter_name", "reporter_phone", "subscribe", "status",
		).WithParent("publicreport.pool"),
		tableAlias:      alias,
		ID:              psql.Quote(alias, "id"),
		AccessComments:  psql.Quote(alias, "access_comments"),
		AccessGate:      psql.Quote(alias, "access_gate"),
		AccessFence:     psql.Quote(alias, "access_fence"),
		AccessLocked:    psql.Quote(alias, "access_locked"),
		AccessDog:       psql.Quote(alias, "access_dog"),
		AccessOther:     psql.Quote(alias, "access_other"),
		Address:         psql.Quote(alias, "address"),
		AddressCountry:  psql.Quote(alias, "address_country"),
		AddressPostCode: psql.Quote(alias, "address_post_code"),
		AddressPlace:    psql.Quote(alias, "address_place"),
		AddressStreet:   psql.Quote(alias, "address_street"),
		AddressRegion:   psql.Quote(alias, "address_region"),
		Comments:        psql.Quote(alias, "comments"),
		Created:         psql.Quote(alias, "created"),
		H3cell:          psql.Quote(alias, "h3cell"),
		HasAdult:        psql.Quote(alias, "has_adult"),
		HasLarvae:       psql.Quote(alias, "has_larvae"),
		HasPupae:        psql.Quote(alias, "has_pupae"),
		Location:        psql.Quote(alias, "location"),
		MapZoom:         psql.Quote(alias, "map_zoom"),
		OwnerEmail:      psql.Quote(alias, "owner_email"),
		OwnerName:       psql.Quote(alias, "owner_name"),
		OwnerPhone:      psql.Quote(alias, "owner_phone"),
		PublicID:        psql.Quote(alias, "public_id"),
		ReporterEmail:   psql.Quote(alias, "reporter_email"),
		ReporterName:    psql.Quote(alias, "reporter_name"),
		ReporterPhone:   psql.Quote(alias, "reporter_phone"),
		Subscribe:       psql.Quote(alias, "subscribe"),
		Status:          psql.Quote(alias, "status"),
	}
}

type publicreportPoolColumns struct {
	expr.ColumnsExpr
	tableAlias      string
	ID              psql.Expression
	AccessComments  psql.Expression
	AccessGate      psql.Expression
	AccessFence     psql.Expression
	AccessLocked    psql.Expression
	AccessDog       psql.Expression
	AccessOther     psql.Expression
	Address         psql.Expression
	AddressCountry  psql.Expression
	AddressPostCode psql.Expression
	AddressPlace    psql.Expression
	AddressStreet   psql.Expression
	AddressRegion   psql.Expression
	Comments        psql.Expression
	Created         psql.Expression
	H3cell          psql.Expression
	HasAdult        psql.Expression
	HasLarvae       psql.Expression
	HasPupae        psql.Expression
	Location        psql.Expression
	MapZoom         psql.Expression
	OwnerEmail      psql.Expression
	OwnerName       psql.Expression
	OwnerPhone      psql.Expression
	PublicID        psql.Expression
	ReporterEmail   psql.Expression
	ReporterName    psql.Expression
	ReporterPhone   psql.Expression
	Subscribe       psql.Expression
	Status          psql.Expression
}

func (c publicreportPoolColumns) Alias() string {
	return c.tableAlias
}

func (publicreportPoolColumns) AliasedAs(alias string) publicreportPoolColumns {
	return buildPublicreportPoolColumns(alias)
}

// PublicreportPoolSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type PublicreportPoolSetter struct {
	ID              omit.Val[int32]                              `db:"id,pk" `
	AccessComments  omit.Val[string]                             `db:"access_comments" `
	AccessGate      omit.Val[bool]                               `db:"access_gate" `
	AccessFence     omit.Val[bool]                               `db:"access_fence" `
	AccessLocked    omit.Val[bool]                               `db:"access_locked" `
	AccessDog       omit.Val[bool]                               `db:"access_dog" `
	AccessOther     omit.Val[bool]                               `db:"access_other" `
	Address         omit.Val[string]                             `db:"address" `
	AddressCountry  omit.Val[string]                             `db:"address_country" `
	AddressPostCode omit.Val[string]                             `db:"address_post_code" `
	AddressPlace    omit.Val[string]                             `db:"address_place" `
	AddressStreet   omit.Val[string]                             `db:"address_street" `
	AddressRegion   omit.Val[string]                             `db:"address_region" `
	Comments        omit.Val[string]                             `db:"comments" `
	Created         omit.Val[time.Time]                          `db:"created" `
	H3cell          omitnull.Val[string]                         `db:"h3cell" `
	HasAdult        omit.Val[bool]                               `db:"has_adult" `
	HasLarvae       omit.Val[bool]                               `db:"has_larvae" `
	HasPupae        omit.Val[bool]                               `db:"has_pupae" `
	Location        omitnull.Val[string]                         `db:"location" `
	MapZoom         omit.Val[float64]                            `db:"map_zoom" `
	OwnerEmail      omit.Val[string]                             `db:"owner_email" `
	OwnerName       omit.Val[string]                             `db:"owner_name" `
	OwnerPhone      omit.Val[string]                             `db:"owner_phone" `
	PublicID        omit.Val[string]                             `db:"public_id" `
	ReporterEmail   omit.Val[string]                             `db:"reporter_email" `
	ReporterName    omit.Val[string]                             `db:"reporter_name" `
	ReporterPhone   omit.Val[string]                             `db:"reporter_phone" `
	Subscribe       omit.Val[bool]                               `db:"subscribe" `
	Status          omit.Val[enums.PublicreportReportstatustype] `db:"status" `
}

func (s PublicreportPoolSetter) SetColumns() []string {
	vals := make([]string, 0, 30)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if s.AccessComments.IsValue() {
		vals = append(vals, "access_comments")
	}
	if s.AccessGate.IsValue() {
		vals = append(vals, "access_gate")
	}
	if s.AccessFence.IsValue() {
		vals = append(vals, "access_fence")
	}
	if s.AccessLocked.IsValue() {
		vals = append(vals, "access_locked")
	}
	if s.AccessDog.IsValue() {
		vals = append(vals, "access_dog")
	}
	if s.AccessOther.IsValue() {
		vals = append(vals, "access_other")
	}
	if s.Address.IsValue() {
		vals = append(vals, "address")
	}
	if s.AddressCountry.IsValue() {
		vals = append(vals, "address_country")
	}
	if s.AddressPostCode.IsValue() {
		vals = append(vals, "address_post_code")
	}
	if s.AddressPlace.IsValue() {
		vals = append(vals, "address_place")
	}
	if s.AddressStreet.IsValue() {
		vals = append(vals, "address_street")
	}
	if s.AddressRegion.IsValue() {
		vals = append(vals, "address_region")
	}
	if s.Comments.IsValue() {
		vals = append(vals, "comments")
	}
	if s.Created.IsValue() {
		vals = append(vals, "created")
	}
	if !s.H3cell.IsUnset() {
		vals = append(vals, "h3cell")
	}
	if s.HasAdult.IsValue() {
		vals = append(vals, "has_adult")
	}
	if s.HasLarvae.IsValue() {
		vals = append(vals, "has_larvae")
	}
	if s.HasPupae.IsValue() {
		vals = append(vals, "has_pupae")
	}
	if !s.Location.IsUnset() {
		vals = append(vals, "location")
	}
	if s.MapZoom.IsValue() {
		vals = append(vals, "map_zoom")
	}
	if s.OwnerEmail.IsValue() {
		vals = append(vals, "owner_email")
	}
	if s.OwnerName.IsValue() {
		vals = append(vals, "owner_name")
	}
	if s.OwnerPhone.IsValue() {
		vals = append(vals, "owner_phone")
	}
	if s.PublicID.IsValue() {
		vals = append(vals, "public_id")
	}
	if s.ReporterEmail.IsValue() {
		vals = append(vals, "reporter_email")
	}
	if s.ReporterName.IsValue() {
		vals = append(vals, "reporter_name")
	}
	if s.ReporterPhone.IsValue() {
		vals = append(vals, "reporter_phone")
	}
	if s.Subscribe.IsValue() {
		vals = append(vals, "subscribe")
	}
	if s.Status.IsValue() {
		vals = append(vals, "status")
	}
	return vals
}

func (s PublicreportPoolSetter) Overwrite(t *PublicreportPool) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if s.AccessComments.IsValue() {
		t.AccessComments = s.AccessComments.MustGet()
	}
	if s.AccessGate.IsValue() {
		t.AccessGate = s.AccessGate.MustGet()
	}
	if s.AccessFence.IsValue() {
		t.AccessFence = s.AccessFence.MustGet()
	}
	if s.AccessLocked.IsValue() {
		t.AccessLocked = s.AccessLocked.MustGet()
	}
	if s.AccessDog.IsValue() {
		t.AccessDog = s.AccessDog.MustGet()
	}
	if s.AccessOther.IsValue() {
		t.AccessOther = s.AccessOther.MustGet()
	}
	if s.Address.IsValue() {
		t.Address = s.Address.MustGet()
	}
	if s.AddressCountry.IsValue() {
		t.AddressCountry = s.AddressCountry.MustGet()
	}
	if s.AddressPostCode.IsValue() {
		t.AddressPostCode = s.AddressPostCode.MustGet()
	}
	if s.AddressPlace.IsValue() {
		t.AddressPlace = s.AddressPlace.MustGet()
	}
	if s.AddressStreet.IsValue() {
		t.AddressStreet = s.AddressStreet.MustGet()
	}
	if s.AddressRegion.IsValue() {
		t.AddressRegion = s.AddressRegion.MustGet()
	}
	if s.Comments.IsValue() {
		t.Comments = s.Comments.MustGet()
	}
	if s.Created.IsValue() {
		t.Created = s.Created.MustGet()
	}
	if !s.H3cell.IsUnset() {
		t.H3cell = s.H3cell.MustGetNull()
	}
	if s.HasAdult.IsValue() {
		t.HasAdult = s.HasAdult.MustGet()
	}
	if s.HasLarvae.IsValue() {
		t.HasLarvae = s.HasLarvae.MustGet()
	}
	if s.HasPupae.IsValue() {
		t.HasPupae = s.HasPupae.MustGet()
	}
	if !s.Location.IsUnset() {
		t.Location = s.Location.MustGetNull()
	}
	if s.MapZoom.IsValue() {
		t.MapZoom = s.MapZoom.MustGet()
	}
	if s.OwnerEmail.IsValue() {
		t.OwnerEmail = s.OwnerEmail.MustGet()
	}
	if s.OwnerName.IsValue() {
		t.OwnerName = s.OwnerName.MustGet()
	}
	if s.OwnerPhone.IsValue() {
		t.OwnerPhone = s.OwnerPhone.MustGet()
	}
	if s.PublicID.IsValue() {
		t.PublicID = s.PublicID.MustGet()
	}
	if s.ReporterEmail.IsValue() {
		t.ReporterEmail = s.ReporterEmail.MustGet()
	}
	if s.ReporterName.IsValue() {
		t.ReporterName = s.ReporterName.MustGet()
	}
	if s.ReporterPhone.IsValue() {
		t.ReporterPhone = s.ReporterPhone.MustGet()
	}
	if s.Subscribe.IsValue() {
		t.Subscribe = s.Subscribe.MustGet()
	}
	if s.Status.IsValue() {
		t.Status = s.Status.MustGet()
	}
}

func (s *PublicreportPoolSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return PublicreportPools.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 30)
		if s.ID.IsValue() {
			vals[0] = psql.Arg(s.ID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.AccessComments.IsValue() {
			vals[1] = psql.Arg(s.AccessComments.MustGet())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.AccessGate.IsValue() {
			vals[2] = psql.Arg(s.AccessGate.MustGet())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.AccessFence.IsValue() {
			vals[3] = psql.Arg(s.AccessFence.MustGet())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.AccessLocked.IsValue() {
			vals[4] = psql.Arg(s.AccessLocked.MustGet())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.AccessDog.IsValue() {
			vals[5] = psql.Arg(s.AccessDog.MustGet())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.AccessOther.IsValue() {
			vals[6] = psql.Arg(s.AccessOther.MustGet())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.Address.IsValue() {
			vals[7] = psql.Arg(s.Address.MustGet())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.AddressCountry.IsValue() {
			vals[8] = psql.Arg(s.AddressCountry.MustGet())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.AddressPostCode.IsValue() {
			vals[9] = psql.Arg(s.AddressPostCode.MustGet())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if s.AddressPlace.IsValue() {
			vals[10] = psql.Arg(s.AddressPlace.MustGet())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.AddressStreet.IsValue() {
			vals[11] = psql.Arg(s.AddressStreet.MustGet())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.AddressRegion.IsValue() {
			vals[12] = psql.Arg(s.AddressRegion.MustGet())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.Comments.IsValue() {
			vals[13] = psql.Arg(s.Comments.MustGet())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.Created.IsValue() {
			vals[14] = psql.Arg(s.Created.MustGet())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.H3cell.IsUnset() {
			vals[15] = psql.Arg(s.H3cell.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if s.HasAdult.IsValue() {
			vals[16] = psql.Arg(s.HasAdult.MustGet())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if s.HasLarvae.IsValue() {
			vals[17] = psql.Arg(s.HasLarvae.MustGet())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if s.HasPupae.IsValue() {
			vals[18] = psql.Arg(s.HasPupae.MustGet())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Location.IsUnset() {
			vals[19] = psql.Arg(s.Location.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if s.MapZoom.IsValue() {
			vals[20] = psql.Arg(s.MapZoom.MustGet())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if s.OwnerEmail.IsValue() {
			vals[21] = psql.Arg(s.OwnerEmail.MustGet())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if s.OwnerName.IsValue() {
			vals[22] = psql.Arg(s.OwnerName.MustGet())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if s.OwnerPhone.IsValue() {
			vals[23] = psql.Arg(s.OwnerPhone.MustGet())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if s.PublicID.IsValue() {
			vals[24] = psql.Arg(s.PublicID.MustGet())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if s.ReporterEmail.IsValue() {
			vals[25] = psql.Arg(s.ReporterEmail.MustGet())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if s.ReporterName.IsValue() {
			vals[26] = psql.Arg(s.ReporterName.MustGet())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if s.ReporterPhone.IsValue() {
			vals[27] = psql.Arg(s.ReporterPhone.MustGet())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if s.Subscribe.IsValue() {
			vals[28] = psql.Arg(s.Subscribe.MustGet())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if s.Status.IsValue() {
			vals[29] = psql.Arg(s.Status.MustGet())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s PublicreportPoolSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s PublicreportPoolSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 30)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if s.AccessComments.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "access_comments")...),
			psql.Arg(s.AccessComments),
		}})
	}

	if s.AccessGate.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "access_gate")...),
			psql.Arg(s.AccessGate),
		}})
	}

	if s.AccessFence.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "access_fence")...),
			psql.Arg(s.AccessFence),
		}})
	}

	if s.AccessLocked.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "access_locked")...),
			psql.Arg(s.AccessLocked),
		}})
	}

	if s.AccessDog.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "access_dog")...),
			psql.Arg(s.AccessDog),
		}})
	}

	if s.AccessOther.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "access_other")...),
			psql.Arg(s.AccessOther),
		}})
	}

	if s.Address.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address")...),
			psql.Arg(s.Address),
		}})
	}

	if s.AddressCountry.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_country")...),
			psql.Arg(s.AddressCountry),
		}})
	}

	if s.AddressPostCode.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_post_code")...),
			psql.Arg(s.AddressPostCode),
		}})
	}

	if s.AddressPlace.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_place")...),
			psql.Arg(s.AddressPlace),
		}})
	}

	if s.AddressStreet.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_street")...),
			psql.Arg(s.AddressStreet),
		}})
	}

	if s.AddressRegion.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address_region")...),
			psql.Arg(s.AddressRegion),
		}})
	}

	if s.Comments.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if s.Created.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created")...),
			psql.Arg(s.Created),
		}})
	}

	if !s.H3cell.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "h3cell")...),
			psql.Arg(s.H3cell),
		}})
	}

	if s.HasAdult.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "has_adult")...),
			psql.Arg(s.HasAdult),
		}})
	}

	if s.HasLarvae.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "has_larvae")...),
			psql.Arg(s.HasLarvae),
		}})
	}

	if s.HasPupae.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "has_pupae")...),
			psql.Arg(s.HasPupae),
		}})
	}

	if !s.Location.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "location")...),
			psql.Arg(s.Location),
		}})
	}

	if s.MapZoom.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "map_zoom")...),
			psql.Arg(s.MapZoom),
		}})
	}

	if s.OwnerEmail.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "owner_email")...),
			psql.Arg(s.OwnerEmail),
		}})
	}

	if s.OwnerName.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "owner_name")...),
			psql.Arg(s.OwnerName),
		}})
	}

	if s.OwnerPhone.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "owner_phone")...),
			psql.Arg(s.OwnerPhone),
		}})
	}

	if s.PublicID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "public_id")...),
			psql.Arg(s.PublicID),
		}})
	}

	if s.ReporterEmail.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_email")...),
			psql.Arg(s.ReporterEmail),
		}})
	}

	if s.ReporterName.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_name")...),
			psql.Arg(s.ReporterName),
		}})
	}

	if s.ReporterPhone.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reporter_phone")...),
			psql.Arg(s.ReporterPhone),
		}})
	}

	if s.Subscribe.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "subscribe")...),
			psql.Arg(s.Subscribe),
		}})
	}

	if s.Status.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "status")...),
			psql.Arg(s.Status),
		}})
	}

	return exprs
}

// FindPublicreportPool retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindPublicreportPool(ctx context.Context, exec bob.Executor, IDPK int32, cols ...string) (*PublicreportPool, error) {
	if len(cols) == 0 {
		return PublicreportPools.Query(
			sm.Where(PublicreportPools.Columns.ID.EQ(psql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return PublicreportPools.Query(
		sm.Where(PublicreportPools.Columns.ID.EQ(psql.Arg(IDPK))),
		sm.Columns(PublicreportPools.Columns.Only(cols...)),
	).One(ctx, exec)
}

// PublicreportPoolExists checks the presence of a single record by primary key
func PublicreportPoolExists(ctx context.Context, exec bob.Executor, IDPK int32) (bool, error) {
	return PublicreportPools.Query(
		sm.Where(PublicreportPools.Columns.ID.EQ(psql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after PublicreportPool is retrieved from the database
func (o *PublicreportPool) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = PublicreportPools.AfterSelectHooks.RunHooks(ctx, exec, PublicreportPoolSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = PublicreportPools.AfterInsertHooks.RunHooks(ctx, exec, PublicreportPoolSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = PublicreportPools.AfterUpdateHooks.RunHooks(ctx, exec, PublicreportPoolSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = PublicreportPools.AfterDeleteHooks.RunHooks(ctx, exec, PublicreportPoolSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the PublicreportPool
func (o *PublicreportPool) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *PublicreportPool) pkEQ() dialect.Expression {
	return psql.Quote("publicreport.pool", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the PublicreportPool
func (o *PublicreportPool) Update(ctx context.Context, exec bob.Executor, s *PublicreportPoolSetter) error {
	v, err := PublicreportPools.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single PublicreportPool record with an executor
func (o *PublicreportPool) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := PublicreportPools.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the PublicreportPool using the executor
func (o *PublicreportPool) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := PublicreportPools.Query(
		sm.Where(PublicreportPools.Columns.ID.EQ(psql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after PublicreportPoolSlice is retrieved from the database
func (o PublicreportPoolSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = PublicreportPools.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = PublicreportPools.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = PublicreportPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = PublicreportPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o PublicreportPoolSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("publicreport.pool", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o PublicreportPoolSlice) copyMatchingRows(from ...*PublicreportPool) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o PublicreportPoolSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return PublicreportPools.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *PublicreportPool:
				o.copyMatchingRows(retrieved)
			case []*PublicreportPool:
				o.copyMatchingRows(retrieved...)
			case PublicreportPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a PublicreportPool or a slice of PublicreportPool
				// then run the AfterUpdateHooks on the slice
				_, err = PublicreportPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o PublicreportPoolSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return PublicreportPools.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *PublicreportPool:
				o.copyMatchingRows(retrieved)
			case []*PublicreportPool:
				o.copyMatchingRows(retrieved...)
			case PublicreportPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a PublicreportPool or a slice of PublicreportPool
				// then run the AfterDeleteHooks on the slice
				_, err = PublicreportPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o PublicreportPoolSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals PublicreportPoolSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := PublicreportPools.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o PublicreportPoolSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := PublicreportPools.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o PublicreportPoolSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := PublicreportPools.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// PoolPhotos starts a query for related objects on publicreport.pool_photo
func (o *PublicreportPool) PoolPhotos(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportPoolPhotosQuery {
	return PublicreportPoolPhotos.Query(append(mods,
		sm.Where(PublicreportPoolPhotos.Columns.PoolID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os PublicreportPoolSlice) PoolPhotos(mods ...bob.Mod[*dialect.SelectQuery]) PublicreportPoolPhotosQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return PublicreportPoolPhotos.Query(append(mods,
		sm.Where(psql.Group(PublicreportPoolPhotos.Columns.PoolID).OP("IN", PKArgExpr)),
	)...)
}

func insertPublicreportPoolPoolPhotos0(ctx context.Context, exec bob.Executor, publicreportPoolPhotos1 []*PublicreportPoolPhotoSetter, publicreportPool0 *PublicreportPool) (PublicreportPoolPhotoSlice, error) {
	for i := range publicreportPoolPhotos1 {
		publicreportPoolPhotos1[i].PoolID = omit.From(publicreportPool0.ID)
	}

	ret, err := PublicreportPoolPhotos.Insert(bob.ToMods(publicreportPoolPhotos1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertPublicreportPoolPoolPhotos0: %w", err)
	}

	return ret, nil
}

func attachPublicreportPoolPoolPhotos0(ctx context.Context, exec bob.Executor, count int, publicreportPoolPhotos1 PublicreportPoolPhotoSlice, publicreportPool0 *PublicreportPool) (PublicreportPoolPhotoSlice, error) {
	setter := &PublicreportPoolPhotoSetter{
		PoolID: omit.From(publicreportPool0.ID),
	}

	err := publicreportPoolPhotos1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachPublicreportPoolPoolPhotos0: %w", err)
	}

	return publicreportPoolPhotos1, nil
}

func (publicreportPool0 *PublicreportPool) InsertPoolPhotos(ctx context.Context, exec bob.Executor, related ...*PublicreportPoolPhotoSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	publicreportPoolPhotos1, err := insertPublicreportPoolPoolPhotos0(ctx, exec, related, publicreportPool0)
	if err != nil {
		return err
	}

	publicreportPool0.R.PoolPhotos = append(publicreportPool0.R.PoolPhotos, publicreportPoolPhotos1...)

	for _, rel := range publicreportPoolPhotos1 {
		rel.R.Pool = publicreportPool0
	}
	return nil
}

func (publicreportPool0 *PublicreportPool) AttachPoolPhotos(ctx context.Context, exec bob.Executor, related ...*PublicreportPoolPhoto) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	publicreportPoolPhotos1 := PublicreportPoolPhotoSlice(related)

	_, err = attachPublicreportPoolPoolPhotos0(ctx, exec, len(related), publicreportPoolPhotos1, publicreportPool0)
	if err != nil {
		return err
	}

	publicreportPool0.R.PoolPhotos = append(publicreportPool0.R.PoolPhotos, publicreportPoolPhotos1...)

	for _, rel := range related {
		rel.R.Pool = publicreportPool0
	}

	return nil
}

type publicreportPoolWhere[Q psql.Filterable] struct {
	ID              psql.WhereMod[Q, int32]
	AccessComments  psql.WhereMod[Q, string]
	AccessGate      psql.WhereMod[Q, bool]
	AccessFence     psql.WhereMod[Q, bool]
	AccessLocked    psql.WhereMod[Q, bool]
	AccessDog       psql.WhereMod[Q, bool]
	AccessOther     psql.WhereMod[Q, bool]
	Address         psql.WhereMod[Q, string]
	AddressCountry  psql.WhereMod[Q, string]
	AddressPostCode psql.WhereMod[Q, string]
	AddressPlace    psql.WhereMod[Q, string]
	AddressStreet   psql.WhereMod[Q, string]
	AddressRegion   psql.WhereMod[Q, string]
	Comments        psql.WhereMod[Q, string]
	Created         psql.WhereMod[Q, time.Time]
	H3cell          psql.WhereNullMod[Q, string]
	HasAdult        psql.WhereMod[Q, bool]
	HasLarvae       psql.WhereMod[Q, bool]
	HasPupae        psql.WhereMod[Q, bool]
	Location        psql.WhereNullMod[Q, string]
	MapZoom         psql.WhereMod[Q, float64]
	OwnerEmail      psql.WhereMod[Q, string]
	OwnerName       psql.WhereMod[Q, string]
	OwnerPhone      psql.WhereMod[Q, string]
	PublicID        psql.WhereMod[Q, string]
	ReporterEmail   psql.WhereMod[Q, string]
	ReporterName    psql.WhereMod[Q, string]
	ReporterPhone   psql.WhereMod[Q, string]
	Subscribe       psql.WhereMod[Q, bool]
	Status          psql.WhereMod[Q, enums.PublicreportReportstatustype]
}

func (publicreportPoolWhere[Q]) AliasedAs(alias string) publicreportPoolWhere[Q] {
	return buildPublicreportPoolWhere[Q](buildPublicreportPoolColumns(alias))
}

func buildPublicreportPoolWhere[Q psql.Filterable](cols publicreportPoolColumns) publicreportPoolWhere[Q] {
	return publicreportPoolWhere[Q]{
		ID:              psql.Where[Q, int32](cols.ID),
		AccessComments:  psql.Where[Q, string](cols.AccessComments),
		AccessGate:      psql.Where[Q, bool](cols.AccessGate),
		AccessFence:     psql.Where[Q, bool](cols.AccessFence),
		AccessLocked:    psql.Where[Q, bool](cols.AccessLocked),
		AccessDog:       psql.Where[Q, bool](cols.AccessDog),
		AccessOther:     psql.Where[Q, bool](cols.AccessOther),
		Address:         psql.Where[Q, string](cols.Address),
		AddressCountry:  psql.Where[Q, string](cols.AddressCountry),
		AddressPostCode: psql.Where[Q, string](cols.AddressPostCode),
		AddressPlace:    psql.Where[Q, string](cols.AddressPlace),
		AddressStreet:   psql.Where[Q, string](cols.AddressStreet),
		AddressRegion:   psql.Where[Q, string](cols.AddressRegion),
		Comments:        psql.Where[Q, string](cols.Comments),
		Created:         psql.Where[Q, time.Time](cols.Created),
		H3cell:          psql.WhereNull[Q, string](cols.H3cell),
		HasAdult:        psql.Where[Q, bool](cols.HasAdult),
		HasLarvae:       psql.Where[Q, bool](cols.HasLarvae),
		HasPupae:        psql.Where[Q, bool](cols.HasPupae),
		Location:        psql.WhereNull[Q, string](cols.Location),
		MapZoom:         psql.Where[Q, float64](cols.MapZoom),
		OwnerEmail:      psql.Where[Q, string](cols.OwnerEmail),
		OwnerName:       psql.Where[Q, string](cols.OwnerName),
		OwnerPhone:      psql.Where[Q, string](cols.OwnerPhone),
		PublicID:        psql.Where[Q, string](cols.PublicID),
		ReporterEmail:   psql.Where[Q, string](cols.ReporterEmail),
		ReporterName:    psql.Where[Q, string](cols.ReporterName),
		ReporterPhone:   psql.Where[Q, string](cols.ReporterPhone),
		Subscribe:       psql.Where[Q, bool](cols.Subscribe),
		Status:          psql.Where[Q, enums.PublicreportReportstatustype](cols.Status),
	}
}

func (o *PublicreportPool) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "PoolPhotos":
		rels, ok := retrieved.(PublicreportPoolPhotoSlice)
		if !ok {
			return fmt.Errorf("publicreportPool cannot load %T as %q", retrieved, name)
		}

		o.R.PoolPhotos = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Pool = o
			}
		}
		return nil
	default:
		return fmt.Errorf("publicreportPool has no relationship %q", name)
	}
}

type publicreportPoolPreloader struct{}

func buildPublicreportPoolPreloader() publicreportPoolPreloader {
	return publicreportPoolPreloader{}
}

type publicreportPoolThenLoader[Q orm.Loadable] struct {
	PoolPhotos func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildPublicreportPoolThenLoader[Q orm.Loadable]() publicreportPoolThenLoader[Q] {
	type PoolPhotosLoadInterface interface {
		LoadPoolPhotos(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return publicreportPoolThenLoader[Q]{
		PoolPhotos: thenLoadBuilder[Q](
			"PoolPhotos",
			func(ctx context.Context, exec bob.Executor, retrieved PoolPhotosLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPoolPhotos(ctx, exec, mods...)
			},
		),
	}
}

// LoadPoolPhotos loads the publicreportPool's PoolPhotos into the .R struct
func (o *PublicreportPool) LoadPoolPhotos(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.PoolPhotos = nil

	related, err := o.PoolPhotos(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Pool = o
	}

	o.R.PoolPhotos = related
	return nil
}

// LoadPoolPhotos loads the publicreportPool's PoolPhotos into the .R struct
func (os PublicreportPoolSlice) LoadPoolPhotos(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	publicreportPoolPhotos, err := os.PoolPhotos(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.PoolPhotos = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range publicreportPoolPhotos {

			if !(o.ID == rel.PoolID) {
				continue
			}

			rel.R.Pool = o

			o.R.PoolPhotos = append(o.R.PoolPhotos, rel)
		}
	}

	return nil
}

type publicreportPoolJoins[Q dialect.Joinable] struct {
	typ        string
	PoolPhotos modAs[Q, publicreportPoolPhotoColumns]
}

func (j publicreportPoolJoins[Q]) aliasedAs(alias string) publicreportPoolJoins[Q] {
	return buildPublicreportPoolJoins[Q](buildPublicreportPoolColumns(alias), j.typ)
}

func buildPublicreportPoolJoins[Q dialect.Joinable](cols publicreportPoolColumns, typ string) publicreportPoolJoins[Q] {
	return publicreportPoolJoins[Q]{
		typ: typ,
		PoolPhotos: modAs[Q, publicreportPoolPhotoColumns]{
			c: PublicreportPoolPhotos.Columns,
			f: func(to publicreportPoolPhotoColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, PublicreportPoolPhotos.Name().As(to.Alias())).On(
						to.PoolID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
	}
}
