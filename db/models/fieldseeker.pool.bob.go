// Code generated by BobGen psql v0.0.3-0.20251202003046-49148fc66a73+dirty. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"io"
	"time"

	enums "github.com/Gleipnir-Technology/nidus-sync/db/enums"
	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/gofrs/uuid/v5"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
)

// FieldseekerPool is an object representing the database table.
type FieldseekerPool struct {
	Objectid int64 `db:"objectid,pk" `
	// Trap Data ID
	TrapdataID null.Val[uuid.UUID] `db:"trapdata_id" `
	// Date Sent
	Datesent null.Val[time.Time] `db:"datesent" `
	// Survey Tech
	Survtech null.Val[string] `db:"survtech" `
	// Date Tested
	Datetested null.Val[time.Time] `db:"datetested" `
	// Test Tech
	Testtech null.Val[string] `db:"testtech" `
	// Comments
	Comments null.Val[string] `db:"comments" `
	// Sample ID
	Sampleid null.Val[string] `db:"sampleid" `
	// Processed
	Processed null.Val[enums.FieldseekerPoolNotinuitFEnum] `db:"processed" `
	LabID     null.Val[uuid.UUID]                          `db:"lab_id" `
	// Test Methods
	Testmethod null.Val[enums.FieldseekerPoolPoolTestmethod670efbfba86d41ba8e2d3cab5d749e7fEnum] `db:"testmethod" `
	// Diseases Tested
	Diseasetested null.Val[enums.FieldseekerPoolPoolDiseasetested0f02232949c04c7e8de820b9b515ed97Enum] `db:"diseasetested" `
	// Diseases Positive
	Diseasepos     null.Val[enums.FieldseekerPoolPoolDiseasepos6889f8dd00074874aa726907e78497faEnum] `db:"diseasepos" `
	Globalid       null.Val[uuid.UUID]                                                               `db:"globalid" `
	CreatedUser    null.Val[string]                                                                  `db:"created_user" `
	CreatedDate    null.Val[time.Time]                                                               `db:"created_date" `
	LastEditedUser null.Val[string]                                                                  `db:"last_edited_user" `
	LastEditedDate null.Val[time.Time]                                                               `db:"last_edited_date" `
	Lab            null.Val[enums.FieldseekerPoolMosquitolabnameEnum]                                `db:"lab" `
	// Pool Year
	Poolyear null.Val[int16] `db:"poolyear" `
	// Gateway Sync
	Gatewaysync            null.Val[int16]     `db:"gatewaysync" `
	Vectorsurvcollectionid null.Val[string]    `db:"vectorsurvcollectionid" `
	Vectorsurvpoolid       null.Val[string]    `db:"vectorsurvpoolid" `
	Vectorsurvtrapdataid   null.Val[string]    `db:"vectorsurvtrapdataid" `
	Creationdate           null.Val[time.Time] `db:"creationdate" `
	Creator                null.Val[string]    `db:"creator" `
	Editdate               null.Val[time.Time] `db:"editdate" `
	Editor                 null.Val[string]    `db:"editor" `
	// Tracks version changes to the row. Increases when data is modified.
	Version int32 `db:"version,pk" `
}

// FieldseekerPoolSlice is an alias for a slice of pointers to FieldseekerPool.
// This should almost always be used instead of []*FieldseekerPool.
type FieldseekerPoolSlice []*FieldseekerPool

// FieldseekerPools contains methods to work with the pool table
var FieldseekerPools = psql.NewTablex[*FieldseekerPool, FieldseekerPoolSlice, *FieldseekerPoolSetter]("fieldseeker", "pool", buildFieldseekerPoolColumns("fieldseeker.pool"))

// FieldseekerPoolsQuery is a query on the pool table
type FieldseekerPoolsQuery = *psql.ViewQuery[*FieldseekerPool, FieldseekerPoolSlice]

func buildFieldseekerPoolColumns(alias string) fieldseekerPoolColumns {
	return fieldseekerPoolColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"objectid", "trapdata_id", "datesent", "survtech", "datetested", "testtech", "comments", "sampleid", "processed", "lab_id", "testmethod", "diseasetested", "diseasepos", "globalid", "created_user", "created_date", "last_edited_user", "last_edited_date", "lab", "poolyear", "gatewaysync", "vectorsurvcollectionid", "vectorsurvpoolid", "vectorsurvtrapdataid", "creationdate", "creator", "editdate", "editor", "version",
		).WithParent("fieldseeker.pool"),
		tableAlias:             alias,
		Objectid:               psql.Quote(alias, "objectid"),
		TrapdataID:             psql.Quote(alias, "trapdata_id"),
		Datesent:               psql.Quote(alias, "datesent"),
		Survtech:               psql.Quote(alias, "survtech"),
		Datetested:             psql.Quote(alias, "datetested"),
		Testtech:               psql.Quote(alias, "testtech"),
		Comments:               psql.Quote(alias, "comments"),
		Sampleid:               psql.Quote(alias, "sampleid"),
		Processed:              psql.Quote(alias, "processed"),
		LabID:                  psql.Quote(alias, "lab_id"),
		Testmethod:             psql.Quote(alias, "testmethod"),
		Diseasetested:          psql.Quote(alias, "diseasetested"),
		Diseasepos:             psql.Quote(alias, "diseasepos"),
		Globalid:               psql.Quote(alias, "globalid"),
		CreatedUser:            psql.Quote(alias, "created_user"),
		CreatedDate:            psql.Quote(alias, "created_date"),
		LastEditedUser:         psql.Quote(alias, "last_edited_user"),
		LastEditedDate:         psql.Quote(alias, "last_edited_date"),
		Lab:                    psql.Quote(alias, "lab"),
		Poolyear:               psql.Quote(alias, "poolyear"),
		Gatewaysync:            psql.Quote(alias, "gatewaysync"),
		Vectorsurvcollectionid: psql.Quote(alias, "vectorsurvcollectionid"),
		Vectorsurvpoolid:       psql.Quote(alias, "vectorsurvpoolid"),
		Vectorsurvtrapdataid:   psql.Quote(alias, "vectorsurvtrapdataid"),
		Creationdate:           psql.Quote(alias, "creationdate"),
		Creator:                psql.Quote(alias, "creator"),
		Editdate:               psql.Quote(alias, "editdate"),
		Editor:                 psql.Quote(alias, "editor"),
		Version:                psql.Quote(alias, "version"),
	}
}

type fieldseekerPoolColumns struct {
	expr.ColumnsExpr
	tableAlias             string
	Objectid               psql.Expression
	TrapdataID             psql.Expression
	Datesent               psql.Expression
	Survtech               psql.Expression
	Datetested             psql.Expression
	Testtech               psql.Expression
	Comments               psql.Expression
	Sampleid               psql.Expression
	Processed              psql.Expression
	LabID                  psql.Expression
	Testmethod             psql.Expression
	Diseasetested          psql.Expression
	Diseasepos             psql.Expression
	Globalid               psql.Expression
	CreatedUser            psql.Expression
	CreatedDate            psql.Expression
	LastEditedUser         psql.Expression
	LastEditedDate         psql.Expression
	Lab                    psql.Expression
	Poolyear               psql.Expression
	Gatewaysync            psql.Expression
	Vectorsurvcollectionid psql.Expression
	Vectorsurvpoolid       psql.Expression
	Vectorsurvtrapdataid   psql.Expression
	Creationdate           psql.Expression
	Creator                psql.Expression
	Editdate               psql.Expression
	Editor                 psql.Expression
	Version                psql.Expression
}

func (c fieldseekerPoolColumns) Alias() string {
	return c.tableAlias
}

func (fieldseekerPoolColumns) AliasedAs(alias string) fieldseekerPoolColumns {
	return buildFieldseekerPoolColumns(alias)
}

// FieldseekerPoolSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type FieldseekerPoolSetter struct {
	Objectid               omit.Val[int64]                                                                          `db:"objectid,pk" `
	TrapdataID             omitnull.Val[uuid.UUID]                                                                  `db:"trapdata_id" `
	Datesent               omitnull.Val[time.Time]                                                                  `db:"datesent" `
	Survtech               omitnull.Val[string]                                                                     `db:"survtech" `
	Datetested             omitnull.Val[time.Time]                                                                  `db:"datetested" `
	Testtech               omitnull.Val[string]                                                                     `db:"testtech" `
	Comments               omitnull.Val[string]                                                                     `db:"comments" `
	Sampleid               omitnull.Val[string]                                                                     `db:"sampleid" `
	Processed              omitnull.Val[enums.FieldseekerPoolNotinuitFEnum]                                         `db:"processed" `
	LabID                  omitnull.Val[uuid.UUID]                                                                  `db:"lab_id" `
	Testmethod             omitnull.Val[enums.FieldseekerPoolPoolTestmethod670efbfba86d41ba8e2d3cab5d749e7fEnum]    `db:"testmethod" `
	Diseasetested          omitnull.Val[enums.FieldseekerPoolPoolDiseasetested0f02232949c04c7e8de820b9b515ed97Enum] `db:"diseasetested" `
	Diseasepos             omitnull.Val[enums.FieldseekerPoolPoolDiseasepos6889f8dd00074874aa726907e78497faEnum]    `db:"diseasepos" `
	Globalid               omitnull.Val[uuid.UUID]                                                                  `db:"globalid" `
	CreatedUser            omitnull.Val[string]                                                                     `db:"created_user" `
	CreatedDate            omitnull.Val[time.Time]                                                                  `db:"created_date" `
	LastEditedUser         omitnull.Val[string]                                                                     `db:"last_edited_user" `
	LastEditedDate         omitnull.Val[time.Time]                                                                  `db:"last_edited_date" `
	Lab                    omitnull.Val[enums.FieldseekerPoolMosquitolabnameEnum]                                   `db:"lab" `
	Poolyear               omitnull.Val[int16]                                                                      `db:"poolyear" `
	Gatewaysync            omitnull.Val[int16]                                                                      `db:"gatewaysync" `
	Vectorsurvcollectionid omitnull.Val[string]                                                                     `db:"vectorsurvcollectionid" `
	Vectorsurvpoolid       omitnull.Val[string]                                                                     `db:"vectorsurvpoolid" `
	Vectorsurvtrapdataid   omitnull.Val[string]                                                                     `db:"vectorsurvtrapdataid" `
	Creationdate           omitnull.Val[time.Time]                                                                  `db:"creationdate" `
	Creator                omitnull.Val[string]                                                                     `db:"creator" `
	Editdate               omitnull.Val[time.Time]                                                                  `db:"editdate" `
	Editor                 omitnull.Val[string]                                                                     `db:"editor" `
	Version                omit.Val[int32]                                                                          `db:"version,pk" `
}

func (s FieldseekerPoolSetter) SetColumns() []string {
	vals := make([]string, 0, 29)
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.TrapdataID.IsUnset() {
		vals = append(vals, "trapdata_id")
	}
	if !s.Datesent.IsUnset() {
		vals = append(vals, "datesent")
	}
	if !s.Survtech.IsUnset() {
		vals = append(vals, "survtech")
	}
	if !s.Datetested.IsUnset() {
		vals = append(vals, "datetested")
	}
	if !s.Testtech.IsUnset() {
		vals = append(vals, "testtech")
	}
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Sampleid.IsUnset() {
		vals = append(vals, "sampleid")
	}
	if !s.Processed.IsUnset() {
		vals = append(vals, "processed")
	}
	if !s.LabID.IsUnset() {
		vals = append(vals, "lab_id")
	}
	if !s.Testmethod.IsUnset() {
		vals = append(vals, "testmethod")
	}
	if !s.Diseasetested.IsUnset() {
		vals = append(vals, "diseasetested")
	}
	if !s.Diseasepos.IsUnset() {
		vals = append(vals, "diseasepos")
	}
	if !s.Globalid.IsUnset() {
		vals = append(vals, "globalid")
	}
	if !s.CreatedUser.IsUnset() {
		vals = append(vals, "created_user")
	}
	if !s.CreatedDate.IsUnset() {
		vals = append(vals, "created_date")
	}
	if !s.LastEditedUser.IsUnset() {
		vals = append(vals, "last_edited_user")
	}
	if !s.LastEditedDate.IsUnset() {
		vals = append(vals, "last_edited_date")
	}
	if !s.Lab.IsUnset() {
		vals = append(vals, "lab")
	}
	if !s.Poolyear.IsUnset() {
		vals = append(vals, "poolyear")
	}
	if !s.Gatewaysync.IsUnset() {
		vals = append(vals, "gatewaysync")
	}
	if !s.Vectorsurvcollectionid.IsUnset() {
		vals = append(vals, "vectorsurvcollectionid")
	}
	if !s.Vectorsurvpoolid.IsUnset() {
		vals = append(vals, "vectorsurvpoolid")
	}
	if !s.Vectorsurvtrapdataid.IsUnset() {
		vals = append(vals, "vectorsurvtrapdataid")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if s.Version.IsValue() {
		vals = append(vals, "version")
	}
	return vals
}

func (s FieldseekerPoolSetter) Overwrite(t *FieldseekerPool) {
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.TrapdataID.IsUnset() {
		t.TrapdataID = s.TrapdataID.MustGetNull()
	}
	if !s.Datesent.IsUnset() {
		t.Datesent = s.Datesent.MustGetNull()
	}
	if !s.Survtech.IsUnset() {
		t.Survtech = s.Survtech.MustGetNull()
	}
	if !s.Datetested.IsUnset() {
		t.Datetested = s.Datetested.MustGetNull()
	}
	if !s.Testtech.IsUnset() {
		t.Testtech = s.Testtech.MustGetNull()
	}
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Sampleid.IsUnset() {
		t.Sampleid = s.Sampleid.MustGetNull()
	}
	if !s.Processed.IsUnset() {
		t.Processed = s.Processed.MustGetNull()
	}
	if !s.LabID.IsUnset() {
		t.LabID = s.LabID.MustGetNull()
	}
	if !s.Testmethod.IsUnset() {
		t.Testmethod = s.Testmethod.MustGetNull()
	}
	if !s.Diseasetested.IsUnset() {
		t.Diseasetested = s.Diseasetested.MustGetNull()
	}
	if !s.Diseasepos.IsUnset() {
		t.Diseasepos = s.Diseasepos.MustGetNull()
	}
	if !s.Globalid.IsUnset() {
		t.Globalid = s.Globalid.MustGetNull()
	}
	if !s.CreatedUser.IsUnset() {
		t.CreatedUser = s.CreatedUser.MustGetNull()
	}
	if !s.CreatedDate.IsUnset() {
		t.CreatedDate = s.CreatedDate.MustGetNull()
	}
	if !s.LastEditedUser.IsUnset() {
		t.LastEditedUser = s.LastEditedUser.MustGetNull()
	}
	if !s.LastEditedDate.IsUnset() {
		t.LastEditedDate = s.LastEditedDate.MustGetNull()
	}
	if !s.Lab.IsUnset() {
		t.Lab = s.Lab.MustGetNull()
	}
	if !s.Poolyear.IsUnset() {
		t.Poolyear = s.Poolyear.MustGetNull()
	}
	if !s.Gatewaysync.IsUnset() {
		t.Gatewaysync = s.Gatewaysync.MustGetNull()
	}
	if !s.Vectorsurvcollectionid.IsUnset() {
		t.Vectorsurvcollectionid = s.Vectorsurvcollectionid.MustGetNull()
	}
	if !s.Vectorsurvpoolid.IsUnset() {
		t.Vectorsurvpoolid = s.Vectorsurvpoolid.MustGetNull()
	}
	if !s.Vectorsurvtrapdataid.IsUnset() {
		t.Vectorsurvtrapdataid = s.Vectorsurvtrapdataid.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if s.Version.IsValue() {
		t.Version = s.Version.MustGet()
	}
}

func (s *FieldseekerPoolSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return FieldseekerPools.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 29)
		if s.Objectid.IsValue() {
			vals[0] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.TrapdataID.IsUnset() {
			vals[1] = psql.Arg(s.TrapdataID.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Datesent.IsUnset() {
			vals[2] = psql.Arg(s.Datesent.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Survtech.IsUnset() {
			vals[3] = psql.Arg(s.Survtech.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Datetested.IsUnset() {
			vals[4] = psql.Arg(s.Datetested.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Testtech.IsUnset() {
			vals[5] = psql.Arg(s.Testtech.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Comments.IsUnset() {
			vals[6] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Sampleid.IsUnset() {
			vals[7] = psql.Arg(s.Sampleid.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Processed.IsUnset() {
			vals[8] = psql.Arg(s.Processed.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.LabID.IsUnset() {
			vals[9] = psql.Arg(s.LabID.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Testmethod.IsUnset() {
			vals[10] = psql.Arg(s.Testmethod.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.Diseasetested.IsUnset() {
			vals[11] = psql.Arg(s.Diseasetested.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.Diseasepos.IsUnset() {
			vals[12] = psql.Arg(s.Diseasepos.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Globalid.IsUnset() {
			vals[13] = psql.Arg(s.Globalid.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.CreatedUser.IsUnset() {
			vals[14] = psql.Arg(s.CreatedUser.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.CreatedDate.IsUnset() {
			vals[15] = psql.Arg(s.CreatedDate.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedUser.IsUnset() {
			vals[16] = psql.Arg(s.LastEditedUser.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedDate.IsUnset() {
			vals[17] = psql.Arg(s.LastEditedDate.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Lab.IsUnset() {
			vals[18] = psql.Arg(s.Lab.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Poolyear.IsUnset() {
			vals[19] = psql.Arg(s.Poolyear.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.Gatewaysync.IsUnset() {
			vals[20] = psql.Arg(s.Gatewaysync.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvcollectionid.IsUnset() {
			vals[21] = psql.Arg(s.Vectorsurvcollectionid.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvpoolid.IsUnset() {
			vals[22] = psql.Arg(s.Vectorsurvpoolid.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvtrapdataid.IsUnset() {
			vals[23] = psql.Arg(s.Vectorsurvtrapdataid.MustGetNull())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[24] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[25] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[26] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[27] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if s.Version.IsValue() {
			vals[28] = psql.Arg(s.Version.MustGet())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s FieldseekerPoolSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s FieldseekerPoolSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 29)

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.TrapdataID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "trapdata_id")...),
			psql.Arg(s.TrapdataID),
		}})
	}

	if !s.Datesent.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datesent")...),
			psql.Arg(s.Datesent),
		}})
	}

	if !s.Survtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "survtech")...),
			psql.Arg(s.Survtech),
		}})
	}

	if !s.Datetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datetested")...),
			psql.Arg(s.Datetested),
		}})
	}

	if !s.Testtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testtech")...),
			psql.Arg(s.Testtech),
		}})
	}

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Sampleid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sampleid")...),
			psql.Arg(s.Sampleid),
		}})
	}

	if !s.Processed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "processed")...),
			psql.Arg(s.Processed),
		}})
	}

	if !s.LabID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lab_id")...),
			psql.Arg(s.LabID),
		}})
	}

	if !s.Testmethod.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testmethod")...),
			psql.Arg(s.Testmethod),
		}})
	}

	if !s.Diseasetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasetested")...),
			psql.Arg(s.Diseasetested),
		}})
	}

	if !s.Diseasepos.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasepos")...),
			psql.Arg(s.Diseasepos),
		}})
	}

	if !s.Globalid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.CreatedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_user")...),
			psql.Arg(s.CreatedUser),
		}})
	}

	if !s.CreatedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_date")...),
			psql.Arg(s.CreatedDate),
		}})
	}

	if !s.LastEditedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_user")...),
			psql.Arg(s.LastEditedUser),
		}})
	}

	if !s.LastEditedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_date")...),
			psql.Arg(s.LastEditedDate),
		}})
	}

	if !s.Lab.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lab")...),
			psql.Arg(s.Lab),
		}})
	}

	if !s.Poolyear.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "poolyear")...),
			psql.Arg(s.Poolyear),
		}})
	}

	if !s.Gatewaysync.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "gatewaysync")...),
			psql.Arg(s.Gatewaysync),
		}})
	}

	if !s.Vectorsurvcollectionid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvcollectionid")...),
			psql.Arg(s.Vectorsurvcollectionid),
		}})
	}

	if !s.Vectorsurvpoolid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvpoolid")...),
			psql.Arg(s.Vectorsurvpoolid),
		}})
	}

	if !s.Vectorsurvtrapdataid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvtrapdataid")...),
			psql.Arg(s.Vectorsurvtrapdataid),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if s.Version.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "version")...),
			psql.Arg(s.Version),
		}})
	}

	return exprs
}

// FindFieldseekerPool retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindFieldseekerPool(ctx context.Context, exec bob.Executor, ObjectidPK int64, VersionPK int32, cols ...string) (*FieldseekerPool, error) {
	if len(cols) == 0 {
		return FieldseekerPools.Query(
			sm.Where(FieldseekerPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
			sm.Where(FieldseekerPools.Columns.Version.EQ(psql.Arg(VersionPK))),
		).One(ctx, exec)
	}

	return FieldseekerPools.Query(
		sm.Where(FieldseekerPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Where(FieldseekerPools.Columns.Version.EQ(psql.Arg(VersionPK))),
		sm.Columns(FieldseekerPools.Columns.Only(cols...)),
	).One(ctx, exec)
}

// FieldseekerPoolExists checks the presence of a single record by primary key
func FieldseekerPoolExists(ctx context.Context, exec bob.Executor, ObjectidPK int64, VersionPK int32) (bool, error) {
	return FieldseekerPools.Query(
		sm.Where(FieldseekerPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Where(FieldseekerPools.Columns.Version.EQ(psql.Arg(VersionPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after FieldseekerPool is retrieved from the database
func (o *FieldseekerPool) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FieldseekerPools.AfterSelectHooks.RunHooks(ctx, exec, FieldseekerPoolSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = FieldseekerPools.AfterInsertHooks.RunHooks(ctx, exec, FieldseekerPoolSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = FieldseekerPools.AfterUpdateHooks.RunHooks(ctx, exec, FieldseekerPoolSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = FieldseekerPools.AfterDeleteHooks.RunHooks(ctx, exec, FieldseekerPoolSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the FieldseekerPool
func (o *FieldseekerPool) primaryKeyVals() bob.Expression {
	return psql.ArgGroup(
		o.Objectid,
		o.Version,
	)
}

func (o *FieldseekerPool) pkEQ() dialect.Expression {
	return psql.Group(psql.Quote("fieldseeker.pool", "objectid"), psql.Quote("fieldseeker.pool", "version")).EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the FieldseekerPool
func (o *FieldseekerPool) Update(ctx context.Context, exec bob.Executor, s *FieldseekerPoolSetter) error {
	v, err := FieldseekerPools.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	*o = *v

	return nil
}

// Delete deletes a single FieldseekerPool record with an executor
func (o *FieldseekerPool) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := FieldseekerPools.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the FieldseekerPool using the executor
func (o *FieldseekerPool) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := FieldseekerPools.Query(
		sm.Where(FieldseekerPools.Columns.Objectid.EQ(psql.Arg(o.Objectid))),
		sm.Where(FieldseekerPools.Columns.Version.EQ(psql.Arg(o.Version))),
	).One(ctx, exec)
	if err != nil {
		return err
	}

	*o = *o2

	return nil
}

// AfterQueryHook is called after FieldseekerPoolSlice is retrieved from the database
func (o FieldseekerPoolSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FieldseekerPools.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = FieldseekerPools.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = FieldseekerPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = FieldseekerPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o FieldseekerPoolSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Group(psql.Quote("fieldseeker.pool", "objectid"), psql.Quote("fieldseeker.pool", "version")).In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o FieldseekerPoolSlice) copyMatchingRows(from ...*FieldseekerPool) {
	for i, old := range o {
		for _, new := range from {
			if new.Objectid != old.Objectid {
				continue
			}
			if new.Version != old.Version {
				continue
			}

			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o FieldseekerPoolSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FieldseekerPools.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FieldseekerPool:
				o.copyMatchingRows(retrieved)
			case []*FieldseekerPool:
				o.copyMatchingRows(retrieved...)
			case FieldseekerPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FieldseekerPool or a slice of FieldseekerPool
				// then run the AfterUpdateHooks on the slice
				_, err = FieldseekerPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o FieldseekerPoolSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FieldseekerPools.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FieldseekerPool:
				o.copyMatchingRows(retrieved)
			case []*FieldseekerPool:
				o.copyMatchingRows(retrieved...)
			case FieldseekerPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FieldseekerPool or a slice of FieldseekerPool
				// then run the AfterDeleteHooks on the slice
				_, err = FieldseekerPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o FieldseekerPoolSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals FieldseekerPoolSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FieldseekerPools.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o FieldseekerPoolSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FieldseekerPools.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o FieldseekerPoolSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := FieldseekerPools.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type fieldseekerPoolWhere[Q psql.Filterable] struct {
	Objectid               psql.WhereMod[Q, int64]
	TrapdataID             psql.WhereNullMod[Q, uuid.UUID]
	Datesent               psql.WhereNullMod[Q, time.Time]
	Survtech               psql.WhereNullMod[Q, string]
	Datetested             psql.WhereNullMod[Q, time.Time]
	Testtech               psql.WhereNullMod[Q, string]
	Comments               psql.WhereNullMod[Q, string]
	Sampleid               psql.WhereNullMod[Q, string]
	Processed              psql.WhereNullMod[Q, enums.FieldseekerPoolNotinuitFEnum]
	LabID                  psql.WhereNullMod[Q, uuid.UUID]
	Testmethod             psql.WhereNullMod[Q, enums.FieldseekerPoolPoolTestmethod670efbfba86d41ba8e2d3cab5d749e7fEnum]
	Diseasetested          psql.WhereNullMod[Q, enums.FieldseekerPoolPoolDiseasetested0f02232949c04c7e8de820b9b515ed97Enum]
	Diseasepos             psql.WhereNullMod[Q, enums.FieldseekerPoolPoolDiseasepos6889f8dd00074874aa726907e78497faEnum]
	Globalid               psql.WhereNullMod[Q, uuid.UUID]
	CreatedUser            psql.WhereNullMod[Q, string]
	CreatedDate            psql.WhereNullMod[Q, time.Time]
	LastEditedUser         psql.WhereNullMod[Q, string]
	LastEditedDate         psql.WhereNullMod[Q, time.Time]
	Lab                    psql.WhereNullMod[Q, enums.FieldseekerPoolMosquitolabnameEnum]
	Poolyear               psql.WhereNullMod[Q, int16]
	Gatewaysync            psql.WhereNullMod[Q, int16]
	Vectorsurvcollectionid psql.WhereNullMod[Q, string]
	Vectorsurvpoolid       psql.WhereNullMod[Q, string]
	Vectorsurvtrapdataid   psql.WhereNullMod[Q, string]
	Creationdate           psql.WhereNullMod[Q, time.Time]
	Creator                psql.WhereNullMod[Q, string]
	Editdate               psql.WhereNullMod[Q, time.Time]
	Editor                 psql.WhereNullMod[Q, string]
	Version                psql.WhereMod[Q, int32]
}

func (fieldseekerPoolWhere[Q]) AliasedAs(alias string) fieldseekerPoolWhere[Q] {
	return buildFieldseekerPoolWhere[Q](buildFieldseekerPoolColumns(alias))
}

func buildFieldseekerPoolWhere[Q psql.Filterable](cols fieldseekerPoolColumns) fieldseekerPoolWhere[Q] {
	return fieldseekerPoolWhere[Q]{
		Objectid:               psql.Where[Q, int64](cols.Objectid),
		TrapdataID:             psql.WhereNull[Q, uuid.UUID](cols.TrapdataID),
		Datesent:               psql.WhereNull[Q, time.Time](cols.Datesent),
		Survtech:               psql.WhereNull[Q, string](cols.Survtech),
		Datetested:             psql.WhereNull[Q, time.Time](cols.Datetested),
		Testtech:               psql.WhereNull[Q, string](cols.Testtech),
		Comments:               psql.WhereNull[Q, string](cols.Comments),
		Sampleid:               psql.WhereNull[Q, string](cols.Sampleid),
		Processed:              psql.WhereNull[Q, enums.FieldseekerPoolNotinuitFEnum](cols.Processed),
		LabID:                  psql.WhereNull[Q, uuid.UUID](cols.LabID),
		Testmethod:             psql.WhereNull[Q, enums.FieldseekerPoolPoolTestmethod670efbfba86d41ba8e2d3cab5d749e7fEnum](cols.Testmethod),
		Diseasetested:          psql.WhereNull[Q, enums.FieldseekerPoolPoolDiseasetested0f02232949c04c7e8de820b9b515ed97Enum](cols.Diseasetested),
		Diseasepos:             psql.WhereNull[Q, enums.FieldseekerPoolPoolDiseasepos6889f8dd00074874aa726907e78497faEnum](cols.Diseasepos),
		Globalid:               psql.WhereNull[Q, uuid.UUID](cols.Globalid),
		CreatedUser:            psql.WhereNull[Q, string](cols.CreatedUser),
		CreatedDate:            psql.WhereNull[Q, time.Time](cols.CreatedDate),
		LastEditedUser:         psql.WhereNull[Q, string](cols.LastEditedUser),
		LastEditedDate:         psql.WhereNull[Q, time.Time](cols.LastEditedDate),
		Lab:                    psql.WhereNull[Q, enums.FieldseekerPoolMosquitolabnameEnum](cols.Lab),
		Poolyear:               psql.WhereNull[Q, int16](cols.Poolyear),
		Gatewaysync:            psql.WhereNull[Q, int16](cols.Gatewaysync),
		Vectorsurvcollectionid: psql.WhereNull[Q, string](cols.Vectorsurvcollectionid),
		Vectorsurvpoolid:       psql.WhereNull[Q, string](cols.Vectorsurvpoolid),
		Vectorsurvtrapdataid:   psql.WhereNull[Q, string](cols.Vectorsurvtrapdataid),
		Creationdate:           psql.WhereNull[Q, time.Time](cols.Creationdate),
		Creator:                psql.WhereNull[Q, string](cols.Creator),
		Editdate:               psql.WhereNull[Q, time.Time](cols.Editdate),
		Editor:                 psql.WhereNull[Q, string](cols.Editor),
		Version:                psql.Where[Q, int32](cols.Version),
	}
}
