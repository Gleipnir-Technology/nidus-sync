// Code generated by BobGen psql v0.0.4-0.20251216163753-8e325b7c773a+dirty. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/google/uuid"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// FieldseekerPool is an object representing the database table.
type FieldseekerPool struct {
	Objectid int64 `db:"objectid,pk" `
	// Original attribute from ArcGIS API is TRAPDATA_ID
	TrapdataID null.Val[uuid.UUID] `db:"trapdata_id" `
	// Original attribute from ArcGIS API is DATESENT
	Datesent null.Val[time.Time] `db:"datesent" `
	// Original attribute from ArcGIS API is SURVTECH
	Survtech null.Val[string] `db:"survtech" `
	// Original attribute from ArcGIS API is DATETESTED
	Datetested null.Val[time.Time] `db:"datetested" `
	// Original attribute from ArcGIS API is TESTTECH
	Testtech null.Val[string] `db:"testtech" `
	// Original attribute from ArcGIS API is COMMENTS
	Comments null.Val[string] `db:"comments" `
	// Original attribute from ArcGIS API is SAMPLEID
	Sampleid null.Val[string] `db:"sampleid" `
	// Original attribute from ArcGIS API is PROCESSED
	Processed null.Val[int16] `db:"processed" `
	// Original attribute from ArcGIS API is LAB_ID
	LabID null.Val[uuid.UUID] `db:"lab_id" `
	// Original attribute from ArcGIS API is TESTMETHOD
	Testmethod null.Val[string] `db:"testmethod" `
	// Original attribute from ArcGIS API is DISEASETESTED
	Diseasetested null.Val[string] `db:"diseasetested" `
	// Original attribute from ArcGIS API is DISEASEPOS
	Diseasepos null.Val[string] `db:"diseasepos" `
	// Original attribute from ArcGIS API is GlobalID
	Globalid null.Val[uuid.UUID] `db:"globalid" `
	// Original attribute from ArcGIS API is created_user
	CreatedUser null.Val[string] `db:"created_user" `
	// Original attribute from ArcGIS API is created_date
	CreatedDate null.Val[time.Time] `db:"created_date" `
	// Original attribute from ArcGIS API is last_edited_user
	LastEditedUser null.Val[string] `db:"last_edited_user" `
	// Original attribute from ArcGIS API is last_edited_date
	LastEditedDate null.Val[time.Time] `db:"last_edited_date" `
	// Original attribute from ArcGIS API is LAB
	Lab null.Val[string] `db:"lab" `
	// Original attribute from ArcGIS API is POOLYEAR
	Poolyear null.Val[int16] `db:"poolyear" `
	// Original attribute from ArcGIS API is GATEWAYSYNC
	Gatewaysync null.Val[int16] `db:"gatewaysync" `
	// Original attribute from ArcGIS API is VECTORSURVCOLLECTIONID
	Vectorsurvcollectionid null.Val[string] `db:"vectorsurvcollectionid" `
	// Original attribute from ArcGIS API is VECTORSURVPOOLID
	Vectorsurvpoolid null.Val[string] `db:"vectorsurvpoolid" `
	// Original attribute from ArcGIS API is VECTORSURVTRAPDATAID
	Vectorsurvtrapdataid null.Val[string] `db:"vectorsurvtrapdataid" `
	// Original attribute from ArcGIS API is CreationDate
	Creationdate null.Val[time.Time] `db:"creationdate" `
	// Original attribute from ArcGIS API is Creator
	Creator null.Val[string] `db:"creator" `
	// Original attribute from ArcGIS API is EditDate
	Editdate null.Val[time.Time] `db:"editdate" `
	// Original attribute from ArcGIS API is Editor
	Editor         null.Val[string]            `db:"editor" `
	Geometry       types.JSON[json.RawMessage] `db:"geometry" `
	Geospatial     null.Val[string]            `db:"geospatial" `
	Version        int32                       `db:"version,pk" `
	OrganizationID int32                       `db:"organization_id" `

	R fieldseekerPoolR `db:"-" `
}

// FieldseekerPoolSlice is an alias for a slice of pointers to FieldseekerPool.
// This should almost always be used instead of []*FieldseekerPool.
type FieldseekerPoolSlice []*FieldseekerPool

// FieldseekerPools contains methods to work with the pool table
var FieldseekerPools = psql.NewTablex[*FieldseekerPool, FieldseekerPoolSlice, *FieldseekerPoolSetter]("fieldseeker", "pool", buildFieldseekerPoolColumns("fieldseeker.pool"))

// FieldseekerPoolsQuery is a query on the pool table
type FieldseekerPoolsQuery = *psql.ViewQuery[*FieldseekerPool, FieldseekerPoolSlice]

// fieldseekerPoolR is where relationships are stored.
type fieldseekerPoolR struct {
	Organization *Organization // fieldseeker.pool.pool_organization_id_fkey
}

func buildFieldseekerPoolColumns(alias string) fieldseekerPoolColumns {
	return fieldseekerPoolColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"objectid", "trapdata_id", "datesent", "survtech", "datetested", "testtech", "comments", "sampleid", "processed", "lab_id", "testmethod", "diseasetested", "diseasepos", "globalid", "created_user", "created_date", "last_edited_user", "last_edited_date", "lab", "poolyear", "gatewaysync", "vectorsurvcollectionid", "vectorsurvpoolid", "vectorsurvtrapdataid", "creationdate", "creator", "editdate", "editor", "geometry", "geospatial", "version", "organization_id",
		).WithParent("fieldseeker.pool"),
		tableAlias:             alias,
		Objectid:               psql.Quote(alias, "objectid"),
		TrapdataID:             psql.Quote(alias, "trapdata_id"),
		Datesent:               psql.Quote(alias, "datesent"),
		Survtech:               psql.Quote(alias, "survtech"),
		Datetested:             psql.Quote(alias, "datetested"),
		Testtech:               psql.Quote(alias, "testtech"),
		Comments:               psql.Quote(alias, "comments"),
		Sampleid:               psql.Quote(alias, "sampleid"),
		Processed:              psql.Quote(alias, "processed"),
		LabID:                  psql.Quote(alias, "lab_id"),
		Testmethod:             psql.Quote(alias, "testmethod"),
		Diseasetested:          psql.Quote(alias, "diseasetested"),
		Diseasepos:             psql.Quote(alias, "diseasepos"),
		Globalid:               psql.Quote(alias, "globalid"),
		CreatedUser:            psql.Quote(alias, "created_user"),
		CreatedDate:            psql.Quote(alias, "created_date"),
		LastEditedUser:         psql.Quote(alias, "last_edited_user"),
		LastEditedDate:         psql.Quote(alias, "last_edited_date"),
		Lab:                    psql.Quote(alias, "lab"),
		Poolyear:               psql.Quote(alias, "poolyear"),
		Gatewaysync:            psql.Quote(alias, "gatewaysync"),
		Vectorsurvcollectionid: psql.Quote(alias, "vectorsurvcollectionid"),
		Vectorsurvpoolid:       psql.Quote(alias, "vectorsurvpoolid"),
		Vectorsurvtrapdataid:   psql.Quote(alias, "vectorsurvtrapdataid"),
		Creationdate:           psql.Quote(alias, "creationdate"),
		Creator:                psql.Quote(alias, "creator"),
		Editdate:               psql.Quote(alias, "editdate"),
		Editor:                 psql.Quote(alias, "editor"),
		Geometry:               psql.Quote(alias, "geometry"),
		Geospatial:             psql.Quote(alias, "geospatial"),
		Version:                psql.Quote(alias, "version"),
		OrganizationID:         psql.Quote(alias, "organization_id"),
	}
}

type fieldseekerPoolColumns struct {
	expr.ColumnsExpr
	tableAlias             string
	Objectid               psql.Expression
	TrapdataID             psql.Expression
	Datesent               psql.Expression
	Survtech               psql.Expression
	Datetested             psql.Expression
	Testtech               psql.Expression
	Comments               psql.Expression
	Sampleid               psql.Expression
	Processed              psql.Expression
	LabID                  psql.Expression
	Testmethod             psql.Expression
	Diseasetested          psql.Expression
	Diseasepos             psql.Expression
	Globalid               psql.Expression
	CreatedUser            psql.Expression
	CreatedDate            psql.Expression
	LastEditedUser         psql.Expression
	LastEditedDate         psql.Expression
	Lab                    psql.Expression
	Poolyear               psql.Expression
	Gatewaysync            psql.Expression
	Vectorsurvcollectionid psql.Expression
	Vectorsurvpoolid       psql.Expression
	Vectorsurvtrapdataid   psql.Expression
	Creationdate           psql.Expression
	Creator                psql.Expression
	Editdate               psql.Expression
	Editor                 psql.Expression
	Geometry               psql.Expression
	Geospatial             psql.Expression
	Version                psql.Expression
	OrganizationID         psql.Expression
}

func (c fieldseekerPoolColumns) Alias() string {
	return c.tableAlias
}

func (fieldseekerPoolColumns) AliasedAs(alias string) fieldseekerPoolColumns {
	return buildFieldseekerPoolColumns(alias)
}

// FieldseekerPoolSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type FieldseekerPoolSetter struct {
	Objectid               omit.Val[int64]                       `db:"objectid,pk" `
	TrapdataID             omitnull.Val[uuid.UUID]               `db:"trapdata_id" `
	Datesent               omitnull.Val[time.Time]               `db:"datesent" `
	Survtech               omitnull.Val[string]                  `db:"survtech" `
	Datetested             omitnull.Val[time.Time]               `db:"datetested" `
	Testtech               omitnull.Val[string]                  `db:"testtech" `
	Comments               omitnull.Val[string]                  `db:"comments" `
	Sampleid               omitnull.Val[string]                  `db:"sampleid" `
	Processed              omitnull.Val[int16]                   `db:"processed" `
	LabID                  omitnull.Val[uuid.UUID]               `db:"lab_id" `
	Testmethod             omitnull.Val[string]                  `db:"testmethod" `
	Diseasetested          omitnull.Val[string]                  `db:"diseasetested" `
	Diseasepos             omitnull.Val[string]                  `db:"diseasepos" `
	Globalid               omitnull.Val[uuid.UUID]               `db:"globalid" `
	CreatedUser            omitnull.Val[string]                  `db:"created_user" `
	CreatedDate            omitnull.Val[time.Time]               `db:"created_date" `
	LastEditedUser         omitnull.Val[string]                  `db:"last_edited_user" `
	LastEditedDate         omitnull.Val[time.Time]               `db:"last_edited_date" `
	Lab                    omitnull.Val[string]                  `db:"lab" `
	Poolyear               omitnull.Val[int16]                   `db:"poolyear" `
	Gatewaysync            omitnull.Val[int16]                   `db:"gatewaysync" `
	Vectorsurvcollectionid omitnull.Val[string]                  `db:"vectorsurvcollectionid" `
	Vectorsurvpoolid       omitnull.Val[string]                  `db:"vectorsurvpoolid" `
	Vectorsurvtrapdataid   omitnull.Val[string]                  `db:"vectorsurvtrapdataid" `
	Creationdate           omitnull.Val[time.Time]               `db:"creationdate" `
	Creator                omitnull.Val[string]                  `db:"creator" `
	Editdate               omitnull.Val[time.Time]               `db:"editdate" `
	Editor                 omitnull.Val[string]                  `db:"editor" `
	Geometry               omit.Val[types.JSON[json.RawMessage]] `db:"geometry" `
	Geospatial             omitnull.Val[string]                  `db:"geospatial" `
	Version                omit.Val[int32]                       `db:"version,pk" `
	OrganizationID         omit.Val[int32]                       `db:"organization_id" `
}

func (s FieldseekerPoolSetter) SetColumns() []string {
	vals := make([]string, 0, 32)
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.TrapdataID.IsUnset() {
		vals = append(vals, "trapdata_id")
	}
	if !s.Datesent.IsUnset() {
		vals = append(vals, "datesent")
	}
	if !s.Survtech.IsUnset() {
		vals = append(vals, "survtech")
	}
	if !s.Datetested.IsUnset() {
		vals = append(vals, "datetested")
	}
	if !s.Testtech.IsUnset() {
		vals = append(vals, "testtech")
	}
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Sampleid.IsUnset() {
		vals = append(vals, "sampleid")
	}
	if !s.Processed.IsUnset() {
		vals = append(vals, "processed")
	}
	if !s.LabID.IsUnset() {
		vals = append(vals, "lab_id")
	}
	if !s.Testmethod.IsUnset() {
		vals = append(vals, "testmethod")
	}
	if !s.Diseasetested.IsUnset() {
		vals = append(vals, "diseasetested")
	}
	if !s.Diseasepos.IsUnset() {
		vals = append(vals, "diseasepos")
	}
	if !s.Globalid.IsUnset() {
		vals = append(vals, "globalid")
	}
	if !s.CreatedUser.IsUnset() {
		vals = append(vals, "created_user")
	}
	if !s.CreatedDate.IsUnset() {
		vals = append(vals, "created_date")
	}
	if !s.LastEditedUser.IsUnset() {
		vals = append(vals, "last_edited_user")
	}
	if !s.LastEditedDate.IsUnset() {
		vals = append(vals, "last_edited_date")
	}
	if !s.Lab.IsUnset() {
		vals = append(vals, "lab")
	}
	if !s.Poolyear.IsUnset() {
		vals = append(vals, "poolyear")
	}
	if !s.Gatewaysync.IsUnset() {
		vals = append(vals, "gatewaysync")
	}
	if !s.Vectorsurvcollectionid.IsUnset() {
		vals = append(vals, "vectorsurvcollectionid")
	}
	if !s.Vectorsurvpoolid.IsUnset() {
		vals = append(vals, "vectorsurvpoolid")
	}
	if !s.Vectorsurvtrapdataid.IsUnset() {
		vals = append(vals, "vectorsurvtrapdataid")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if s.Geometry.IsValue() {
		vals = append(vals, "geometry")
	}
	if !s.Geospatial.IsUnset() {
		vals = append(vals, "geospatial")
	}
	if s.Version.IsValue() {
		vals = append(vals, "version")
	}
	if s.OrganizationID.IsValue() {
		vals = append(vals, "organization_id")
	}
	return vals
}

func (s FieldseekerPoolSetter) Overwrite(t *FieldseekerPool) {
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.TrapdataID.IsUnset() {
		t.TrapdataID = s.TrapdataID.MustGetNull()
	}
	if !s.Datesent.IsUnset() {
		t.Datesent = s.Datesent.MustGetNull()
	}
	if !s.Survtech.IsUnset() {
		t.Survtech = s.Survtech.MustGetNull()
	}
	if !s.Datetested.IsUnset() {
		t.Datetested = s.Datetested.MustGetNull()
	}
	if !s.Testtech.IsUnset() {
		t.Testtech = s.Testtech.MustGetNull()
	}
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Sampleid.IsUnset() {
		t.Sampleid = s.Sampleid.MustGetNull()
	}
	if !s.Processed.IsUnset() {
		t.Processed = s.Processed.MustGetNull()
	}
	if !s.LabID.IsUnset() {
		t.LabID = s.LabID.MustGetNull()
	}
	if !s.Testmethod.IsUnset() {
		t.Testmethod = s.Testmethod.MustGetNull()
	}
	if !s.Diseasetested.IsUnset() {
		t.Diseasetested = s.Diseasetested.MustGetNull()
	}
	if !s.Diseasepos.IsUnset() {
		t.Diseasepos = s.Diseasepos.MustGetNull()
	}
	if !s.Globalid.IsUnset() {
		t.Globalid = s.Globalid.MustGetNull()
	}
	if !s.CreatedUser.IsUnset() {
		t.CreatedUser = s.CreatedUser.MustGetNull()
	}
	if !s.CreatedDate.IsUnset() {
		t.CreatedDate = s.CreatedDate.MustGetNull()
	}
	if !s.LastEditedUser.IsUnset() {
		t.LastEditedUser = s.LastEditedUser.MustGetNull()
	}
	if !s.LastEditedDate.IsUnset() {
		t.LastEditedDate = s.LastEditedDate.MustGetNull()
	}
	if !s.Lab.IsUnset() {
		t.Lab = s.Lab.MustGetNull()
	}
	if !s.Poolyear.IsUnset() {
		t.Poolyear = s.Poolyear.MustGetNull()
	}
	if !s.Gatewaysync.IsUnset() {
		t.Gatewaysync = s.Gatewaysync.MustGetNull()
	}
	if !s.Vectorsurvcollectionid.IsUnset() {
		t.Vectorsurvcollectionid = s.Vectorsurvcollectionid.MustGetNull()
	}
	if !s.Vectorsurvpoolid.IsUnset() {
		t.Vectorsurvpoolid = s.Vectorsurvpoolid.MustGetNull()
	}
	if !s.Vectorsurvtrapdataid.IsUnset() {
		t.Vectorsurvtrapdataid = s.Vectorsurvtrapdataid.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if s.Geometry.IsValue() {
		t.Geometry = s.Geometry.MustGet()
	}
	if !s.Geospatial.IsUnset() {
		t.Geospatial = s.Geospatial.MustGetNull()
	}
	if s.Version.IsValue() {
		t.Version = s.Version.MustGet()
	}
	if s.OrganizationID.IsValue() {
		t.OrganizationID = s.OrganizationID.MustGet()
	}
}

func (s *FieldseekerPoolSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return FieldseekerPools.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 32)
		if s.Objectid.IsValue() {
			vals[0] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.TrapdataID.IsUnset() {
			vals[1] = psql.Arg(s.TrapdataID.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Datesent.IsUnset() {
			vals[2] = psql.Arg(s.Datesent.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Survtech.IsUnset() {
			vals[3] = psql.Arg(s.Survtech.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Datetested.IsUnset() {
			vals[4] = psql.Arg(s.Datetested.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Testtech.IsUnset() {
			vals[5] = psql.Arg(s.Testtech.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Comments.IsUnset() {
			vals[6] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Sampleid.IsUnset() {
			vals[7] = psql.Arg(s.Sampleid.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Processed.IsUnset() {
			vals[8] = psql.Arg(s.Processed.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.LabID.IsUnset() {
			vals[9] = psql.Arg(s.LabID.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Testmethod.IsUnset() {
			vals[10] = psql.Arg(s.Testmethod.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.Diseasetested.IsUnset() {
			vals[11] = psql.Arg(s.Diseasetested.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.Diseasepos.IsUnset() {
			vals[12] = psql.Arg(s.Diseasepos.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Globalid.IsUnset() {
			vals[13] = psql.Arg(s.Globalid.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.CreatedUser.IsUnset() {
			vals[14] = psql.Arg(s.CreatedUser.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.CreatedDate.IsUnset() {
			vals[15] = psql.Arg(s.CreatedDate.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedUser.IsUnset() {
			vals[16] = psql.Arg(s.LastEditedUser.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedDate.IsUnset() {
			vals[17] = psql.Arg(s.LastEditedDate.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Lab.IsUnset() {
			vals[18] = psql.Arg(s.Lab.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Poolyear.IsUnset() {
			vals[19] = psql.Arg(s.Poolyear.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.Gatewaysync.IsUnset() {
			vals[20] = psql.Arg(s.Gatewaysync.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvcollectionid.IsUnset() {
			vals[21] = psql.Arg(s.Vectorsurvcollectionid.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvpoolid.IsUnset() {
			vals[22] = psql.Arg(s.Vectorsurvpoolid.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if !s.Vectorsurvtrapdataid.IsUnset() {
			vals[23] = psql.Arg(s.Vectorsurvtrapdataid.MustGetNull())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[24] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[25] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[26] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[27] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if s.Geometry.IsValue() {
			vals[28] = psql.Arg(s.Geometry.MustGet())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if !s.Geospatial.IsUnset() {
			vals[29] = psql.Arg(s.Geospatial.MustGetNull())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if s.Version.IsValue() {
			vals[30] = psql.Arg(s.Version.MustGet())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		if s.OrganizationID.IsValue() {
			vals[31] = psql.Arg(s.OrganizationID.MustGet())
		} else {
			vals[31] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s FieldseekerPoolSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s FieldseekerPoolSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 32)

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.TrapdataID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "trapdata_id")...),
			psql.Arg(s.TrapdataID),
		}})
	}

	if !s.Datesent.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datesent")...),
			psql.Arg(s.Datesent),
		}})
	}

	if !s.Survtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "survtech")...),
			psql.Arg(s.Survtech),
		}})
	}

	if !s.Datetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "datetested")...),
			psql.Arg(s.Datetested),
		}})
	}

	if !s.Testtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testtech")...),
			psql.Arg(s.Testtech),
		}})
	}

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Sampleid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sampleid")...),
			psql.Arg(s.Sampleid),
		}})
	}

	if !s.Processed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "processed")...),
			psql.Arg(s.Processed),
		}})
	}

	if !s.LabID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lab_id")...),
			psql.Arg(s.LabID),
		}})
	}

	if !s.Testmethod.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "testmethod")...),
			psql.Arg(s.Testmethod),
		}})
	}

	if !s.Diseasetested.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasetested")...),
			psql.Arg(s.Diseasetested),
		}})
	}

	if !s.Diseasepos.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "diseasepos")...),
			psql.Arg(s.Diseasepos),
		}})
	}

	if !s.Globalid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.CreatedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_user")...),
			psql.Arg(s.CreatedUser),
		}})
	}

	if !s.CreatedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_date")...),
			psql.Arg(s.CreatedDate),
		}})
	}

	if !s.LastEditedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_user")...),
			psql.Arg(s.LastEditedUser),
		}})
	}

	if !s.LastEditedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_date")...),
			psql.Arg(s.LastEditedDate),
		}})
	}

	if !s.Lab.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lab")...),
			psql.Arg(s.Lab),
		}})
	}

	if !s.Poolyear.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "poolyear")...),
			psql.Arg(s.Poolyear),
		}})
	}

	if !s.Gatewaysync.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "gatewaysync")...),
			psql.Arg(s.Gatewaysync),
		}})
	}

	if !s.Vectorsurvcollectionid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvcollectionid")...),
			psql.Arg(s.Vectorsurvcollectionid),
		}})
	}

	if !s.Vectorsurvpoolid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvpoolid")...),
			psql.Arg(s.Vectorsurvpoolid),
		}})
	}

	if !s.Vectorsurvtrapdataid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "vectorsurvtrapdataid")...),
			psql.Arg(s.Vectorsurvtrapdataid),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if s.Geometry.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry")...),
			psql.Arg(s.Geometry),
		}})
	}

	if !s.Geospatial.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geospatial")...),
			psql.Arg(s.Geospatial),
		}})
	}

	if s.Version.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "version")...),
			psql.Arg(s.Version),
		}})
	}

	if s.OrganizationID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "organization_id")...),
			psql.Arg(s.OrganizationID),
		}})
	}

	return exprs
}

// FindFieldseekerPool retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindFieldseekerPool(ctx context.Context, exec bob.Executor, ObjectidPK int64, VersionPK int32, cols ...string) (*FieldseekerPool, error) {
	if len(cols) == 0 {
		return FieldseekerPools.Query(
			sm.Where(FieldseekerPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
			sm.Where(FieldseekerPools.Columns.Version.EQ(psql.Arg(VersionPK))),
		).One(ctx, exec)
	}

	return FieldseekerPools.Query(
		sm.Where(FieldseekerPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Where(FieldseekerPools.Columns.Version.EQ(psql.Arg(VersionPK))),
		sm.Columns(FieldseekerPools.Columns.Only(cols...)),
	).One(ctx, exec)
}

// FieldseekerPoolExists checks the presence of a single record by primary key
func FieldseekerPoolExists(ctx context.Context, exec bob.Executor, ObjectidPK int64, VersionPK int32) (bool, error) {
	return FieldseekerPools.Query(
		sm.Where(FieldseekerPools.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Where(FieldseekerPools.Columns.Version.EQ(psql.Arg(VersionPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after FieldseekerPool is retrieved from the database
func (o *FieldseekerPool) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FieldseekerPools.AfterSelectHooks.RunHooks(ctx, exec, FieldseekerPoolSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = FieldseekerPools.AfterInsertHooks.RunHooks(ctx, exec, FieldseekerPoolSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = FieldseekerPools.AfterUpdateHooks.RunHooks(ctx, exec, FieldseekerPoolSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = FieldseekerPools.AfterDeleteHooks.RunHooks(ctx, exec, FieldseekerPoolSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the FieldseekerPool
func (o *FieldseekerPool) primaryKeyVals() bob.Expression {
	return psql.ArgGroup(
		o.Objectid,
		o.Version,
	)
}

func (o *FieldseekerPool) pkEQ() dialect.Expression {
	return psql.Group(psql.Quote("fieldseeker.pool", "objectid"), psql.Quote("fieldseeker.pool", "version")).EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the FieldseekerPool
func (o *FieldseekerPool) Update(ctx context.Context, exec bob.Executor, s *FieldseekerPoolSetter) error {
	v, err := FieldseekerPools.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single FieldseekerPool record with an executor
func (o *FieldseekerPool) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := FieldseekerPools.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the FieldseekerPool using the executor
func (o *FieldseekerPool) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := FieldseekerPools.Query(
		sm.Where(FieldseekerPools.Columns.Objectid.EQ(psql.Arg(o.Objectid))),
		sm.Where(FieldseekerPools.Columns.Version.EQ(psql.Arg(o.Version))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after FieldseekerPoolSlice is retrieved from the database
func (o FieldseekerPoolSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FieldseekerPools.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = FieldseekerPools.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = FieldseekerPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = FieldseekerPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o FieldseekerPoolSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Group(psql.Quote("fieldseeker.pool", "objectid"), psql.Quote("fieldseeker.pool", "version")).In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o FieldseekerPoolSlice) copyMatchingRows(from ...*FieldseekerPool) {
	for i, old := range o {
		for _, new := range from {
			if new.Objectid != old.Objectid {
				continue
			}
			if new.Version != old.Version {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o FieldseekerPoolSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FieldseekerPools.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FieldseekerPool:
				o.copyMatchingRows(retrieved)
			case []*FieldseekerPool:
				o.copyMatchingRows(retrieved...)
			case FieldseekerPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FieldseekerPool or a slice of FieldseekerPool
				// then run the AfterUpdateHooks on the slice
				_, err = FieldseekerPools.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o FieldseekerPoolSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FieldseekerPools.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FieldseekerPool:
				o.copyMatchingRows(retrieved)
			case []*FieldseekerPool:
				o.copyMatchingRows(retrieved...)
			case FieldseekerPoolSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FieldseekerPool or a slice of FieldseekerPool
				// then run the AfterDeleteHooks on the slice
				_, err = FieldseekerPools.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o FieldseekerPoolSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals FieldseekerPoolSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FieldseekerPools.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o FieldseekerPoolSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FieldseekerPools.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o FieldseekerPoolSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := FieldseekerPools.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// Organization starts a query for related objects on organization
func (o *FieldseekerPool) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	return Organizations.Query(append(mods,
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.OrganizationID))),
	)...)
}

func (os FieldseekerPoolSlice) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	pkOrganizationID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkOrganizationID = append(pkOrganizationID, o.OrganizationID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkOrganizationID), "integer[]")),
	))

	return Organizations.Query(append(mods,
		sm.Where(psql.Group(Organizations.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

func attachFieldseekerPoolOrganization0(ctx context.Context, exec bob.Executor, count int, fieldseekerPool0 *FieldseekerPool, organization1 *Organization) (*FieldseekerPool, error) {
	setter := &FieldseekerPoolSetter{
		OrganizationID: omit.From(organization1.ID),
	}

	err := fieldseekerPool0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachFieldseekerPoolOrganization0: %w", err)
	}

	return fieldseekerPool0, nil
}

func (fieldseekerPool0 *FieldseekerPool) InsertOrganization(ctx context.Context, exec bob.Executor, related *OrganizationSetter) error {
	var err error

	organization1, err := Organizations.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachFieldseekerPoolOrganization0(ctx, exec, 1, fieldseekerPool0, organization1)
	if err != nil {
		return err
	}

	fieldseekerPool0.R.Organization = organization1

	organization1.R.Pools = append(organization1.R.Pools, fieldseekerPool0)

	return nil
}

func (fieldseekerPool0 *FieldseekerPool) AttachOrganization(ctx context.Context, exec bob.Executor, organization1 *Organization) error {
	var err error

	_, err = attachFieldseekerPoolOrganization0(ctx, exec, 1, fieldseekerPool0, organization1)
	if err != nil {
		return err
	}

	fieldseekerPool0.R.Organization = organization1

	organization1.R.Pools = append(organization1.R.Pools, fieldseekerPool0)

	return nil
}

type fieldseekerPoolWhere[Q psql.Filterable] struct {
	Objectid               psql.WhereMod[Q, int64]
	TrapdataID             psql.WhereNullMod[Q, uuid.UUID]
	Datesent               psql.WhereNullMod[Q, time.Time]
	Survtech               psql.WhereNullMod[Q, string]
	Datetested             psql.WhereNullMod[Q, time.Time]
	Testtech               psql.WhereNullMod[Q, string]
	Comments               psql.WhereNullMod[Q, string]
	Sampleid               psql.WhereNullMod[Q, string]
	Processed              psql.WhereNullMod[Q, int16]
	LabID                  psql.WhereNullMod[Q, uuid.UUID]
	Testmethod             psql.WhereNullMod[Q, string]
	Diseasetested          psql.WhereNullMod[Q, string]
	Diseasepos             psql.WhereNullMod[Q, string]
	Globalid               psql.WhereNullMod[Q, uuid.UUID]
	CreatedUser            psql.WhereNullMod[Q, string]
	CreatedDate            psql.WhereNullMod[Q, time.Time]
	LastEditedUser         psql.WhereNullMod[Q, string]
	LastEditedDate         psql.WhereNullMod[Q, time.Time]
	Lab                    psql.WhereNullMod[Q, string]
	Poolyear               psql.WhereNullMod[Q, int16]
	Gatewaysync            psql.WhereNullMod[Q, int16]
	Vectorsurvcollectionid psql.WhereNullMod[Q, string]
	Vectorsurvpoolid       psql.WhereNullMod[Q, string]
	Vectorsurvtrapdataid   psql.WhereNullMod[Q, string]
	Creationdate           psql.WhereNullMod[Q, time.Time]
	Creator                psql.WhereNullMod[Q, string]
	Editdate               psql.WhereNullMod[Q, time.Time]
	Editor                 psql.WhereNullMod[Q, string]
	Geometry               psql.WhereMod[Q, types.JSON[json.RawMessage]]
	Geospatial             psql.WhereNullMod[Q, string]
	Version                psql.WhereMod[Q, int32]
	OrganizationID         psql.WhereMod[Q, int32]
}

func (fieldseekerPoolWhere[Q]) AliasedAs(alias string) fieldseekerPoolWhere[Q] {
	return buildFieldseekerPoolWhere[Q](buildFieldseekerPoolColumns(alias))
}

func buildFieldseekerPoolWhere[Q psql.Filterable](cols fieldseekerPoolColumns) fieldseekerPoolWhere[Q] {
	return fieldseekerPoolWhere[Q]{
		Objectid:               psql.Where[Q, int64](cols.Objectid),
		TrapdataID:             psql.WhereNull[Q, uuid.UUID](cols.TrapdataID),
		Datesent:               psql.WhereNull[Q, time.Time](cols.Datesent),
		Survtech:               psql.WhereNull[Q, string](cols.Survtech),
		Datetested:             psql.WhereNull[Q, time.Time](cols.Datetested),
		Testtech:               psql.WhereNull[Q, string](cols.Testtech),
		Comments:               psql.WhereNull[Q, string](cols.Comments),
		Sampleid:               psql.WhereNull[Q, string](cols.Sampleid),
		Processed:              psql.WhereNull[Q, int16](cols.Processed),
		LabID:                  psql.WhereNull[Q, uuid.UUID](cols.LabID),
		Testmethod:             psql.WhereNull[Q, string](cols.Testmethod),
		Diseasetested:          psql.WhereNull[Q, string](cols.Diseasetested),
		Diseasepos:             psql.WhereNull[Q, string](cols.Diseasepos),
		Globalid:               psql.WhereNull[Q, uuid.UUID](cols.Globalid),
		CreatedUser:            psql.WhereNull[Q, string](cols.CreatedUser),
		CreatedDate:            psql.WhereNull[Q, time.Time](cols.CreatedDate),
		LastEditedUser:         psql.WhereNull[Q, string](cols.LastEditedUser),
		LastEditedDate:         psql.WhereNull[Q, time.Time](cols.LastEditedDate),
		Lab:                    psql.WhereNull[Q, string](cols.Lab),
		Poolyear:               psql.WhereNull[Q, int16](cols.Poolyear),
		Gatewaysync:            psql.WhereNull[Q, int16](cols.Gatewaysync),
		Vectorsurvcollectionid: psql.WhereNull[Q, string](cols.Vectorsurvcollectionid),
		Vectorsurvpoolid:       psql.WhereNull[Q, string](cols.Vectorsurvpoolid),
		Vectorsurvtrapdataid:   psql.WhereNull[Q, string](cols.Vectorsurvtrapdataid),
		Creationdate:           psql.WhereNull[Q, time.Time](cols.Creationdate),
		Creator:                psql.WhereNull[Q, string](cols.Creator),
		Editdate:               psql.WhereNull[Q, time.Time](cols.Editdate),
		Editor:                 psql.WhereNull[Q, string](cols.Editor),
		Geometry:               psql.Where[Q, types.JSON[json.RawMessage]](cols.Geometry),
		Geospatial:             psql.WhereNull[Q, string](cols.Geospatial),
		Version:                psql.Where[Q, int32](cols.Version),
		OrganizationID:         psql.Where[Q, int32](cols.OrganizationID),
	}
}

func (o *FieldseekerPool) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Organization":
		rel, ok := retrieved.(*Organization)
		if !ok {
			return fmt.Errorf("fieldseekerPool cannot load %T as %q", retrieved, name)
		}

		o.R.Organization = rel

		if rel != nil {
			rel.R.Pools = FieldseekerPoolSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("fieldseekerPool has no relationship %q", name)
	}
}

type fieldseekerPoolPreloader struct {
	Organization func(...psql.PreloadOption) psql.Preloader
}

func buildFieldseekerPoolPreloader() fieldseekerPoolPreloader {
	return fieldseekerPoolPreloader{
		Organization: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Organization, OrganizationSlice](psql.PreloadRel{
				Name: "Organization",
				Sides: []psql.PreloadSide{
					{
						From:        FieldseekerPools,
						To:          Organizations,
						FromColumns: []string{"organization_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Organizations.Columns.Names(), opts...)
		},
	}
}

type fieldseekerPoolThenLoader[Q orm.Loadable] struct {
	Organization func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildFieldseekerPoolThenLoader[Q orm.Loadable]() fieldseekerPoolThenLoader[Q] {
	type OrganizationLoadInterface interface {
		LoadOrganization(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return fieldseekerPoolThenLoader[Q]{
		Organization: thenLoadBuilder[Q](
			"Organization",
			func(ctx context.Context, exec bob.Executor, retrieved OrganizationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrganization(ctx, exec, mods...)
			},
		),
	}
}

// LoadOrganization loads the fieldseekerPool's Organization into the .R struct
func (o *FieldseekerPool) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Organization = nil

	related, err := o.Organization(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Pools = FieldseekerPoolSlice{o}

	o.R.Organization = related
	return nil
}

// LoadOrganization loads the fieldseekerPool's Organization into the .R struct
func (os FieldseekerPoolSlice) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	organizations, err := os.Organization(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range organizations {

			if !(o.OrganizationID == rel.ID) {
				continue
			}

			rel.R.Pools = append(rel.R.Pools, o)

			o.R.Organization = rel
			break
		}
	}

	return nil
}

type fieldseekerPoolJoins[Q dialect.Joinable] struct {
	typ          string
	Organization modAs[Q, organizationColumns]
}

func (j fieldseekerPoolJoins[Q]) aliasedAs(alias string) fieldseekerPoolJoins[Q] {
	return buildFieldseekerPoolJoins[Q](buildFieldseekerPoolColumns(alias), j.typ)
}

func buildFieldseekerPoolJoins[Q dialect.Joinable](cols fieldseekerPoolColumns, typ string) fieldseekerPoolJoins[Q] {
	return fieldseekerPoolJoins[Q]{
		typ: typ,
		Organization: modAs[Q, organizationColumns]{
			c: Organizations.Columns,
			f: func(to organizationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Organizations.Name().As(to.Alias())).On(
						to.ID.EQ(cols.OrganizationID),
					))
				}

				return mods
			},
		},
	}
}
