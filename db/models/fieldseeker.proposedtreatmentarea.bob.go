// Code generated by BobGen psql v0.42.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/google/uuid"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// FieldseekerProposedtreatmentarea is an object representing the database table.
type FieldseekerProposedtreatmentarea struct {
	Objectid int64 `db:"objectid" `
	// Original attribute from ArcGIS API is METHOD
	Method null.Val[string] `db:"method" `
	// Original attribute from ArcGIS API is COMMENTS
	Comments null.Val[string] `db:"comments" `
	// Original attribute from ArcGIS API is ZONE
	Zone null.Val[string] `db:"zone" `
	// Original attribute from ArcGIS API is REVIEWED
	Reviewed null.Val[int16] `db:"reviewed" `
	// Original attribute from ArcGIS API is REVIEWEDBY
	Reviewedby null.Val[string] `db:"reviewedby" `
	// Original attribute from ArcGIS API is REVIEWEDDATE
	Revieweddate null.Val[time.Time] `db:"revieweddate" `
	// Original attribute from ArcGIS API is ZONE2
	Zone2 null.Val[string] `db:"zone2" `
	// Original attribute from ArcGIS API is COMPLETEDDATE
	Completeddate null.Val[time.Time] `db:"completeddate" `
	// Original attribute from ArcGIS API is COMPLETEDBY
	Completedby null.Val[string] `db:"completedby" `
	// Original attribute from ArcGIS API is COMPLETED
	Completed null.Val[int16] `db:"completed" `
	// Original attribute from ArcGIS API is ISSPRAYROUTE
	Issprayroute null.Val[int16] `db:"issprayroute" `
	// Original attribute from ArcGIS API is NAME
	Name null.Val[string] `db:"name" `
	// Original attribute from ArcGIS API is ACRES
	Acres null.Val[float64] `db:"acres" `
	// Original attribute from ArcGIS API is GlobalID
	Globalid uuid.UUID `db:"globalid,pk" `
	// Original attribute from ArcGIS API is EXPORTED
	Exported null.Val[int16] `db:"exported" `
	// Original attribute from ArcGIS API is TARGETPRODUCT
	Targetproduct null.Val[string] `db:"targetproduct" `
	// Original attribute from ArcGIS API is TARGETAPPRATE
	Targetapprate null.Val[float64] `db:"targetapprate" `
	// Original attribute from ArcGIS API is HECTARES
	Hectares null.Val[float64] `db:"hectares" `
	// Original attribute from ArcGIS API is LASTTREATACTIVITY
	Lasttreatactivity null.Val[string] `db:"lasttreatactivity" `
	// Original attribute from ArcGIS API is LASTTREATDATE
	Lasttreatdate null.Val[time.Time] `db:"lasttreatdate" `
	// Original attribute from ArcGIS API is LASTTREATPRODUCT
	Lasttreatproduct null.Val[string] `db:"lasttreatproduct" `
	// Original attribute from ArcGIS API is LASTTREATQTY
	Lasttreatqty null.Val[float64] `db:"lasttreatqty" `
	// Original attribute from ArcGIS API is LASTTREATQTYUNIT
	Lasttreatqtyunit null.Val[string] `db:"lasttreatqtyunit" `
	// Original attribute from ArcGIS API is PRIORITY
	Priority null.Val[string] `db:"priority" `
	// Original attribute from ArcGIS API is DUEDATE
	Duedate null.Val[time.Time] `db:"duedate" `
	// Original attribute from ArcGIS API is CreationDate
	Creationdate null.Val[time.Time] `db:"creationdate" `
	// Original attribute from ArcGIS API is Creator
	Creator null.Val[string] `db:"creator" `
	// Original attribute from ArcGIS API is EditDate
	Editdate null.Val[time.Time] `db:"editdate" `
	// Original attribute from ArcGIS API is Editor
	Editor null.Val[string] `db:"editor" `
	// Original attribute from ArcGIS API is TARGETSPECIES
	Targetspecies null.Val[string] `db:"targetspecies" `
	// Original attribute from ArcGIS API is Shape__Area
	ShapeArea null.Val[float64] `db:"shape__area" `
	// Original attribute from ArcGIS API is Shape__Length
	ShapeLength    null.Val[float64]           `db:"shape__length" `
	Geometry       types.JSON[json.RawMessage] `db:"geometry" `
	Geospatial     null.Val[string]            `db:"geospatial" `
	Version        int32                       `db:"version,pk" `
	OrganizationID int32                       `db:"organization_id" `

	R fieldseekerProposedtreatmentareaR `db:"-" `
}

// FieldseekerProposedtreatmentareaSlice is an alias for a slice of pointers to FieldseekerProposedtreatmentarea.
// This should almost always be used instead of []*FieldseekerProposedtreatmentarea.
type FieldseekerProposedtreatmentareaSlice []*FieldseekerProposedtreatmentarea

// FieldseekerProposedtreatmentareas contains methods to work with the proposedtreatmentarea table
var FieldseekerProposedtreatmentareas = psql.NewTablex[*FieldseekerProposedtreatmentarea, FieldseekerProposedtreatmentareaSlice, *FieldseekerProposedtreatmentareaSetter]("fieldseeker", "proposedtreatmentarea", buildFieldseekerProposedtreatmentareaColumns("fieldseeker.proposedtreatmentarea"))

// FieldseekerProposedtreatmentareasQuery is a query on the proposedtreatmentarea table
type FieldseekerProposedtreatmentareasQuery = *psql.ViewQuery[*FieldseekerProposedtreatmentarea, FieldseekerProposedtreatmentareaSlice]

// fieldseekerProposedtreatmentareaR is where relationships are stored.
type fieldseekerProposedtreatmentareaR struct {
	Organization *Organization // fieldseeker.proposedtreatmentarea.proposedtreatmentarea_organization_id_fkey
}

func buildFieldseekerProposedtreatmentareaColumns(alias string) fieldseekerProposedtreatmentareaColumns {
	return fieldseekerProposedtreatmentareaColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"objectid", "method", "comments", "zone", "reviewed", "reviewedby", "revieweddate", "zone2", "completeddate", "completedby", "completed", "issprayroute", "name", "acres", "globalid", "exported", "targetproduct", "targetapprate", "hectares", "lasttreatactivity", "lasttreatdate", "lasttreatproduct", "lasttreatqty", "lasttreatqtyunit", "priority", "duedate", "creationdate", "creator", "editdate", "editor", "targetspecies", "shape__area", "shape__length", "geometry", "geospatial", "version", "organization_id",
		).WithParent("fieldseeker.proposedtreatmentarea"),
		tableAlias:        alias,
		Objectid:          psql.Quote(alias, "objectid"),
		Method:            psql.Quote(alias, "method"),
		Comments:          psql.Quote(alias, "comments"),
		Zone:              psql.Quote(alias, "zone"),
		Reviewed:          psql.Quote(alias, "reviewed"),
		Reviewedby:        psql.Quote(alias, "reviewedby"),
		Revieweddate:      psql.Quote(alias, "revieweddate"),
		Zone2:             psql.Quote(alias, "zone2"),
		Completeddate:     psql.Quote(alias, "completeddate"),
		Completedby:       psql.Quote(alias, "completedby"),
		Completed:         psql.Quote(alias, "completed"),
		Issprayroute:      psql.Quote(alias, "issprayroute"),
		Name:              psql.Quote(alias, "name"),
		Acres:             psql.Quote(alias, "acres"),
		Globalid:          psql.Quote(alias, "globalid"),
		Exported:          psql.Quote(alias, "exported"),
		Targetproduct:     psql.Quote(alias, "targetproduct"),
		Targetapprate:     psql.Quote(alias, "targetapprate"),
		Hectares:          psql.Quote(alias, "hectares"),
		Lasttreatactivity: psql.Quote(alias, "lasttreatactivity"),
		Lasttreatdate:     psql.Quote(alias, "lasttreatdate"),
		Lasttreatproduct:  psql.Quote(alias, "lasttreatproduct"),
		Lasttreatqty:      psql.Quote(alias, "lasttreatqty"),
		Lasttreatqtyunit:  psql.Quote(alias, "lasttreatqtyunit"),
		Priority:          psql.Quote(alias, "priority"),
		Duedate:           psql.Quote(alias, "duedate"),
		Creationdate:      psql.Quote(alias, "creationdate"),
		Creator:           psql.Quote(alias, "creator"),
		Editdate:          psql.Quote(alias, "editdate"),
		Editor:            psql.Quote(alias, "editor"),
		Targetspecies:     psql.Quote(alias, "targetspecies"),
		ShapeArea:         psql.Quote(alias, "shape__area"),
		ShapeLength:       psql.Quote(alias, "shape__length"),
		Geometry:          psql.Quote(alias, "geometry"),
		Geospatial:        psql.Quote(alias, "geospatial"),
		Version:           psql.Quote(alias, "version"),
		OrganizationID:    psql.Quote(alias, "organization_id"),
	}
}

type fieldseekerProposedtreatmentareaColumns struct {
	expr.ColumnsExpr
	tableAlias        string
	Objectid          psql.Expression
	Method            psql.Expression
	Comments          psql.Expression
	Zone              psql.Expression
	Reviewed          psql.Expression
	Reviewedby        psql.Expression
	Revieweddate      psql.Expression
	Zone2             psql.Expression
	Completeddate     psql.Expression
	Completedby       psql.Expression
	Completed         psql.Expression
	Issprayroute      psql.Expression
	Name              psql.Expression
	Acres             psql.Expression
	Globalid          psql.Expression
	Exported          psql.Expression
	Targetproduct     psql.Expression
	Targetapprate     psql.Expression
	Hectares          psql.Expression
	Lasttreatactivity psql.Expression
	Lasttreatdate     psql.Expression
	Lasttreatproduct  psql.Expression
	Lasttreatqty      psql.Expression
	Lasttreatqtyunit  psql.Expression
	Priority          psql.Expression
	Duedate           psql.Expression
	Creationdate      psql.Expression
	Creator           psql.Expression
	Editdate          psql.Expression
	Editor            psql.Expression
	Targetspecies     psql.Expression
	ShapeArea         psql.Expression
	ShapeLength       psql.Expression
	Geometry          psql.Expression
	Geospatial        psql.Expression
	Version           psql.Expression
	OrganizationID    psql.Expression
}

func (c fieldseekerProposedtreatmentareaColumns) Alias() string {
	return c.tableAlias
}

func (fieldseekerProposedtreatmentareaColumns) AliasedAs(alias string) fieldseekerProposedtreatmentareaColumns {
	return buildFieldseekerProposedtreatmentareaColumns(alias)
}

// FieldseekerProposedtreatmentareaSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type FieldseekerProposedtreatmentareaSetter struct {
	Objectid          omit.Val[int64]                       `db:"objectid" `
	Method            omitnull.Val[string]                  `db:"method" `
	Comments          omitnull.Val[string]                  `db:"comments" `
	Zone              omitnull.Val[string]                  `db:"zone" `
	Reviewed          omitnull.Val[int16]                   `db:"reviewed" `
	Reviewedby        omitnull.Val[string]                  `db:"reviewedby" `
	Revieweddate      omitnull.Val[time.Time]               `db:"revieweddate" `
	Zone2             omitnull.Val[string]                  `db:"zone2" `
	Completeddate     omitnull.Val[time.Time]               `db:"completeddate" `
	Completedby       omitnull.Val[string]                  `db:"completedby" `
	Completed         omitnull.Val[int16]                   `db:"completed" `
	Issprayroute      omitnull.Val[int16]                   `db:"issprayroute" `
	Name              omitnull.Val[string]                  `db:"name" `
	Acres             omitnull.Val[float64]                 `db:"acres" `
	Globalid          omit.Val[uuid.UUID]                   `db:"globalid,pk" `
	Exported          omitnull.Val[int16]                   `db:"exported" `
	Targetproduct     omitnull.Val[string]                  `db:"targetproduct" `
	Targetapprate     omitnull.Val[float64]                 `db:"targetapprate" `
	Hectares          omitnull.Val[float64]                 `db:"hectares" `
	Lasttreatactivity omitnull.Val[string]                  `db:"lasttreatactivity" `
	Lasttreatdate     omitnull.Val[time.Time]               `db:"lasttreatdate" `
	Lasttreatproduct  omitnull.Val[string]                  `db:"lasttreatproduct" `
	Lasttreatqty      omitnull.Val[float64]                 `db:"lasttreatqty" `
	Lasttreatqtyunit  omitnull.Val[string]                  `db:"lasttreatqtyunit" `
	Priority          omitnull.Val[string]                  `db:"priority" `
	Duedate           omitnull.Val[time.Time]               `db:"duedate" `
	Creationdate      omitnull.Val[time.Time]               `db:"creationdate" `
	Creator           omitnull.Val[string]                  `db:"creator" `
	Editdate          omitnull.Val[time.Time]               `db:"editdate" `
	Editor            omitnull.Val[string]                  `db:"editor" `
	Targetspecies     omitnull.Val[string]                  `db:"targetspecies" `
	ShapeArea         omitnull.Val[float64]                 `db:"shape__area" `
	ShapeLength       omitnull.Val[float64]                 `db:"shape__length" `
	Geometry          omit.Val[types.JSON[json.RawMessage]] `db:"geometry" `
	Geospatial        omitnull.Val[string]                  `db:"geospatial" `
	Version           omit.Val[int32]                       `db:"version,pk" `
	OrganizationID    omit.Val[int32]                       `db:"organization_id" `
}

func (s FieldseekerProposedtreatmentareaSetter) SetColumns() []string {
	vals := make([]string, 0, 37)
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.Method.IsUnset() {
		vals = append(vals, "method")
	}
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Zone.IsUnset() {
		vals = append(vals, "zone")
	}
	if !s.Reviewed.IsUnset() {
		vals = append(vals, "reviewed")
	}
	if !s.Reviewedby.IsUnset() {
		vals = append(vals, "reviewedby")
	}
	if !s.Revieweddate.IsUnset() {
		vals = append(vals, "revieweddate")
	}
	if !s.Zone2.IsUnset() {
		vals = append(vals, "zone2")
	}
	if !s.Completeddate.IsUnset() {
		vals = append(vals, "completeddate")
	}
	if !s.Completedby.IsUnset() {
		vals = append(vals, "completedby")
	}
	if !s.Completed.IsUnset() {
		vals = append(vals, "completed")
	}
	if !s.Issprayroute.IsUnset() {
		vals = append(vals, "issprayroute")
	}
	if !s.Name.IsUnset() {
		vals = append(vals, "name")
	}
	if !s.Acres.IsUnset() {
		vals = append(vals, "acres")
	}
	if s.Globalid.IsValue() {
		vals = append(vals, "globalid")
	}
	if !s.Exported.IsUnset() {
		vals = append(vals, "exported")
	}
	if !s.Targetproduct.IsUnset() {
		vals = append(vals, "targetproduct")
	}
	if !s.Targetapprate.IsUnset() {
		vals = append(vals, "targetapprate")
	}
	if !s.Hectares.IsUnset() {
		vals = append(vals, "hectares")
	}
	if !s.Lasttreatactivity.IsUnset() {
		vals = append(vals, "lasttreatactivity")
	}
	if !s.Lasttreatdate.IsUnset() {
		vals = append(vals, "lasttreatdate")
	}
	if !s.Lasttreatproduct.IsUnset() {
		vals = append(vals, "lasttreatproduct")
	}
	if !s.Lasttreatqty.IsUnset() {
		vals = append(vals, "lasttreatqty")
	}
	if !s.Lasttreatqtyunit.IsUnset() {
		vals = append(vals, "lasttreatqtyunit")
	}
	if !s.Priority.IsUnset() {
		vals = append(vals, "priority")
	}
	if !s.Duedate.IsUnset() {
		vals = append(vals, "duedate")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if !s.Targetspecies.IsUnset() {
		vals = append(vals, "targetspecies")
	}
	if !s.ShapeArea.IsUnset() {
		vals = append(vals, "shape__area")
	}
	if !s.ShapeLength.IsUnset() {
		vals = append(vals, "shape__length")
	}
	if s.Geometry.IsValue() {
		vals = append(vals, "geometry")
	}
	if !s.Geospatial.IsUnset() {
		vals = append(vals, "geospatial")
	}
	if s.Version.IsValue() {
		vals = append(vals, "version")
	}
	if s.OrganizationID.IsValue() {
		vals = append(vals, "organization_id")
	}
	return vals
}

func (s FieldseekerProposedtreatmentareaSetter) Overwrite(t *FieldseekerProposedtreatmentarea) {
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.Method.IsUnset() {
		t.Method = s.Method.MustGetNull()
	}
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Zone.IsUnset() {
		t.Zone = s.Zone.MustGetNull()
	}
	if !s.Reviewed.IsUnset() {
		t.Reviewed = s.Reviewed.MustGetNull()
	}
	if !s.Reviewedby.IsUnset() {
		t.Reviewedby = s.Reviewedby.MustGetNull()
	}
	if !s.Revieweddate.IsUnset() {
		t.Revieweddate = s.Revieweddate.MustGetNull()
	}
	if !s.Zone2.IsUnset() {
		t.Zone2 = s.Zone2.MustGetNull()
	}
	if !s.Completeddate.IsUnset() {
		t.Completeddate = s.Completeddate.MustGetNull()
	}
	if !s.Completedby.IsUnset() {
		t.Completedby = s.Completedby.MustGetNull()
	}
	if !s.Completed.IsUnset() {
		t.Completed = s.Completed.MustGetNull()
	}
	if !s.Issprayroute.IsUnset() {
		t.Issprayroute = s.Issprayroute.MustGetNull()
	}
	if !s.Name.IsUnset() {
		t.Name = s.Name.MustGetNull()
	}
	if !s.Acres.IsUnset() {
		t.Acres = s.Acres.MustGetNull()
	}
	if s.Globalid.IsValue() {
		t.Globalid = s.Globalid.MustGet()
	}
	if !s.Exported.IsUnset() {
		t.Exported = s.Exported.MustGetNull()
	}
	if !s.Targetproduct.IsUnset() {
		t.Targetproduct = s.Targetproduct.MustGetNull()
	}
	if !s.Targetapprate.IsUnset() {
		t.Targetapprate = s.Targetapprate.MustGetNull()
	}
	if !s.Hectares.IsUnset() {
		t.Hectares = s.Hectares.MustGetNull()
	}
	if !s.Lasttreatactivity.IsUnset() {
		t.Lasttreatactivity = s.Lasttreatactivity.MustGetNull()
	}
	if !s.Lasttreatdate.IsUnset() {
		t.Lasttreatdate = s.Lasttreatdate.MustGetNull()
	}
	if !s.Lasttreatproduct.IsUnset() {
		t.Lasttreatproduct = s.Lasttreatproduct.MustGetNull()
	}
	if !s.Lasttreatqty.IsUnset() {
		t.Lasttreatqty = s.Lasttreatqty.MustGetNull()
	}
	if !s.Lasttreatqtyunit.IsUnset() {
		t.Lasttreatqtyunit = s.Lasttreatqtyunit.MustGetNull()
	}
	if !s.Priority.IsUnset() {
		t.Priority = s.Priority.MustGetNull()
	}
	if !s.Duedate.IsUnset() {
		t.Duedate = s.Duedate.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if !s.Targetspecies.IsUnset() {
		t.Targetspecies = s.Targetspecies.MustGetNull()
	}
	if !s.ShapeArea.IsUnset() {
		t.ShapeArea = s.ShapeArea.MustGetNull()
	}
	if !s.ShapeLength.IsUnset() {
		t.ShapeLength = s.ShapeLength.MustGetNull()
	}
	if s.Geometry.IsValue() {
		t.Geometry = s.Geometry.MustGet()
	}
	if !s.Geospatial.IsUnset() {
		t.Geospatial = s.Geospatial.MustGetNull()
	}
	if s.Version.IsValue() {
		t.Version = s.Version.MustGet()
	}
	if s.OrganizationID.IsValue() {
		t.OrganizationID = s.OrganizationID.MustGet()
	}
}

func (s *FieldseekerProposedtreatmentareaSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return FieldseekerProposedtreatmentareas.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 37)
		if s.Objectid.IsValue() {
			vals[0] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Method.IsUnset() {
			vals[1] = psql.Arg(s.Method.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Comments.IsUnset() {
			vals[2] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Zone.IsUnset() {
			vals[3] = psql.Arg(s.Zone.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Reviewed.IsUnset() {
			vals[4] = psql.Arg(s.Reviewed.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Reviewedby.IsUnset() {
			vals[5] = psql.Arg(s.Reviewedby.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Revieweddate.IsUnset() {
			vals[6] = psql.Arg(s.Revieweddate.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Zone2.IsUnset() {
			vals[7] = psql.Arg(s.Zone2.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Completeddate.IsUnset() {
			vals[8] = psql.Arg(s.Completeddate.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Completedby.IsUnset() {
			vals[9] = psql.Arg(s.Completedby.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Completed.IsUnset() {
			vals[10] = psql.Arg(s.Completed.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.Issprayroute.IsUnset() {
			vals[11] = psql.Arg(s.Issprayroute.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.Name.IsUnset() {
			vals[12] = psql.Arg(s.Name.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Acres.IsUnset() {
			vals[13] = psql.Arg(s.Acres.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.Globalid.IsValue() {
			vals[14] = psql.Arg(s.Globalid.MustGet())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.Exported.IsUnset() {
			vals[15] = psql.Arg(s.Exported.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.Targetproduct.IsUnset() {
			vals[16] = psql.Arg(s.Targetproduct.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.Targetapprate.IsUnset() {
			vals[17] = psql.Arg(s.Targetapprate.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Hectares.IsUnset() {
			vals[18] = psql.Arg(s.Hectares.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Lasttreatactivity.IsUnset() {
			vals[19] = psql.Arg(s.Lasttreatactivity.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.Lasttreatdate.IsUnset() {
			vals[20] = psql.Arg(s.Lasttreatdate.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.Lasttreatproduct.IsUnset() {
			vals[21] = psql.Arg(s.Lasttreatproduct.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.Lasttreatqty.IsUnset() {
			vals[22] = psql.Arg(s.Lasttreatqty.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if !s.Lasttreatqtyunit.IsUnset() {
			vals[23] = psql.Arg(s.Lasttreatqtyunit.MustGetNull())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.Priority.IsUnset() {
			vals[24] = psql.Arg(s.Priority.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.Duedate.IsUnset() {
			vals[25] = psql.Arg(s.Duedate.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[26] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[27] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[28] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[29] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if !s.Targetspecies.IsUnset() {
			vals[30] = psql.Arg(s.Targetspecies.MustGetNull())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		if !s.ShapeArea.IsUnset() {
			vals[31] = psql.Arg(s.ShapeArea.MustGetNull())
		} else {
			vals[31] = psql.Raw("DEFAULT")
		}

		if !s.ShapeLength.IsUnset() {
			vals[32] = psql.Arg(s.ShapeLength.MustGetNull())
		} else {
			vals[32] = psql.Raw("DEFAULT")
		}

		if s.Geometry.IsValue() {
			vals[33] = psql.Arg(s.Geometry.MustGet())
		} else {
			vals[33] = psql.Raw("DEFAULT")
		}

		if !s.Geospatial.IsUnset() {
			vals[34] = psql.Arg(s.Geospatial.MustGetNull())
		} else {
			vals[34] = psql.Raw("DEFAULT")
		}

		if s.Version.IsValue() {
			vals[35] = psql.Arg(s.Version.MustGet())
		} else {
			vals[35] = psql.Raw("DEFAULT")
		}

		if s.OrganizationID.IsValue() {
			vals[36] = psql.Arg(s.OrganizationID.MustGet())
		} else {
			vals[36] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s FieldseekerProposedtreatmentareaSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s FieldseekerProposedtreatmentareaSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 37)

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.Method.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "method")...),
			psql.Arg(s.Method),
		}})
	}

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Zone.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone")...),
			psql.Arg(s.Zone),
		}})
	}

	if !s.Reviewed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reviewed")...),
			psql.Arg(s.Reviewed),
		}})
	}

	if !s.Reviewedby.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reviewedby")...),
			psql.Arg(s.Reviewedby),
		}})
	}

	if !s.Revieweddate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "revieweddate")...),
			psql.Arg(s.Revieweddate),
		}})
	}

	if !s.Zone2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone2")...),
			psql.Arg(s.Zone2),
		}})
	}

	if !s.Completeddate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "completeddate")...),
			psql.Arg(s.Completeddate),
		}})
	}

	if !s.Completedby.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "completedby")...),
			psql.Arg(s.Completedby),
		}})
	}

	if !s.Completed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "completed")...),
			psql.Arg(s.Completed),
		}})
	}

	if !s.Issprayroute.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "issprayroute")...),
			psql.Arg(s.Issprayroute),
		}})
	}

	if !s.Name.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "name")...),
			psql.Arg(s.Name),
		}})
	}

	if !s.Acres.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "acres")...),
			psql.Arg(s.Acres),
		}})
	}

	if s.Globalid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.Exported.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "exported")...),
			psql.Arg(s.Exported),
		}})
	}

	if !s.Targetproduct.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "targetproduct")...),
			psql.Arg(s.Targetproduct),
		}})
	}

	if !s.Targetapprate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "targetapprate")...),
			psql.Arg(s.Targetapprate),
		}})
	}

	if !s.Hectares.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "hectares")...),
			psql.Arg(s.Hectares),
		}})
	}

	if !s.Lasttreatactivity.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lasttreatactivity")...),
			psql.Arg(s.Lasttreatactivity),
		}})
	}

	if !s.Lasttreatdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lasttreatdate")...),
			psql.Arg(s.Lasttreatdate),
		}})
	}

	if !s.Lasttreatproduct.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lasttreatproduct")...),
			psql.Arg(s.Lasttreatproduct),
		}})
	}

	if !s.Lasttreatqty.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lasttreatqty")...),
			psql.Arg(s.Lasttreatqty),
		}})
	}

	if !s.Lasttreatqtyunit.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lasttreatqtyunit")...),
			psql.Arg(s.Lasttreatqtyunit),
		}})
	}

	if !s.Priority.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "priority")...),
			psql.Arg(s.Priority),
		}})
	}

	if !s.Duedate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "duedate")...),
			psql.Arg(s.Duedate),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if !s.Targetspecies.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "targetspecies")...),
			psql.Arg(s.Targetspecies),
		}})
	}

	if !s.ShapeArea.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "shape__area")...),
			psql.Arg(s.ShapeArea),
		}})
	}

	if !s.ShapeLength.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "shape__length")...),
			psql.Arg(s.ShapeLength),
		}})
	}

	if s.Geometry.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry")...),
			psql.Arg(s.Geometry),
		}})
	}

	if !s.Geospatial.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geospatial")...),
			psql.Arg(s.Geospatial),
		}})
	}

	if s.Version.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "version")...),
			psql.Arg(s.Version),
		}})
	}

	if s.OrganizationID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "organization_id")...),
			psql.Arg(s.OrganizationID),
		}})
	}

	return exprs
}

// FindFieldseekerProposedtreatmentarea retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindFieldseekerProposedtreatmentarea(ctx context.Context, exec bob.Executor, GlobalidPK uuid.UUID, VersionPK int32, cols ...string) (*FieldseekerProposedtreatmentarea, error) {
	if len(cols) == 0 {
		return FieldseekerProposedtreatmentareas.Query(
			sm.Where(FieldseekerProposedtreatmentareas.Columns.Globalid.EQ(psql.Arg(GlobalidPK))),
			sm.Where(FieldseekerProposedtreatmentareas.Columns.Version.EQ(psql.Arg(VersionPK))),
		).One(ctx, exec)
	}

	return FieldseekerProposedtreatmentareas.Query(
		sm.Where(FieldseekerProposedtreatmentareas.Columns.Globalid.EQ(psql.Arg(GlobalidPK))),
		sm.Where(FieldseekerProposedtreatmentareas.Columns.Version.EQ(psql.Arg(VersionPK))),
		sm.Columns(FieldseekerProposedtreatmentareas.Columns.Only(cols...)),
	).One(ctx, exec)
}

// FieldseekerProposedtreatmentareaExists checks the presence of a single record by primary key
func FieldseekerProposedtreatmentareaExists(ctx context.Context, exec bob.Executor, GlobalidPK uuid.UUID, VersionPK int32) (bool, error) {
	return FieldseekerProposedtreatmentareas.Query(
		sm.Where(FieldseekerProposedtreatmentareas.Columns.Globalid.EQ(psql.Arg(GlobalidPK))),
		sm.Where(FieldseekerProposedtreatmentareas.Columns.Version.EQ(psql.Arg(VersionPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after FieldseekerProposedtreatmentarea is retrieved from the database
func (o *FieldseekerProposedtreatmentarea) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FieldseekerProposedtreatmentareas.AfterSelectHooks.RunHooks(ctx, exec, FieldseekerProposedtreatmentareaSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = FieldseekerProposedtreatmentareas.AfterInsertHooks.RunHooks(ctx, exec, FieldseekerProposedtreatmentareaSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = FieldseekerProposedtreatmentareas.AfterUpdateHooks.RunHooks(ctx, exec, FieldseekerProposedtreatmentareaSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = FieldseekerProposedtreatmentareas.AfterDeleteHooks.RunHooks(ctx, exec, FieldseekerProposedtreatmentareaSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the FieldseekerProposedtreatmentarea
func (o *FieldseekerProposedtreatmentarea) primaryKeyVals() bob.Expression {
	return psql.ArgGroup(
		o.Globalid,
		o.Version,
	)
}

func (o *FieldseekerProposedtreatmentarea) pkEQ() dialect.Expression {
	return psql.Group(psql.Quote("fieldseeker.proposedtreatmentarea", "globalid"), psql.Quote("fieldseeker.proposedtreatmentarea", "version")).EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the FieldseekerProposedtreatmentarea
func (o *FieldseekerProposedtreatmentarea) Update(ctx context.Context, exec bob.Executor, s *FieldseekerProposedtreatmentareaSetter) error {
	v, err := FieldseekerProposedtreatmentareas.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single FieldseekerProposedtreatmentarea record with an executor
func (o *FieldseekerProposedtreatmentarea) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := FieldseekerProposedtreatmentareas.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the FieldseekerProposedtreatmentarea using the executor
func (o *FieldseekerProposedtreatmentarea) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := FieldseekerProposedtreatmentareas.Query(
		sm.Where(FieldseekerProposedtreatmentareas.Columns.Globalid.EQ(psql.Arg(o.Globalid))),
		sm.Where(FieldseekerProposedtreatmentareas.Columns.Version.EQ(psql.Arg(o.Version))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after FieldseekerProposedtreatmentareaSlice is retrieved from the database
func (o FieldseekerProposedtreatmentareaSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FieldseekerProposedtreatmentareas.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = FieldseekerProposedtreatmentareas.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = FieldseekerProposedtreatmentareas.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = FieldseekerProposedtreatmentareas.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o FieldseekerProposedtreatmentareaSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Group(psql.Quote("fieldseeker.proposedtreatmentarea", "globalid"), psql.Quote("fieldseeker.proposedtreatmentarea", "version")).In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o FieldseekerProposedtreatmentareaSlice) copyMatchingRows(from ...*FieldseekerProposedtreatmentarea) {
	for i, old := range o {
		for _, new := range from {
			if new.Globalid != old.Globalid {
				continue
			}
			if new.Version != old.Version {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o FieldseekerProposedtreatmentareaSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FieldseekerProposedtreatmentareas.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FieldseekerProposedtreatmentarea:
				o.copyMatchingRows(retrieved)
			case []*FieldseekerProposedtreatmentarea:
				o.copyMatchingRows(retrieved...)
			case FieldseekerProposedtreatmentareaSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FieldseekerProposedtreatmentarea or a slice of FieldseekerProposedtreatmentarea
				// then run the AfterUpdateHooks on the slice
				_, err = FieldseekerProposedtreatmentareas.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o FieldseekerProposedtreatmentareaSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FieldseekerProposedtreatmentareas.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FieldseekerProposedtreatmentarea:
				o.copyMatchingRows(retrieved)
			case []*FieldseekerProposedtreatmentarea:
				o.copyMatchingRows(retrieved...)
			case FieldseekerProposedtreatmentareaSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FieldseekerProposedtreatmentarea or a slice of FieldseekerProposedtreatmentarea
				// then run the AfterDeleteHooks on the slice
				_, err = FieldseekerProposedtreatmentareas.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o FieldseekerProposedtreatmentareaSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals FieldseekerProposedtreatmentareaSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FieldseekerProposedtreatmentareas.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o FieldseekerProposedtreatmentareaSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FieldseekerProposedtreatmentareas.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o FieldseekerProposedtreatmentareaSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := FieldseekerProposedtreatmentareas.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// Organization starts a query for related objects on organization
func (o *FieldseekerProposedtreatmentarea) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	return Organizations.Query(append(mods,
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.OrganizationID))),
	)...)
}

func (os FieldseekerProposedtreatmentareaSlice) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	pkOrganizationID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkOrganizationID = append(pkOrganizationID, o.OrganizationID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkOrganizationID), "integer[]")),
	))

	return Organizations.Query(append(mods,
		sm.Where(psql.Group(Organizations.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

func attachFieldseekerProposedtreatmentareaOrganization0(ctx context.Context, exec bob.Executor, count int, fieldseekerProposedtreatmentarea0 *FieldseekerProposedtreatmentarea, organization1 *Organization) (*FieldseekerProposedtreatmentarea, error) {
	setter := &FieldseekerProposedtreatmentareaSetter{
		OrganizationID: omit.From(organization1.ID),
	}

	err := fieldseekerProposedtreatmentarea0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachFieldseekerProposedtreatmentareaOrganization0: %w", err)
	}

	return fieldseekerProposedtreatmentarea0, nil
}

func (fieldseekerProposedtreatmentarea0 *FieldseekerProposedtreatmentarea) InsertOrganization(ctx context.Context, exec bob.Executor, related *OrganizationSetter) error {
	var err error

	organization1, err := Organizations.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachFieldseekerProposedtreatmentareaOrganization0(ctx, exec, 1, fieldseekerProposedtreatmentarea0, organization1)
	if err != nil {
		return err
	}

	fieldseekerProposedtreatmentarea0.R.Organization = organization1

	organization1.R.Proposedtreatmentareas = append(organization1.R.Proposedtreatmentareas, fieldseekerProposedtreatmentarea0)

	return nil
}

func (fieldseekerProposedtreatmentarea0 *FieldseekerProposedtreatmentarea) AttachOrganization(ctx context.Context, exec bob.Executor, organization1 *Organization) error {
	var err error

	_, err = attachFieldseekerProposedtreatmentareaOrganization0(ctx, exec, 1, fieldseekerProposedtreatmentarea0, organization1)
	if err != nil {
		return err
	}

	fieldseekerProposedtreatmentarea0.R.Organization = organization1

	organization1.R.Proposedtreatmentareas = append(organization1.R.Proposedtreatmentareas, fieldseekerProposedtreatmentarea0)

	return nil
}

type fieldseekerProposedtreatmentareaWhere[Q psql.Filterable] struct {
	Objectid          psql.WhereMod[Q, int64]
	Method            psql.WhereNullMod[Q, string]
	Comments          psql.WhereNullMod[Q, string]
	Zone              psql.WhereNullMod[Q, string]
	Reviewed          psql.WhereNullMod[Q, int16]
	Reviewedby        psql.WhereNullMod[Q, string]
	Revieweddate      psql.WhereNullMod[Q, time.Time]
	Zone2             psql.WhereNullMod[Q, string]
	Completeddate     psql.WhereNullMod[Q, time.Time]
	Completedby       psql.WhereNullMod[Q, string]
	Completed         psql.WhereNullMod[Q, int16]
	Issprayroute      psql.WhereNullMod[Q, int16]
	Name              psql.WhereNullMod[Q, string]
	Acres             psql.WhereNullMod[Q, float64]
	Globalid          psql.WhereMod[Q, uuid.UUID]
	Exported          psql.WhereNullMod[Q, int16]
	Targetproduct     psql.WhereNullMod[Q, string]
	Targetapprate     psql.WhereNullMod[Q, float64]
	Hectares          psql.WhereNullMod[Q, float64]
	Lasttreatactivity psql.WhereNullMod[Q, string]
	Lasttreatdate     psql.WhereNullMod[Q, time.Time]
	Lasttreatproduct  psql.WhereNullMod[Q, string]
	Lasttreatqty      psql.WhereNullMod[Q, float64]
	Lasttreatqtyunit  psql.WhereNullMod[Q, string]
	Priority          psql.WhereNullMod[Q, string]
	Duedate           psql.WhereNullMod[Q, time.Time]
	Creationdate      psql.WhereNullMod[Q, time.Time]
	Creator           psql.WhereNullMod[Q, string]
	Editdate          psql.WhereNullMod[Q, time.Time]
	Editor            psql.WhereNullMod[Q, string]
	Targetspecies     psql.WhereNullMod[Q, string]
	ShapeArea         psql.WhereNullMod[Q, float64]
	ShapeLength       psql.WhereNullMod[Q, float64]
	Geometry          psql.WhereMod[Q, types.JSON[json.RawMessage]]
	Geospatial        psql.WhereNullMod[Q, string]
	Version           psql.WhereMod[Q, int32]
	OrganizationID    psql.WhereMod[Q, int32]
}

func (fieldseekerProposedtreatmentareaWhere[Q]) AliasedAs(alias string) fieldseekerProposedtreatmentareaWhere[Q] {
	return buildFieldseekerProposedtreatmentareaWhere[Q](buildFieldseekerProposedtreatmentareaColumns(alias))
}

func buildFieldseekerProposedtreatmentareaWhere[Q psql.Filterable](cols fieldseekerProposedtreatmentareaColumns) fieldseekerProposedtreatmentareaWhere[Q] {
	return fieldseekerProposedtreatmentareaWhere[Q]{
		Objectid:          psql.Where[Q, int64](cols.Objectid),
		Method:            psql.WhereNull[Q, string](cols.Method),
		Comments:          psql.WhereNull[Q, string](cols.Comments),
		Zone:              psql.WhereNull[Q, string](cols.Zone),
		Reviewed:          psql.WhereNull[Q, int16](cols.Reviewed),
		Reviewedby:        psql.WhereNull[Q, string](cols.Reviewedby),
		Revieweddate:      psql.WhereNull[Q, time.Time](cols.Revieweddate),
		Zone2:             psql.WhereNull[Q, string](cols.Zone2),
		Completeddate:     psql.WhereNull[Q, time.Time](cols.Completeddate),
		Completedby:       psql.WhereNull[Q, string](cols.Completedby),
		Completed:         psql.WhereNull[Q, int16](cols.Completed),
		Issprayroute:      psql.WhereNull[Q, int16](cols.Issprayroute),
		Name:              psql.WhereNull[Q, string](cols.Name),
		Acres:             psql.WhereNull[Q, float64](cols.Acres),
		Globalid:          psql.Where[Q, uuid.UUID](cols.Globalid),
		Exported:          psql.WhereNull[Q, int16](cols.Exported),
		Targetproduct:     psql.WhereNull[Q, string](cols.Targetproduct),
		Targetapprate:     psql.WhereNull[Q, float64](cols.Targetapprate),
		Hectares:          psql.WhereNull[Q, float64](cols.Hectares),
		Lasttreatactivity: psql.WhereNull[Q, string](cols.Lasttreatactivity),
		Lasttreatdate:     psql.WhereNull[Q, time.Time](cols.Lasttreatdate),
		Lasttreatproduct:  psql.WhereNull[Q, string](cols.Lasttreatproduct),
		Lasttreatqty:      psql.WhereNull[Q, float64](cols.Lasttreatqty),
		Lasttreatqtyunit:  psql.WhereNull[Q, string](cols.Lasttreatqtyunit),
		Priority:          psql.WhereNull[Q, string](cols.Priority),
		Duedate:           psql.WhereNull[Q, time.Time](cols.Duedate),
		Creationdate:      psql.WhereNull[Q, time.Time](cols.Creationdate),
		Creator:           psql.WhereNull[Q, string](cols.Creator),
		Editdate:          psql.WhereNull[Q, time.Time](cols.Editdate),
		Editor:            psql.WhereNull[Q, string](cols.Editor),
		Targetspecies:     psql.WhereNull[Q, string](cols.Targetspecies),
		ShapeArea:         psql.WhereNull[Q, float64](cols.ShapeArea),
		ShapeLength:       psql.WhereNull[Q, float64](cols.ShapeLength),
		Geometry:          psql.Where[Q, types.JSON[json.RawMessage]](cols.Geometry),
		Geospatial:        psql.WhereNull[Q, string](cols.Geospatial),
		Version:           psql.Where[Q, int32](cols.Version),
		OrganizationID:    psql.Where[Q, int32](cols.OrganizationID),
	}
}

func (o *FieldseekerProposedtreatmentarea) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Organization":
		rel, ok := retrieved.(*Organization)
		if !ok {
			return fmt.Errorf("fieldseekerProposedtreatmentarea cannot load %T as %q", retrieved, name)
		}

		o.R.Organization = rel

		if rel != nil {
			rel.R.Proposedtreatmentareas = FieldseekerProposedtreatmentareaSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("fieldseekerProposedtreatmentarea has no relationship %q", name)
	}
}

type fieldseekerProposedtreatmentareaPreloader struct {
	Organization func(...psql.PreloadOption) psql.Preloader
}

func buildFieldseekerProposedtreatmentareaPreloader() fieldseekerProposedtreatmentareaPreloader {
	return fieldseekerProposedtreatmentareaPreloader{
		Organization: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Organization, OrganizationSlice](psql.PreloadRel{
				Name: "Organization",
				Sides: []psql.PreloadSide{
					{
						From:        FieldseekerProposedtreatmentareas,
						To:          Organizations,
						FromColumns: []string{"organization_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Organizations.Columns.Names(), opts...)
		},
	}
}

type fieldseekerProposedtreatmentareaThenLoader[Q orm.Loadable] struct {
	Organization func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildFieldseekerProposedtreatmentareaThenLoader[Q orm.Loadable]() fieldseekerProposedtreatmentareaThenLoader[Q] {
	type OrganizationLoadInterface interface {
		LoadOrganization(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return fieldseekerProposedtreatmentareaThenLoader[Q]{
		Organization: thenLoadBuilder[Q](
			"Organization",
			func(ctx context.Context, exec bob.Executor, retrieved OrganizationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrganization(ctx, exec, mods...)
			},
		),
	}
}

// LoadOrganization loads the fieldseekerProposedtreatmentarea's Organization into the .R struct
func (o *FieldseekerProposedtreatmentarea) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Organization = nil

	related, err := o.Organization(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Proposedtreatmentareas = FieldseekerProposedtreatmentareaSlice{o}

	o.R.Organization = related
	return nil
}

// LoadOrganization loads the fieldseekerProposedtreatmentarea's Organization into the .R struct
func (os FieldseekerProposedtreatmentareaSlice) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	organizations, err := os.Organization(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range organizations {

			if !(o.OrganizationID == rel.ID) {
				continue
			}

			rel.R.Proposedtreatmentareas = append(rel.R.Proposedtreatmentareas, o)

			o.R.Organization = rel
			break
		}
	}

	return nil
}

type fieldseekerProposedtreatmentareaJoins[Q dialect.Joinable] struct {
	typ          string
	Organization modAs[Q, organizationColumns]
}

func (j fieldseekerProposedtreatmentareaJoins[Q]) aliasedAs(alias string) fieldseekerProposedtreatmentareaJoins[Q] {
	return buildFieldseekerProposedtreatmentareaJoins[Q](buildFieldseekerProposedtreatmentareaColumns(alias), j.typ)
}

func buildFieldseekerProposedtreatmentareaJoins[Q dialect.Joinable](cols fieldseekerProposedtreatmentareaColumns, typ string) fieldseekerProposedtreatmentareaJoins[Q] {
	return fieldseekerProposedtreatmentareaJoins[Q]{
		typ: typ,
		Organization: modAs[Q, organizationColumns]{
			c: Organizations.Columns,
			f: func(to organizationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Organizations.Name().As(to.Alias())).On(
						to.ID.EQ(cols.OrganizationID),
					))
				}

				return mods
			},
		},
	}
}
