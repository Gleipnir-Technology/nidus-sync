// Code generated by BobGen psql v0.42.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/google/uuid"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// FieldseekerRodentlocation is an object representing the database table.
type FieldseekerRodentlocation struct {
	Objectid int64 `db:"objectid" `
	// Original attribute from ArcGIS API is LOCATIONNAME
	Locationname null.Val[string] `db:"locationname" `
	// Original attribute from ArcGIS API is ZONE
	Zone null.Val[string] `db:"zone" `
	// Original attribute from ArcGIS API is ZONE2
	Zone2 null.Val[string] `db:"zone2" `
	// Original attribute from ArcGIS API is HABITAT
	Habitat null.Val[string] `db:"habitat" `
	// Original attribute from ArcGIS API is PRIORITY
	Priority null.Val[string] `db:"priority" `
	// Original attribute from ArcGIS API is USETYPE
	Usetype null.Val[string] `db:"usetype" `
	// Original attribute from ArcGIS API is ACTIVE
	Active null.Val[int16] `db:"active" `
	// Original attribute from ArcGIS API is DESCRIPTION
	Description null.Val[string] `db:"description" `
	// Original attribute from ArcGIS API is ACCESSDESC
	Accessdesc null.Val[string] `db:"accessdesc" `
	// Original attribute from ArcGIS API is COMMENTS
	Comments null.Val[string] `db:"comments" `
	// Original attribute from ArcGIS API is SYMBOLOGY
	Symbology null.Val[string] `db:"symbology" `
	// Original attribute from ArcGIS API is EXTERNALID
	Externalid null.Val[string] `db:"externalid" `
	// Original attribute from ArcGIS API is NEXTACTIONDATESCHEDULED
	Nextactiondatescheduled null.Val[time.Time] `db:"nextactiondatescheduled" `
	// Original attribute from ArcGIS API is LOCATIONNUMBER
	Locationnumber null.Val[int32] `db:"locationnumber" `
	// Original attribute from ArcGIS API is LASTINSPECTDATE
	Lastinspectdate null.Val[time.Time] `db:"lastinspectdate" `
	// Original attribute from ArcGIS API is LASTINSPECTSPECIES
	Lastinspectspecies null.Val[string] `db:"lastinspectspecies" `
	// Original attribute from ArcGIS API is LASTINSPECTACTION
	Lastinspectaction null.Val[string] `db:"lastinspectaction" `
	// Original attribute from ArcGIS API is LASTINSPECTCONDITIONS
	Lastinspectconditions null.Val[string] `db:"lastinspectconditions" `
	// Original attribute from ArcGIS API is LASTINSPECTRODENTEVIDENCE
	Lastinspectrodentevidence null.Val[string] `db:"lastinspectrodentevidence" `
	// Original attribute from ArcGIS API is GlobalID
	Globalid uuid.UUID `db:"globalid,pk" `
	// Original attribute from ArcGIS API is created_user
	CreatedUser null.Val[string] `db:"created_user" `
	// Original attribute from ArcGIS API is created_date
	CreatedDate null.Val[time.Time] `db:"created_date" `
	// Original attribute from ArcGIS API is last_edited_user
	LastEditedUser null.Val[string] `db:"last_edited_user" `
	// Original attribute from ArcGIS API is last_edited_date
	LastEditedDate null.Val[time.Time] `db:"last_edited_date" `
	// Original attribute from ArcGIS API is CreationDate
	Creationdate null.Val[time.Time] `db:"creationdate" `
	// Original attribute from ArcGIS API is Creator
	Creator null.Val[string] `db:"creator" `
	// Original attribute from ArcGIS API is EditDate
	Editdate null.Val[time.Time] `db:"editdate" `
	// Original attribute from ArcGIS API is Editor
	Editor null.Val[string] `db:"editor" `
	// Original attribute from ArcGIS API is JURISDICTION
	Jurisdiction   null.Val[string]            `db:"jurisdiction" `
	Geometry       types.JSON[json.RawMessage] `db:"geometry" `
	Geospatial     null.Val[string]            `db:"geospatial" `
	Version        int32                       `db:"version,pk" `
	OrganizationID int32                       `db:"organization_id" `

	R fieldseekerRodentlocationR `db:"-" `
}

// FieldseekerRodentlocationSlice is an alias for a slice of pointers to FieldseekerRodentlocation.
// This should almost always be used instead of []*FieldseekerRodentlocation.
type FieldseekerRodentlocationSlice []*FieldseekerRodentlocation

// FieldseekerRodentlocations contains methods to work with the rodentlocation table
var FieldseekerRodentlocations = psql.NewTablex[*FieldseekerRodentlocation, FieldseekerRodentlocationSlice, *FieldseekerRodentlocationSetter]("fieldseeker", "rodentlocation", buildFieldseekerRodentlocationColumns("fieldseeker.rodentlocation"))

// FieldseekerRodentlocationsQuery is a query on the rodentlocation table
type FieldseekerRodentlocationsQuery = *psql.ViewQuery[*FieldseekerRodentlocation, FieldseekerRodentlocationSlice]

// fieldseekerRodentlocationR is where relationships are stored.
type fieldseekerRodentlocationR struct {
	Organization *Organization // fieldseeker.rodentlocation.rodentlocation_organization_id_fkey
}

func buildFieldseekerRodentlocationColumns(alias string) fieldseekerRodentlocationColumns {
	return fieldseekerRodentlocationColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"objectid", "locationname", "zone", "zone2", "habitat", "priority", "usetype", "active", "description", "accessdesc", "comments", "symbology", "externalid", "nextactiondatescheduled", "locationnumber", "lastinspectdate", "lastinspectspecies", "lastinspectaction", "lastinspectconditions", "lastinspectrodentevidence", "globalid", "created_user", "created_date", "last_edited_user", "last_edited_date", "creationdate", "creator", "editdate", "editor", "jurisdiction", "geometry", "geospatial", "version", "organization_id",
		).WithParent("fieldseeker.rodentlocation"),
		tableAlias:                alias,
		Objectid:                  psql.Quote(alias, "objectid"),
		Locationname:              psql.Quote(alias, "locationname"),
		Zone:                      psql.Quote(alias, "zone"),
		Zone2:                     psql.Quote(alias, "zone2"),
		Habitat:                   psql.Quote(alias, "habitat"),
		Priority:                  psql.Quote(alias, "priority"),
		Usetype:                   psql.Quote(alias, "usetype"),
		Active:                    psql.Quote(alias, "active"),
		Description:               psql.Quote(alias, "description"),
		Accessdesc:                psql.Quote(alias, "accessdesc"),
		Comments:                  psql.Quote(alias, "comments"),
		Symbology:                 psql.Quote(alias, "symbology"),
		Externalid:                psql.Quote(alias, "externalid"),
		Nextactiondatescheduled:   psql.Quote(alias, "nextactiondatescheduled"),
		Locationnumber:            psql.Quote(alias, "locationnumber"),
		Lastinspectdate:           psql.Quote(alias, "lastinspectdate"),
		Lastinspectspecies:        psql.Quote(alias, "lastinspectspecies"),
		Lastinspectaction:         psql.Quote(alias, "lastinspectaction"),
		Lastinspectconditions:     psql.Quote(alias, "lastinspectconditions"),
		Lastinspectrodentevidence: psql.Quote(alias, "lastinspectrodentevidence"),
		Globalid:                  psql.Quote(alias, "globalid"),
		CreatedUser:               psql.Quote(alias, "created_user"),
		CreatedDate:               psql.Quote(alias, "created_date"),
		LastEditedUser:            psql.Quote(alias, "last_edited_user"),
		LastEditedDate:            psql.Quote(alias, "last_edited_date"),
		Creationdate:              psql.Quote(alias, "creationdate"),
		Creator:                   psql.Quote(alias, "creator"),
		Editdate:                  psql.Quote(alias, "editdate"),
		Editor:                    psql.Quote(alias, "editor"),
		Jurisdiction:              psql.Quote(alias, "jurisdiction"),
		Geometry:                  psql.Quote(alias, "geometry"),
		Geospatial:                psql.Quote(alias, "geospatial"),
		Version:                   psql.Quote(alias, "version"),
		OrganizationID:            psql.Quote(alias, "organization_id"),
	}
}

type fieldseekerRodentlocationColumns struct {
	expr.ColumnsExpr
	tableAlias                string
	Objectid                  psql.Expression
	Locationname              psql.Expression
	Zone                      psql.Expression
	Zone2                     psql.Expression
	Habitat                   psql.Expression
	Priority                  psql.Expression
	Usetype                   psql.Expression
	Active                    psql.Expression
	Description               psql.Expression
	Accessdesc                psql.Expression
	Comments                  psql.Expression
	Symbology                 psql.Expression
	Externalid                psql.Expression
	Nextactiondatescheduled   psql.Expression
	Locationnumber            psql.Expression
	Lastinspectdate           psql.Expression
	Lastinspectspecies        psql.Expression
	Lastinspectaction         psql.Expression
	Lastinspectconditions     psql.Expression
	Lastinspectrodentevidence psql.Expression
	Globalid                  psql.Expression
	CreatedUser               psql.Expression
	CreatedDate               psql.Expression
	LastEditedUser            psql.Expression
	LastEditedDate            psql.Expression
	Creationdate              psql.Expression
	Creator                   psql.Expression
	Editdate                  psql.Expression
	Editor                    psql.Expression
	Jurisdiction              psql.Expression
	Geometry                  psql.Expression
	Geospatial                psql.Expression
	Version                   psql.Expression
	OrganizationID            psql.Expression
}

func (c fieldseekerRodentlocationColumns) Alias() string {
	return c.tableAlias
}

func (fieldseekerRodentlocationColumns) AliasedAs(alias string) fieldseekerRodentlocationColumns {
	return buildFieldseekerRodentlocationColumns(alias)
}

// FieldseekerRodentlocationSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type FieldseekerRodentlocationSetter struct {
	Objectid                  omit.Val[int64]                       `db:"objectid" `
	Locationname              omitnull.Val[string]                  `db:"locationname" `
	Zone                      omitnull.Val[string]                  `db:"zone" `
	Zone2                     omitnull.Val[string]                  `db:"zone2" `
	Habitat                   omitnull.Val[string]                  `db:"habitat" `
	Priority                  omitnull.Val[string]                  `db:"priority" `
	Usetype                   omitnull.Val[string]                  `db:"usetype" `
	Active                    omitnull.Val[int16]                   `db:"active" `
	Description               omitnull.Val[string]                  `db:"description" `
	Accessdesc                omitnull.Val[string]                  `db:"accessdesc" `
	Comments                  omitnull.Val[string]                  `db:"comments" `
	Symbology                 omitnull.Val[string]                  `db:"symbology" `
	Externalid                omitnull.Val[string]                  `db:"externalid" `
	Nextactiondatescheduled   omitnull.Val[time.Time]               `db:"nextactiondatescheduled" `
	Locationnumber            omitnull.Val[int32]                   `db:"locationnumber" `
	Lastinspectdate           omitnull.Val[time.Time]               `db:"lastinspectdate" `
	Lastinspectspecies        omitnull.Val[string]                  `db:"lastinspectspecies" `
	Lastinspectaction         omitnull.Val[string]                  `db:"lastinspectaction" `
	Lastinspectconditions     omitnull.Val[string]                  `db:"lastinspectconditions" `
	Lastinspectrodentevidence omitnull.Val[string]                  `db:"lastinspectrodentevidence" `
	Globalid                  omit.Val[uuid.UUID]                   `db:"globalid,pk" `
	CreatedUser               omitnull.Val[string]                  `db:"created_user" `
	CreatedDate               omitnull.Val[time.Time]               `db:"created_date" `
	LastEditedUser            omitnull.Val[string]                  `db:"last_edited_user" `
	LastEditedDate            omitnull.Val[time.Time]               `db:"last_edited_date" `
	Creationdate              omitnull.Val[time.Time]               `db:"creationdate" `
	Creator                   omitnull.Val[string]                  `db:"creator" `
	Editdate                  omitnull.Val[time.Time]               `db:"editdate" `
	Editor                    omitnull.Val[string]                  `db:"editor" `
	Jurisdiction              omitnull.Val[string]                  `db:"jurisdiction" `
	Geometry                  omit.Val[types.JSON[json.RawMessage]] `db:"geometry" `
	Geospatial                omitnull.Val[string]                  `db:"geospatial" `
	Version                   omit.Val[int32]                       `db:"version,pk" `
	OrganizationID            omit.Val[int32]                       `db:"organization_id" `
}

func (s FieldseekerRodentlocationSetter) SetColumns() []string {
	vals := make([]string, 0, 34)
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.Locationname.IsUnset() {
		vals = append(vals, "locationname")
	}
	if !s.Zone.IsUnset() {
		vals = append(vals, "zone")
	}
	if !s.Zone2.IsUnset() {
		vals = append(vals, "zone2")
	}
	if !s.Habitat.IsUnset() {
		vals = append(vals, "habitat")
	}
	if !s.Priority.IsUnset() {
		vals = append(vals, "priority")
	}
	if !s.Usetype.IsUnset() {
		vals = append(vals, "usetype")
	}
	if !s.Active.IsUnset() {
		vals = append(vals, "active")
	}
	if !s.Description.IsUnset() {
		vals = append(vals, "description")
	}
	if !s.Accessdesc.IsUnset() {
		vals = append(vals, "accessdesc")
	}
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Symbology.IsUnset() {
		vals = append(vals, "symbology")
	}
	if !s.Externalid.IsUnset() {
		vals = append(vals, "externalid")
	}
	if !s.Nextactiondatescheduled.IsUnset() {
		vals = append(vals, "nextactiondatescheduled")
	}
	if !s.Locationnumber.IsUnset() {
		vals = append(vals, "locationnumber")
	}
	if !s.Lastinspectdate.IsUnset() {
		vals = append(vals, "lastinspectdate")
	}
	if !s.Lastinspectspecies.IsUnset() {
		vals = append(vals, "lastinspectspecies")
	}
	if !s.Lastinspectaction.IsUnset() {
		vals = append(vals, "lastinspectaction")
	}
	if !s.Lastinspectconditions.IsUnset() {
		vals = append(vals, "lastinspectconditions")
	}
	if !s.Lastinspectrodentevidence.IsUnset() {
		vals = append(vals, "lastinspectrodentevidence")
	}
	if s.Globalid.IsValue() {
		vals = append(vals, "globalid")
	}
	if !s.CreatedUser.IsUnset() {
		vals = append(vals, "created_user")
	}
	if !s.CreatedDate.IsUnset() {
		vals = append(vals, "created_date")
	}
	if !s.LastEditedUser.IsUnset() {
		vals = append(vals, "last_edited_user")
	}
	if !s.LastEditedDate.IsUnset() {
		vals = append(vals, "last_edited_date")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if !s.Jurisdiction.IsUnset() {
		vals = append(vals, "jurisdiction")
	}
	if s.Geometry.IsValue() {
		vals = append(vals, "geometry")
	}
	if !s.Geospatial.IsUnset() {
		vals = append(vals, "geospatial")
	}
	if s.Version.IsValue() {
		vals = append(vals, "version")
	}
	if s.OrganizationID.IsValue() {
		vals = append(vals, "organization_id")
	}
	return vals
}

func (s FieldseekerRodentlocationSetter) Overwrite(t *FieldseekerRodentlocation) {
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.Locationname.IsUnset() {
		t.Locationname = s.Locationname.MustGetNull()
	}
	if !s.Zone.IsUnset() {
		t.Zone = s.Zone.MustGetNull()
	}
	if !s.Zone2.IsUnset() {
		t.Zone2 = s.Zone2.MustGetNull()
	}
	if !s.Habitat.IsUnset() {
		t.Habitat = s.Habitat.MustGetNull()
	}
	if !s.Priority.IsUnset() {
		t.Priority = s.Priority.MustGetNull()
	}
	if !s.Usetype.IsUnset() {
		t.Usetype = s.Usetype.MustGetNull()
	}
	if !s.Active.IsUnset() {
		t.Active = s.Active.MustGetNull()
	}
	if !s.Description.IsUnset() {
		t.Description = s.Description.MustGetNull()
	}
	if !s.Accessdesc.IsUnset() {
		t.Accessdesc = s.Accessdesc.MustGetNull()
	}
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Symbology.IsUnset() {
		t.Symbology = s.Symbology.MustGetNull()
	}
	if !s.Externalid.IsUnset() {
		t.Externalid = s.Externalid.MustGetNull()
	}
	if !s.Nextactiondatescheduled.IsUnset() {
		t.Nextactiondatescheduled = s.Nextactiondatescheduled.MustGetNull()
	}
	if !s.Locationnumber.IsUnset() {
		t.Locationnumber = s.Locationnumber.MustGetNull()
	}
	if !s.Lastinspectdate.IsUnset() {
		t.Lastinspectdate = s.Lastinspectdate.MustGetNull()
	}
	if !s.Lastinspectspecies.IsUnset() {
		t.Lastinspectspecies = s.Lastinspectspecies.MustGetNull()
	}
	if !s.Lastinspectaction.IsUnset() {
		t.Lastinspectaction = s.Lastinspectaction.MustGetNull()
	}
	if !s.Lastinspectconditions.IsUnset() {
		t.Lastinspectconditions = s.Lastinspectconditions.MustGetNull()
	}
	if !s.Lastinspectrodentevidence.IsUnset() {
		t.Lastinspectrodentevidence = s.Lastinspectrodentevidence.MustGetNull()
	}
	if s.Globalid.IsValue() {
		t.Globalid = s.Globalid.MustGet()
	}
	if !s.CreatedUser.IsUnset() {
		t.CreatedUser = s.CreatedUser.MustGetNull()
	}
	if !s.CreatedDate.IsUnset() {
		t.CreatedDate = s.CreatedDate.MustGetNull()
	}
	if !s.LastEditedUser.IsUnset() {
		t.LastEditedUser = s.LastEditedUser.MustGetNull()
	}
	if !s.LastEditedDate.IsUnset() {
		t.LastEditedDate = s.LastEditedDate.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if !s.Jurisdiction.IsUnset() {
		t.Jurisdiction = s.Jurisdiction.MustGetNull()
	}
	if s.Geometry.IsValue() {
		t.Geometry = s.Geometry.MustGet()
	}
	if !s.Geospatial.IsUnset() {
		t.Geospatial = s.Geospatial.MustGetNull()
	}
	if s.Version.IsValue() {
		t.Version = s.Version.MustGet()
	}
	if s.OrganizationID.IsValue() {
		t.OrganizationID = s.OrganizationID.MustGet()
	}
}

func (s *FieldseekerRodentlocationSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return FieldseekerRodentlocations.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 34)
		if s.Objectid.IsValue() {
			vals[0] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Locationname.IsUnset() {
			vals[1] = psql.Arg(s.Locationname.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Zone.IsUnset() {
			vals[2] = psql.Arg(s.Zone.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Zone2.IsUnset() {
			vals[3] = psql.Arg(s.Zone2.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Habitat.IsUnset() {
			vals[4] = psql.Arg(s.Habitat.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Priority.IsUnset() {
			vals[5] = psql.Arg(s.Priority.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Usetype.IsUnset() {
			vals[6] = psql.Arg(s.Usetype.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Active.IsUnset() {
			vals[7] = psql.Arg(s.Active.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Description.IsUnset() {
			vals[8] = psql.Arg(s.Description.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Accessdesc.IsUnset() {
			vals[9] = psql.Arg(s.Accessdesc.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Comments.IsUnset() {
			vals[10] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.Symbology.IsUnset() {
			vals[11] = psql.Arg(s.Symbology.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.Externalid.IsUnset() {
			vals[12] = psql.Arg(s.Externalid.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Nextactiondatescheduled.IsUnset() {
			vals[13] = psql.Arg(s.Nextactiondatescheduled.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.Locationnumber.IsUnset() {
			vals[14] = psql.Arg(s.Locationnumber.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.Lastinspectdate.IsUnset() {
			vals[15] = psql.Arg(s.Lastinspectdate.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.Lastinspectspecies.IsUnset() {
			vals[16] = psql.Arg(s.Lastinspectspecies.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.Lastinspectaction.IsUnset() {
			vals[17] = psql.Arg(s.Lastinspectaction.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Lastinspectconditions.IsUnset() {
			vals[18] = psql.Arg(s.Lastinspectconditions.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Lastinspectrodentevidence.IsUnset() {
			vals[19] = psql.Arg(s.Lastinspectrodentevidence.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if s.Globalid.IsValue() {
			vals[20] = psql.Arg(s.Globalid.MustGet())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.CreatedUser.IsUnset() {
			vals[21] = psql.Arg(s.CreatedUser.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.CreatedDate.IsUnset() {
			vals[22] = psql.Arg(s.CreatedDate.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedUser.IsUnset() {
			vals[23] = psql.Arg(s.LastEditedUser.MustGetNull())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedDate.IsUnset() {
			vals[24] = psql.Arg(s.LastEditedDate.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[25] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[26] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[27] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[28] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if !s.Jurisdiction.IsUnset() {
			vals[29] = psql.Arg(s.Jurisdiction.MustGetNull())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if s.Geometry.IsValue() {
			vals[30] = psql.Arg(s.Geometry.MustGet())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		if !s.Geospatial.IsUnset() {
			vals[31] = psql.Arg(s.Geospatial.MustGetNull())
		} else {
			vals[31] = psql.Raw("DEFAULT")
		}

		if s.Version.IsValue() {
			vals[32] = psql.Arg(s.Version.MustGet())
		} else {
			vals[32] = psql.Raw("DEFAULT")
		}

		if s.OrganizationID.IsValue() {
			vals[33] = psql.Arg(s.OrganizationID.MustGet())
		} else {
			vals[33] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s FieldseekerRodentlocationSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s FieldseekerRodentlocationSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 34)

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.Locationname.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "locationname")...),
			psql.Arg(s.Locationname),
		}})
	}

	if !s.Zone.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone")...),
			psql.Arg(s.Zone),
		}})
	}

	if !s.Zone2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone2")...),
			psql.Arg(s.Zone2),
		}})
	}

	if !s.Habitat.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "habitat")...),
			psql.Arg(s.Habitat),
		}})
	}

	if !s.Priority.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "priority")...),
			psql.Arg(s.Priority),
		}})
	}

	if !s.Usetype.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "usetype")...),
			psql.Arg(s.Usetype),
		}})
	}

	if !s.Active.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "active")...),
			psql.Arg(s.Active),
		}})
	}

	if !s.Description.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "description")...),
			psql.Arg(s.Description),
		}})
	}

	if !s.Accessdesc.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "accessdesc")...),
			psql.Arg(s.Accessdesc),
		}})
	}

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Symbology.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "symbology")...),
			psql.Arg(s.Symbology),
		}})
	}

	if !s.Externalid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "externalid")...),
			psql.Arg(s.Externalid),
		}})
	}

	if !s.Nextactiondatescheduled.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "nextactiondatescheduled")...),
			psql.Arg(s.Nextactiondatescheduled),
		}})
	}

	if !s.Locationnumber.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "locationnumber")...),
			psql.Arg(s.Locationnumber),
		}})
	}

	if !s.Lastinspectdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lastinspectdate")...),
			psql.Arg(s.Lastinspectdate),
		}})
	}

	if !s.Lastinspectspecies.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lastinspectspecies")...),
			psql.Arg(s.Lastinspectspecies),
		}})
	}

	if !s.Lastinspectaction.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lastinspectaction")...),
			psql.Arg(s.Lastinspectaction),
		}})
	}

	if !s.Lastinspectconditions.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lastinspectconditions")...),
			psql.Arg(s.Lastinspectconditions),
		}})
	}

	if !s.Lastinspectrodentevidence.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lastinspectrodentevidence")...),
			psql.Arg(s.Lastinspectrodentevidence),
		}})
	}

	if s.Globalid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.CreatedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_user")...),
			psql.Arg(s.CreatedUser),
		}})
	}

	if !s.CreatedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_date")...),
			psql.Arg(s.CreatedDate),
		}})
	}

	if !s.LastEditedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_user")...),
			psql.Arg(s.LastEditedUser),
		}})
	}

	if !s.LastEditedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_date")...),
			psql.Arg(s.LastEditedDate),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if !s.Jurisdiction.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "jurisdiction")...),
			psql.Arg(s.Jurisdiction),
		}})
	}

	if s.Geometry.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry")...),
			psql.Arg(s.Geometry),
		}})
	}

	if !s.Geospatial.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geospatial")...),
			psql.Arg(s.Geospatial),
		}})
	}

	if s.Version.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "version")...),
			psql.Arg(s.Version),
		}})
	}

	if s.OrganizationID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "organization_id")...),
			psql.Arg(s.OrganizationID),
		}})
	}

	return exprs
}

// FindFieldseekerRodentlocation retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindFieldseekerRodentlocation(ctx context.Context, exec bob.Executor, GlobalidPK uuid.UUID, VersionPK int32, cols ...string) (*FieldseekerRodentlocation, error) {
	if len(cols) == 0 {
		return FieldseekerRodentlocations.Query(
			sm.Where(FieldseekerRodentlocations.Columns.Globalid.EQ(psql.Arg(GlobalidPK))),
			sm.Where(FieldseekerRodentlocations.Columns.Version.EQ(psql.Arg(VersionPK))),
		).One(ctx, exec)
	}

	return FieldseekerRodentlocations.Query(
		sm.Where(FieldseekerRodentlocations.Columns.Globalid.EQ(psql.Arg(GlobalidPK))),
		sm.Where(FieldseekerRodentlocations.Columns.Version.EQ(psql.Arg(VersionPK))),
		sm.Columns(FieldseekerRodentlocations.Columns.Only(cols...)),
	).One(ctx, exec)
}

// FieldseekerRodentlocationExists checks the presence of a single record by primary key
func FieldseekerRodentlocationExists(ctx context.Context, exec bob.Executor, GlobalidPK uuid.UUID, VersionPK int32) (bool, error) {
	return FieldseekerRodentlocations.Query(
		sm.Where(FieldseekerRodentlocations.Columns.Globalid.EQ(psql.Arg(GlobalidPK))),
		sm.Where(FieldseekerRodentlocations.Columns.Version.EQ(psql.Arg(VersionPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after FieldseekerRodentlocation is retrieved from the database
func (o *FieldseekerRodentlocation) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FieldseekerRodentlocations.AfterSelectHooks.RunHooks(ctx, exec, FieldseekerRodentlocationSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = FieldseekerRodentlocations.AfterInsertHooks.RunHooks(ctx, exec, FieldseekerRodentlocationSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = FieldseekerRodentlocations.AfterUpdateHooks.RunHooks(ctx, exec, FieldseekerRodentlocationSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = FieldseekerRodentlocations.AfterDeleteHooks.RunHooks(ctx, exec, FieldseekerRodentlocationSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the FieldseekerRodentlocation
func (o *FieldseekerRodentlocation) primaryKeyVals() bob.Expression {
	return psql.ArgGroup(
		o.Globalid,
		o.Version,
	)
}

func (o *FieldseekerRodentlocation) pkEQ() dialect.Expression {
	return psql.Group(psql.Quote("fieldseeker.rodentlocation", "globalid"), psql.Quote("fieldseeker.rodentlocation", "version")).EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the FieldseekerRodentlocation
func (o *FieldseekerRodentlocation) Update(ctx context.Context, exec bob.Executor, s *FieldseekerRodentlocationSetter) error {
	v, err := FieldseekerRodentlocations.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single FieldseekerRodentlocation record with an executor
func (o *FieldseekerRodentlocation) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := FieldseekerRodentlocations.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the FieldseekerRodentlocation using the executor
func (o *FieldseekerRodentlocation) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := FieldseekerRodentlocations.Query(
		sm.Where(FieldseekerRodentlocations.Columns.Globalid.EQ(psql.Arg(o.Globalid))),
		sm.Where(FieldseekerRodentlocations.Columns.Version.EQ(psql.Arg(o.Version))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after FieldseekerRodentlocationSlice is retrieved from the database
func (o FieldseekerRodentlocationSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FieldseekerRodentlocations.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = FieldseekerRodentlocations.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = FieldseekerRodentlocations.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = FieldseekerRodentlocations.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o FieldseekerRodentlocationSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Group(psql.Quote("fieldseeker.rodentlocation", "globalid"), psql.Quote("fieldseeker.rodentlocation", "version")).In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o FieldseekerRodentlocationSlice) copyMatchingRows(from ...*FieldseekerRodentlocation) {
	for i, old := range o {
		for _, new := range from {
			if new.Globalid != old.Globalid {
				continue
			}
			if new.Version != old.Version {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o FieldseekerRodentlocationSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FieldseekerRodentlocations.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FieldseekerRodentlocation:
				o.copyMatchingRows(retrieved)
			case []*FieldseekerRodentlocation:
				o.copyMatchingRows(retrieved...)
			case FieldseekerRodentlocationSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FieldseekerRodentlocation or a slice of FieldseekerRodentlocation
				// then run the AfterUpdateHooks on the slice
				_, err = FieldseekerRodentlocations.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o FieldseekerRodentlocationSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FieldseekerRodentlocations.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FieldseekerRodentlocation:
				o.copyMatchingRows(retrieved)
			case []*FieldseekerRodentlocation:
				o.copyMatchingRows(retrieved...)
			case FieldseekerRodentlocationSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FieldseekerRodentlocation or a slice of FieldseekerRodentlocation
				// then run the AfterDeleteHooks on the slice
				_, err = FieldseekerRodentlocations.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o FieldseekerRodentlocationSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals FieldseekerRodentlocationSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FieldseekerRodentlocations.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o FieldseekerRodentlocationSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FieldseekerRodentlocations.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o FieldseekerRodentlocationSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := FieldseekerRodentlocations.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// Organization starts a query for related objects on organization
func (o *FieldseekerRodentlocation) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	return Organizations.Query(append(mods,
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.OrganizationID))),
	)...)
}

func (os FieldseekerRodentlocationSlice) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	pkOrganizationID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkOrganizationID = append(pkOrganizationID, o.OrganizationID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkOrganizationID), "integer[]")),
	))

	return Organizations.Query(append(mods,
		sm.Where(psql.Group(Organizations.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

func attachFieldseekerRodentlocationOrganization0(ctx context.Context, exec bob.Executor, count int, fieldseekerRodentlocation0 *FieldseekerRodentlocation, organization1 *Organization) (*FieldseekerRodentlocation, error) {
	setter := &FieldseekerRodentlocationSetter{
		OrganizationID: omit.From(organization1.ID),
	}

	err := fieldseekerRodentlocation0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachFieldseekerRodentlocationOrganization0: %w", err)
	}

	return fieldseekerRodentlocation0, nil
}

func (fieldseekerRodentlocation0 *FieldseekerRodentlocation) InsertOrganization(ctx context.Context, exec bob.Executor, related *OrganizationSetter) error {
	var err error

	organization1, err := Organizations.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachFieldseekerRodentlocationOrganization0(ctx, exec, 1, fieldseekerRodentlocation0, organization1)
	if err != nil {
		return err
	}

	fieldseekerRodentlocation0.R.Organization = organization1

	organization1.R.Rodentlocations = append(organization1.R.Rodentlocations, fieldseekerRodentlocation0)

	return nil
}

func (fieldseekerRodentlocation0 *FieldseekerRodentlocation) AttachOrganization(ctx context.Context, exec bob.Executor, organization1 *Organization) error {
	var err error

	_, err = attachFieldseekerRodentlocationOrganization0(ctx, exec, 1, fieldseekerRodentlocation0, organization1)
	if err != nil {
		return err
	}

	fieldseekerRodentlocation0.R.Organization = organization1

	organization1.R.Rodentlocations = append(organization1.R.Rodentlocations, fieldseekerRodentlocation0)

	return nil
}

type fieldseekerRodentlocationWhere[Q psql.Filterable] struct {
	Objectid                  psql.WhereMod[Q, int64]
	Locationname              psql.WhereNullMod[Q, string]
	Zone                      psql.WhereNullMod[Q, string]
	Zone2                     psql.WhereNullMod[Q, string]
	Habitat                   psql.WhereNullMod[Q, string]
	Priority                  psql.WhereNullMod[Q, string]
	Usetype                   psql.WhereNullMod[Q, string]
	Active                    psql.WhereNullMod[Q, int16]
	Description               psql.WhereNullMod[Q, string]
	Accessdesc                psql.WhereNullMod[Q, string]
	Comments                  psql.WhereNullMod[Q, string]
	Symbology                 psql.WhereNullMod[Q, string]
	Externalid                psql.WhereNullMod[Q, string]
	Nextactiondatescheduled   psql.WhereNullMod[Q, time.Time]
	Locationnumber            psql.WhereNullMod[Q, int32]
	Lastinspectdate           psql.WhereNullMod[Q, time.Time]
	Lastinspectspecies        psql.WhereNullMod[Q, string]
	Lastinspectaction         psql.WhereNullMod[Q, string]
	Lastinspectconditions     psql.WhereNullMod[Q, string]
	Lastinspectrodentevidence psql.WhereNullMod[Q, string]
	Globalid                  psql.WhereMod[Q, uuid.UUID]
	CreatedUser               psql.WhereNullMod[Q, string]
	CreatedDate               psql.WhereNullMod[Q, time.Time]
	LastEditedUser            psql.WhereNullMod[Q, string]
	LastEditedDate            psql.WhereNullMod[Q, time.Time]
	Creationdate              psql.WhereNullMod[Q, time.Time]
	Creator                   psql.WhereNullMod[Q, string]
	Editdate                  psql.WhereNullMod[Q, time.Time]
	Editor                    psql.WhereNullMod[Q, string]
	Jurisdiction              psql.WhereNullMod[Q, string]
	Geometry                  psql.WhereMod[Q, types.JSON[json.RawMessage]]
	Geospatial                psql.WhereNullMod[Q, string]
	Version                   psql.WhereMod[Q, int32]
	OrganizationID            psql.WhereMod[Q, int32]
}

func (fieldseekerRodentlocationWhere[Q]) AliasedAs(alias string) fieldseekerRodentlocationWhere[Q] {
	return buildFieldseekerRodentlocationWhere[Q](buildFieldseekerRodentlocationColumns(alias))
}

func buildFieldseekerRodentlocationWhere[Q psql.Filterable](cols fieldseekerRodentlocationColumns) fieldseekerRodentlocationWhere[Q] {
	return fieldseekerRodentlocationWhere[Q]{
		Objectid:                  psql.Where[Q, int64](cols.Objectid),
		Locationname:              psql.WhereNull[Q, string](cols.Locationname),
		Zone:                      psql.WhereNull[Q, string](cols.Zone),
		Zone2:                     psql.WhereNull[Q, string](cols.Zone2),
		Habitat:                   psql.WhereNull[Q, string](cols.Habitat),
		Priority:                  psql.WhereNull[Q, string](cols.Priority),
		Usetype:                   psql.WhereNull[Q, string](cols.Usetype),
		Active:                    psql.WhereNull[Q, int16](cols.Active),
		Description:               psql.WhereNull[Q, string](cols.Description),
		Accessdesc:                psql.WhereNull[Q, string](cols.Accessdesc),
		Comments:                  psql.WhereNull[Q, string](cols.Comments),
		Symbology:                 psql.WhereNull[Q, string](cols.Symbology),
		Externalid:                psql.WhereNull[Q, string](cols.Externalid),
		Nextactiondatescheduled:   psql.WhereNull[Q, time.Time](cols.Nextactiondatescheduled),
		Locationnumber:            psql.WhereNull[Q, int32](cols.Locationnumber),
		Lastinspectdate:           psql.WhereNull[Q, time.Time](cols.Lastinspectdate),
		Lastinspectspecies:        psql.WhereNull[Q, string](cols.Lastinspectspecies),
		Lastinspectaction:         psql.WhereNull[Q, string](cols.Lastinspectaction),
		Lastinspectconditions:     psql.WhereNull[Q, string](cols.Lastinspectconditions),
		Lastinspectrodentevidence: psql.WhereNull[Q, string](cols.Lastinspectrodentevidence),
		Globalid:                  psql.Where[Q, uuid.UUID](cols.Globalid),
		CreatedUser:               psql.WhereNull[Q, string](cols.CreatedUser),
		CreatedDate:               psql.WhereNull[Q, time.Time](cols.CreatedDate),
		LastEditedUser:            psql.WhereNull[Q, string](cols.LastEditedUser),
		LastEditedDate:            psql.WhereNull[Q, time.Time](cols.LastEditedDate),
		Creationdate:              psql.WhereNull[Q, time.Time](cols.Creationdate),
		Creator:                   psql.WhereNull[Q, string](cols.Creator),
		Editdate:                  psql.WhereNull[Q, time.Time](cols.Editdate),
		Editor:                    psql.WhereNull[Q, string](cols.Editor),
		Jurisdiction:              psql.WhereNull[Q, string](cols.Jurisdiction),
		Geometry:                  psql.Where[Q, types.JSON[json.RawMessage]](cols.Geometry),
		Geospatial:                psql.WhereNull[Q, string](cols.Geospatial),
		Version:                   psql.Where[Q, int32](cols.Version),
		OrganizationID:            psql.Where[Q, int32](cols.OrganizationID),
	}
}

func (o *FieldseekerRodentlocation) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Organization":
		rel, ok := retrieved.(*Organization)
		if !ok {
			return fmt.Errorf("fieldseekerRodentlocation cannot load %T as %q", retrieved, name)
		}

		o.R.Organization = rel

		if rel != nil {
			rel.R.Rodentlocations = FieldseekerRodentlocationSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("fieldseekerRodentlocation has no relationship %q", name)
	}
}

type fieldseekerRodentlocationPreloader struct {
	Organization func(...psql.PreloadOption) psql.Preloader
}

func buildFieldseekerRodentlocationPreloader() fieldseekerRodentlocationPreloader {
	return fieldseekerRodentlocationPreloader{
		Organization: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Organization, OrganizationSlice](psql.PreloadRel{
				Name: "Organization",
				Sides: []psql.PreloadSide{
					{
						From:        FieldseekerRodentlocations,
						To:          Organizations,
						FromColumns: []string{"organization_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Organizations.Columns.Names(), opts...)
		},
	}
}

type fieldseekerRodentlocationThenLoader[Q orm.Loadable] struct {
	Organization func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildFieldseekerRodentlocationThenLoader[Q orm.Loadable]() fieldseekerRodentlocationThenLoader[Q] {
	type OrganizationLoadInterface interface {
		LoadOrganization(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return fieldseekerRodentlocationThenLoader[Q]{
		Organization: thenLoadBuilder[Q](
			"Organization",
			func(ctx context.Context, exec bob.Executor, retrieved OrganizationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrganization(ctx, exec, mods...)
			},
		),
	}
}

// LoadOrganization loads the fieldseekerRodentlocation's Organization into the .R struct
func (o *FieldseekerRodentlocation) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Organization = nil

	related, err := o.Organization(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Rodentlocations = FieldseekerRodentlocationSlice{o}

	o.R.Organization = related
	return nil
}

// LoadOrganization loads the fieldseekerRodentlocation's Organization into the .R struct
func (os FieldseekerRodentlocationSlice) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	organizations, err := os.Organization(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range organizations {

			if !(o.OrganizationID == rel.ID) {
				continue
			}

			rel.R.Rodentlocations = append(rel.R.Rodentlocations, o)

			o.R.Organization = rel
			break
		}
	}

	return nil
}

type fieldseekerRodentlocationJoins[Q dialect.Joinable] struct {
	typ          string
	Organization modAs[Q, organizationColumns]
}

func (j fieldseekerRodentlocationJoins[Q]) aliasedAs(alias string) fieldseekerRodentlocationJoins[Q] {
	return buildFieldseekerRodentlocationJoins[Q](buildFieldseekerRodentlocationColumns(alias), j.typ)
}

func buildFieldseekerRodentlocationJoins[Q dialect.Joinable](cols fieldseekerRodentlocationColumns, typ string) fieldseekerRodentlocationJoins[Q] {
	return fieldseekerRodentlocationJoins[Q]{
		typ: typ,
		Organization: modAs[Q, organizationColumns]{
			c: Organizations.Columns,
			f: func(to organizationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Organizations.Name().As(to.Alias())).On(
						to.ID.EQ(cols.OrganizationID),
					))
				}

				return mods
			},
		},
	}
}
