// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// FSTimecard is an object representing the database table.
type FSTimecard struct {
	OrganizationID int32             `db:"organization_id" `
	Activity       null.Val[string]  `db:"activity" `
	Comments       null.Val[string]  `db:"comments" `
	Creationdate   null.Val[int64]   `db:"creationdate" `
	Creator        null.Val[string]  `db:"creator" `
	Enddatetime    null.Val[int64]   `db:"enddatetime" `
	Equiptype      null.Val[string]  `db:"equiptype" `
	Externalid     null.Val[string]  `db:"externalid" `
	Editdate       null.Val[int64]   `db:"editdate" `
	Editor         null.Val[string]  `db:"editor" `
	Fieldtech      null.Val[string]  `db:"fieldtech" `
	Globalid       string            `db:"globalid" `
	Lclocid        null.Val[string]  `db:"lclocid" `
	Linelocid      null.Val[string]  `db:"linelocid" `
	Locationname   null.Val[string]  `db:"locationname" `
	Objectid       int32             `db:"objectid,pk" `
	Pointlocid     null.Val[string]  `db:"pointlocid" `
	Polygonlocid   null.Val[string]  `db:"polygonlocid" `
	Samplelocid    null.Val[string]  `db:"samplelocid" `
	Srid           null.Val[string]  `db:"srid" `
	Startdatetime  null.Val[int64]   `db:"startdatetime" `
	Traplocid      null.Val[string]  `db:"traplocid" `
	Zone           null.Val[string]  `db:"zone" `
	Zone2          null.Val[string]  `db:"zone2" `
	CreatedDate    null.Val[int64]   `db:"created_date" `
	CreatedUser    null.Val[string]  `db:"created_user" `
	GeometryX      null.Val[float64] `db:"geometry_x" `
	GeometryY      null.Val[float64] `db:"geometry_y" `
	LastEditedDate null.Val[int64]   `db:"last_edited_date" `
	LastEditedUser null.Val[string]  `db:"last_edited_user" `
	Rodentlocid    null.Val[string]  `db:"rodentlocid" `
	Updated        time.Time         `db:"updated" `

	R fsTimecardR `db:"-" `
}

// FSTimecardSlice is an alias for a slice of pointers to FSTimecard.
// This should almost always be used instead of []*FSTimecard.
type FSTimecardSlice []*FSTimecard

// FSTimecards contains methods to work with the fs_timecard table
var FSTimecards = psql.NewTablex[*FSTimecard, FSTimecardSlice, *FSTimecardSetter]("", "fs_timecard", buildFSTimecardColumns("fs_timecard"))

// FSTimecardsQuery is a query on the fs_timecard table
type FSTimecardsQuery = *psql.ViewQuery[*FSTimecard, FSTimecardSlice]

// fsTimecardR is where relationships are stored.
type fsTimecardR struct {
	Organization *Organization // fs_timecard.fs_timecard_organization_id_fkey
}

func buildFSTimecardColumns(alias string) fsTimecardColumns {
	return fsTimecardColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"organization_id", "activity", "comments", "creationdate", "creator", "enddatetime", "equiptype", "externalid", "editdate", "editor", "fieldtech", "globalid", "lclocid", "linelocid", "locationname", "objectid", "pointlocid", "polygonlocid", "samplelocid", "srid", "startdatetime", "traplocid", "zone", "zone2", "created_date", "created_user", "geometry_x", "geometry_y", "last_edited_date", "last_edited_user", "rodentlocid", "updated",
		).WithParent("fs_timecard"),
		tableAlias:     alias,
		OrganizationID: psql.Quote(alias, "organization_id"),
		Activity:       psql.Quote(alias, "activity"),
		Comments:       psql.Quote(alias, "comments"),
		Creationdate:   psql.Quote(alias, "creationdate"),
		Creator:        psql.Quote(alias, "creator"),
		Enddatetime:    psql.Quote(alias, "enddatetime"),
		Equiptype:      psql.Quote(alias, "equiptype"),
		Externalid:     psql.Quote(alias, "externalid"),
		Editdate:       psql.Quote(alias, "editdate"),
		Editor:         psql.Quote(alias, "editor"),
		Fieldtech:      psql.Quote(alias, "fieldtech"),
		Globalid:       psql.Quote(alias, "globalid"),
		Lclocid:        psql.Quote(alias, "lclocid"),
		Linelocid:      psql.Quote(alias, "linelocid"),
		Locationname:   psql.Quote(alias, "locationname"),
		Objectid:       psql.Quote(alias, "objectid"),
		Pointlocid:     psql.Quote(alias, "pointlocid"),
		Polygonlocid:   psql.Quote(alias, "polygonlocid"),
		Samplelocid:    psql.Quote(alias, "samplelocid"),
		Srid:           psql.Quote(alias, "srid"),
		Startdatetime:  psql.Quote(alias, "startdatetime"),
		Traplocid:      psql.Quote(alias, "traplocid"),
		Zone:           psql.Quote(alias, "zone"),
		Zone2:          psql.Quote(alias, "zone2"),
		CreatedDate:    psql.Quote(alias, "created_date"),
		CreatedUser:    psql.Quote(alias, "created_user"),
		GeometryX:      psql.Quote(alias, "geometry_x"),
		GeometryY:      psql.Quote(alias, "geometry_y"),
		LastEditedDate: psql.Quote(alias, "last_edited_date"),
		LastEditedUser: psql.Quote(alias, "last_edited_user"),
		Rodentlocid:    psql.Quote(alias, "rodentlocid"),
		Updated:        psql.Quote(alias, "updated"),
	}
}

type fsTimecardColumns struct {
	expr.ColumnsExpr
	tableAlias     string
	OrganizationID psql.Expression
	Activity       psql.Expression
	Comments       psql.Expression
	Creationdate   psql.Expression
	Creator        psql.Expression
	Enddatetime    psql.Expression
	Equiptype      psql.Expression
	Externalid     psql.Expression
	Editdate       psql.Expression
	Editor         psql.Expression
	Fieldtech      psql.Expression
	Globalid       psql.Expression
	Lclocid        psql.Expression
	Linelocid      psql.Expression
	Locationname   psql.Expression
	Objectid       psql.Expression
	Pointlocid     psql.Expression
	Polygonlocid   psql.Expression
	Samplelocid    psql.Expression
	Srid           psql.Expression
	Startdatetime  psql.Expression
	Traplocid      psql.Expression
	Zone           psql.Expression
	Zone2          psql.Expression
	CreatedDate    psql.Expression
	CreatedUser    psql.Expression
	GeometryX      psql.Expression
	GeometryY      psql.Expression
	LastEditedDate psql.Expression
	LastEditedUser psql.Expression
	Rodentlocid    psql.Expression
	Updated        psql.Expression
}

func (c fsTimecardColumns) Alias() string {
	return c.tableAlias
}

func (fsTimecardColumns) AliasedAs(alias string) fsTimecardColumns {
	return buildFSTimecardColumns(alias)
}

// FSTimecardSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type FSTimecardSetter struct {
	OrganizationID omit.Val[int32]       `db:"organization_id" `
	Activity       omitnull.Val[string]  `db:"activity" `
	Comments       omitnull.Val[string]  `db:"comments" `
	Creationdate   omitnull.Val[int64]   `db:"creationdate" `
	Creator        omitnull.Val[string]  `db:"creator" `
	Enddatetime    omitnull.Val[int64]   `db:"enddatetime" `
	Equiptype      omitnull.Val[string]  `db:"equiptype" `
	Externalid     omitnull.Val[string]  `db:"externalid" `
	Editdate       omitnull.Val[int64]   `db:"editdate" `
	Editor         omitnull.Val[string]  `db:"editor" `
	Fieldtech      omitnull.Val[string]  `db:"fieldtech" `
	Globalid       omit.Val[string]      `db:"globalid" `
	Lclocid        omitnull.Val[string]  `db:"lclocid" `
	Linelocid      omitnull.Val[string]  `db:"linelocid" `
	Locationname   omitnull.Val[string]  `db:"locationname" `
	Objectid       omit.Val[int32]       `db:"objectid,pk" `
	Pointlocid     omitnull.Val[string]  `db:"pointlocid" `
	Polygonlocid   omitnull.Val[string]  `db:"polygonlocid" `
	Samplelocid    omitnull.Val[string]  `db:"samplelocid" `
	Srid           omitnull.Val[string]  `db:"srid" `
	Startdatetime  omitnull.Val[int64]   `db:"startdatetime" `
	Traplocid      omitnull.Val[string]  `db:"traplocid" `
	Zone           omitnull.Val[string]  `db:"zone" `
	Zone2          omitnull.Val[string]  `db:"zone2" `
	CreatedDate    omitnull.Val[int64]   `db:"created_date" `
	CreatedUser    omitnull.Val[string]  `db:"created_user" `
	GeometryX      omitnull.Val[float64] `db:"geometry_x" `
	GeometryY      omitnull.Val[float64] `db:"geometry_y" `
	LastEditedDate omitnull.Val[int64]   `db:"last_edited_date" `
	LastEditedUser omitnull.Val[string]  `db:"last_edited_user" `
	Rodentlocid    omitnull.Val[string]  `db:"rodentlocid" `
	Updated        omit.Val[time.Time]   `db:"updated" `
}

func (s FSTimecardSetter) SetColumns() []string {
	vals := make([]string, 0, 32)
	if s.OrganizationID.IsValue() {
		vals = append(vals, "organization_id")
	}
	if !s.Activity.IsUnset() {
		vals = append(vals, "activity")
	}
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Enddatetime.IsUnset() {
		vals = append(vals, "enddatetime")
	}
	if !s.Equiptype.IsUnset() {
		vals = append(vals, "equiptype")
	}
	if !s.Externalid.IsUnset() {
		vals = append(vals, "externalid")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if !s.Fieldtech.IsUnset() {
		vals = append(vals, "fieldtech")
	}
	if s.Globalid.IsValue() {
		vals = append(vals, "globalid")
	}
	if !s.Lclocid.IsUnset() {
		vals = append(vals, "lclocid")
	}
	if !s.Linelocid.IsUnset() {
		vals = append(vals, "linelocid")
	}
	if !s.Locationname.IsUnset() {
		vals = append(vals, "locationname")
	}
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.Pointlocid.IsUnset() {
		vals = append(vals, "pointlocid")
	}
	if !s.Polygonlocid.IsUnset() {
		vals = append(vals, "polygonlocid")
	}
	if !s.Samplelocid.IsUnset() {
		vals = append(vals, "samplelocid")
	}
	if !s.Srid.IsUnset() {
		vals = append(vals, "srid")
	}
	if !s.Startdatetime.IsUnset() {
		vals = append(vals, "startdatetime")
	}
	if !s.Traplocid.IsUnset() {
		vals = append(vals, "traplocid")
	}
	if !s.Zone.IsUnset() {
		vals = append(vals, "zone")
	}
	if !s.Zone2.IsUnset() {
		vals = append(vals, "zone2")
	}
	if !s.CreatedDate.IsUnset() {
		vals = append(vals, "created_date")
	}
	if !s.CreatedUser.IsUnset() {
		vals = append(vals, "created_user")
	}
	if !s.GeometryX.IsUnset() {
		vals = append(vals, "geometry_x")
	}
	if !s.GeometryY.IsUnset() {
		vals = append(vals, "geometry_y")
	}
	if !s.LastEditedDate.IsUnset() {
		vals = append(vals, "last_edited_date")
	}
	if !s.LastEditedUser.IsUnset() {
		vals = append(vals, "last_edited_user")
	}
	if !s.Rodentlocid.IsUnset() {
		vals = append(vals, "rodentlocid")
	}
	if s.Updated.IsValue() {
		vals = append(vals, "updated")
	}
	return vals
}

func (s FSTimecardSetter) Overwrite(t *FSTimecard) {
	if s.OrganizationID.IsValue() {
		t.OrganizationID = s.OrganizationID.MustGet()
	}
	if !s.Activity.IsUnset() {
		t.Activity = s.Activity.MustGetNull()
	}
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Enddatetime.IsUnset() {
		t.Enddatetime = s.Enddatetime.MustGetNull()
	}
	if !s.Equiptype.IsUnset() {
		t.Equiptype = s.Equiptype.MustGetNull()
	}
	if !s.Externalid.IsUnset() {
		t.Externalid = s.Externalid.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if !s.Fieldtech.IsUnset() {
		t.Fieldtech = s.Fieldtech.MustGetNull()
	}
	if s.Globalid.IsValue() {
		t.Globalid = s.Globalid.MustGet()
	}
	if !s.Lclocid.IsUnset() {
		t.Lclocid = s.Lclocid.MustGetNull()
	}
	if !s.Linelocid.IsUnset() {
		t.Linelocid = s.Linelocid.MustGetNull()
	}
	if !s.Locationname.IsUnset() {
		t.Locationname = s.Locationname.MustGetNull()
	}
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.Pointlocid.IsUnset() {
		t.Pointlocid = s.Pointlocid.MustGetNull()
	}
	if !s.Polygonlocid.IsUnset() {
		t.Polygonlocid = s.Polygonlocid.MustGetNull()
	}
	if !s.Samplelocid.IsUnset() {
		t.Samplelocid = s.Samplelocid.MustGetNull()
	}
	if !s.Srid.IsUnset() {
		t.Srid = s.Srid.MustGetNull()
	}
	if !s.Startdatetime.IsUnset() {
		t.Startdatetime = s.Startdatetime.MustGetNull()
	}
	if !s.Traplocid.IsUnset() {
		t.Traplocid = s.Traplocid.MustGetNull()
	}
	if !s.Zone.IsUnset() {
		t.Zone = s.Zone.MustGetNull()
	}
	if !s.Zone2.IsUnset() {
		t.Zone2 = s.Zone2.MustGetNull()
	}
	if !s.CreatedDate.IsUnset() {
		t.CreatedDate = s.CreatedDate.MustGetNull()
	}
	if !s.CreatedUser.IsUnset() {
		t.CreatedUser = s.CreatedUser.MustGetNull()
	}
	if !s.GeometryX.IsUnset() {
		t.GeometryX = s.GeometryX.MustGetNull()
	}
	if !s.GeometryY.IsUnset() {
		t.GeometryY = s.GeometryY.MustGetNull()
	}
	if !s.LastEditedDate.IsUnset() {
		t.LastEditedDate = s.LastEditedDate.MustGetNull()
	}
	if !s.LastEditedUser.IsUnset() {
		t.LastEditedUser = s.LastEditedUser.MustGetNull()
	}
	if !s.Rodentlocid.IsUnset() {
		t.Rodentlocid = s.Rodentlocid.MustGetNull()
	}
	if s.Updated.IsValue() {
		t.Updated = s.Updated.MustGet()
	}
}

func (s *FSTimecardSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return FSTimecards.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 32)
		if s.OrganizationID.IsValue() {
			vals[0] = psql.Arg(s.OrganizationID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Activity.IsUnset() {
			vals[1] = psql.Arg(s.Activity.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Comments.IsUnset() {
			vals[2] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[3] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[4] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Enddatetime.IsUnset() {
			vals[5] = psql.Arg(s.Enddatetime.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Equiptype.IsUnset() {
			vals[6] = psql.Arg(s.Equiptype.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Externalid.IsUnset() {
			vals[7] = psql.Arg(s.Externalid.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[8] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[9] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Fieldtech.IsUnset() {
			vals[10] = psql.Arg(s.Fieldtech.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.Globalid.IsValue() {
			vals[11] = psql.Arg(s.Globalid.MustGet())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.Lclocid.IsUnset() {
			vals[12] = psql.Arg(s.Lclocid.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Linelocid.IsUnset() {
			vals[13] = psql.Arg(s.Linelocid.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.Locationname.IsUnset() {
			vals[14] = psql.Arg(s.Locationname.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.Objectid.IsValue() {
			vals[15] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.Pointlocid.IsUnset() {
			vals[16] = psql.Arg(s.Pointlocid.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.Polygonlocid.IsUnset() {
			vals[17] = psql.Arg(s.Polygonlocid.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Samplelocid.IsUnset() {
			vals[18] = psql.Arg(s.Samplelocid.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Srid.IsUnset() {
			vals[19] = psql.Arg(s.Srid.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.Startdatetime.IsUnset() {
			vals[20] = psql.Arg(s.Startdatetime.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.Traplocid.IsUnset() {
			vals[21] = psql.Arg(s.Traplocid.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.Zone.IsUnset() {
			vals[22] = psql.Arg(s.Zone.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if !s.Zone2.IsUnset() {
			vals[23] = psql.Arg(s.Zone2.MustGetNull())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.CreatedDate.IsUnset() {
			vals[24] = psql.Arg(s.CreatedDate.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.CreatedUser.IsUnset() {
			vals[25] = psql.Arg(s.CreatedUser.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.GeometryX.IsUnset() {
			vals[26] = psql.Arg(s.GeometryX.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.GeometryY.IsUnset() {
			vals[27] = psql.Arg(s.GeometryY.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedDate.IsUnset() {
			vals[28] = psql.Arg(s.LastEditedDate.MustGetNull())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if !s.LastEditedUser.IsUnset() {
			vals[29] = psql.Arg(s.LastEditedUser.MustGetNull())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if !s.Rodentlocid.IsUnset() {
			vals[30] = psql.Arg(s.Rodentlocid.MustGetNull())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		if s.Updated.IsValue() {
			vals[31] = psql.Arg(s.Updated.MustGet())
		} else {
			vals[31] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s FSTimecardSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s FSTimecardSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 32)

	if s.OrganizationID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "organization_id")...),
			psql.Arg(s.OrganizationID),
		}})
	}

	if !s.Activity.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "activity")...),
			psql.Arg(s.Activity),
		}})
	}

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Enddatetime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "enddatetime")...),
			psql.Arg(s.Enddatetime),
		}})
	}

	if !s.Equiptype.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "equiptype")...),
			psql.Arg(s.Equiptype),
		}})
	}

	if !s.Externalid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "externalid")...),
			psql.Arg(s.Externalid),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if !s.Fieldtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "fieldtech")...),
			psql.Arg(s.Fieldtech),
		}})
	}

	if s.Globalid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.Lclocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "lclocid")...),
			psql.Arg(s.Lclocid),
		}})
	}

	if !s.Linelocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "linelocid")...),
			psql.Arg(s.Linelocid),
		}})
	}

	if !s.Locationname.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "locationname")...),
			psql.Arg(s.Locationname),
		}})
	}

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.Pointlocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "pointlocid")...),
			psql.Arg(s.Pointlocid),
		}})
	}

	if !s.Polygonlocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "polygonlocid")...),
			psql.Arg(s.Polygonlocid),
		}})
	}

	if !s.Samplelocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "samplelocid")...),
			psql.Arg(s.Samplelocid),
		}})
	}

	if !s.Srid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "srid")...),
			psql.Arg(s.Srid),
		}})
	}

	if !s.Startdatetime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "startdatetime")...),
			psql.Arg(s.Startdatetime),
		}})
	}

	if !s.Traplocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "traplocid")...),
			psql.Arg(s.Traplocid),
		}})
	}

	if !s.Zone.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone")...),
			psql.Arg(s.Zone),
		}})
	}

	if !s.Zone2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone2")...),
			psql.Arg(s.Zone2),
		}})
	}

	if !s.CreatedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_date")...),
			psql.Arg(s.CreatedDate),
		}})
	}

	if !s.CreatedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_user")...),
			psql.Arg(s.CreatedUser),
		}})
	}

	if !s.GeometryX.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_x")...),
			psql.Arg(s.GeometryX),
		}})
	}

	if !s.GeometryY.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_y")...),
			psql.Arg(s.GeometryY),
		}})
	}

	if !s.LastEditedDate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_date")...),
			psql.Arg(s.LastEditedDate),
		}})
	}

	if !s.LastEditedUser.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "last_edited_user")...),
			psql.Arg(s.LastEditedUser),
		}})
	}

	if !s.Rodentlocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "rodentlocid")...),
			psql.Arg(s.Rodentlocid),
		}})
	}

	if s.Updated.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated")...),
			psql.Arg(s.Updated),
		}})
	}

	return exprs
}

// FindFSTimecard retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindFSTimecard(ctx context.Context, exec bob.Executor, ObjectidPK int32, cols ...string) (*FSTimecard, error) {
	if len(cols) == 0 {
		return FSTimecards.Query(
			sm.Where(FSTimecards.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		).One(ctx, exec)
	}

	return FSTimecards.Query(
		sm.Where(FSTimecards.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Columns(FSTimecards.Columns.Only(cols...)),
	).One(ctx, exec)
}

// FSTimecardExists checks the presence of a single record by primary key
func FSTimecardExists(ctx context.Context, exec bob.Executor, ObjectidPK int32) (bool, error) {
	return FSTimecards.Query(
		sm.Where(FSTimecards.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after FSTimecard is retrieved from the database
func (o *FSTimecard) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FSTimecards.AfterSelectHooks.RunHooks(ctx, exec, FSTimecardSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = FSTimecards.AfterInsertHooks.RunHooks(ctx, exec, FSTimecardSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = FSTimecards.AfterUpdateHooks.RunHooks(ctx, exec, FSTimecardSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = FSTimecards.AfterDeleteHooks.RunHooks(ctx, exec, FSTimecardSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the FSTimecard
func (o *FSTimecard) primaryKeyVals() bob.Expression {
	return psql.Arg(o.Objectid)
}

func (o *FSTimecard) pkEQ() dialect.Expression {
	return psql.Quote("fs_timecard", "objectid").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the FSTimecard
func (o *FSTimecard) Update(ctx context.Context, exec bob.Executor, s *FSTimecardSetter) error {
	v, err := FSTimecards.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single FSTimecard record with an executor
func (o *FSTimecard) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := FSTimecards.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the FSTimecard using the executor
func (o *FSTimecard) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := FSTimecards.Query(
		sm.Where(FSTimecards.Columns.Objectid.EQ(psql.Arg(o.Objectid))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after FSTimecardSlice is retrieved from the database
func (o FSTimecardSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FSTimecards.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = FSTimecards.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = FSTimecards.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = FSTimecards.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o FSTimecardSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("fs_timecard", "objectid").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o FSTimecardSlice) copyMatchingRows(from ...*FSTimecard) {
	for i, old := range o {
		for _, new := range from {
			if new.Objectid != old.Objectid {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o FSTimecardSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FSTimecards.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FSTimecard:
				o.copyMatchingRows(retrieved)
			case []*FSTimecard:
				o.copyMatchingRows(retrieved...)
			case FSTimecardSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FSTimecard or a slice of FSTimecard
				// then run the AfterUpdateHooks on the slice
				_, err = FSTimecards.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o FSTimecardSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FSTimecards.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FSTimecard:
				o.copyMatchingRows(retrieved)
			case []*FSTimecard:
				o.copyMatchingRows(retrieved...)
			case FSTimecardSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FSTimecard or a slice of FSTimecard
				// then run the AfterDeleteHooks on the slice
				_, err = FSTimecards.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o FSTimecardSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals FSTimecardSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FSTimecards.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o FSTimecardSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FSTimecards.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o FSTimecardSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := FSTimecards.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// Organization starts a query for related objects on organization
func (o *FSTimecard) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	return Organizations.Query(append(mods,
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.OrganizationID))),
	)...)
}

func (os FSTimecardSlice) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	pkOrganizationID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkOrganizationID = append(pkOrganizationID, o.OrganizationID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkOrganizationID), "integer[]")),
	))

	return Organizations.Query(append(mods,
		sm.Where(psql.Group(Organizations.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

func attachFSTimecardOrganization0(ctx context.Context, exec bob.Executor, count int, fsTimecard0 *FSTimecard, organization1 *Organization) (*FSTimecard, error) {
	setter := &FSTimecardSetter{
		OrganizationID: omit.From(organization1.ID),
	}

	err := fsTimecard0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachFSTimecardOrganization0: %w", err)
	}

	return fsTimecard0, nil
}

func (fsTimecard0 *FSTimecard) InsertOrganization(ctx context.Context, exec bob.Executor, related *OrganizationSetter) error {
	var err error

	organization1, err := Organizations.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachFSTimecardOrganization0(ctx, exec, 1, fsTimecard0, organization1)
	if err != nil {
		return err
	}

	fsTimecard0.R.Organization = organization1

	organization1.R.FSTimecards = append(organization1.R.FSTimecards, fsTimecard0)

	return nil
}

func (fsTimecard0 *FSTimecard) AttachOrganization(ctx context.Context, exec bob.Executor, organization1 *Organization) error {
	var err error

	_, err = attachFSTimecardOrganization0(ctx, exec, 1, fsTimecard0, organization1)
	if err != nil {
		return err
	}

	fsTimecard0.R.Organization = organization1

	organization1.R.FSTimecards = append(organization1.R.FSTimecards, fsTimecard0)

	return nil
}

type fsTimecardWhere[Q psql.Filterable] struct {
	OrganizationID psql.WhereMod[Q, int32]
	Activity       psql.WhereNullMod[Q, string]
	Comments       psql.WhereNullMod[Q, string]
	Creationdate   psql.WhereNullMod[Q, int64]
	Creator        psql.WhereNullMod[Q, string]
	Enddatetime    psql.WhereNullMod[Q, int64]
	Equiptype      psql.WhereNullMod[Q, string]
	Externalid     psql.WhereNullMod[Q, string]
	Editdate       psql.WhereNullMod[Q, int64]
	Editor         psql.WhereNullMod[Q, string]
	Fieldtech      psql.WhereNullMod[Q, string]
	Globalid       psql.WhereMod[Q, string]
	Lclocid        psql.WhereNullMod[Q, string]
	Linelocid      psql.WhereNullMod[Q, string]
	Locationname   psql.WhereNullMod[Q, string]
	Objectid       psql.WhereMod[Q, int32]
	Pointlocid     psql.WhereNullMod[Q, string]
	Polygonlocid   psql.WhereNullMod[Q, string]
	Samplelocid    psql.WhereNullMod[Q, string]
	Srid           psql.WhereNullMod[Q, string]
	Startdatetime  psql.WhereNullMod[Q, int64]
	Traplocid      psql.WhereNullMod[Q, string]
	Zone           psql.WhereNullMod[Q, string]
	Zone2          psql.WhereNullMod[Q, string]
	CreatedDate    psql.WhereNullMod[Q, int64]
	CreatedUser    psql.WhereNullMod[Q, string]
	GeometryX      psql.WhereNullMod[Q, float64]
	GeometryY      psql.WhereNullMod[Q, float64]
	LastEditedDate psql.WhereNullMod[Q, int64]
	LastEditedUser psql.WhereNullMod[Q, string]
	Rodentlocid    psql.WhereNullMod[Q, string]
	Updated        psql.WhereMod[Q, time.Time]
}

func (fsTimecardWhere[Q]) AliasedAs(alias string) fsTimecardWhere[Q] {
	return buildFSTimecardWhere[Q](buildFSTimecardColumns(alias))
}

func buildFSTimecardWhere[Q psql.Filterable](cols fsTimecardColumns) fsTimecardWhere[Q] {
	return fsTimecardWhere[Q]{
		OrganizationID: psql.Where[Q, int32](cols.OrganizationID),
		Activity:       psql.WhereNull[Q, string](cols.Activity),
		Comments:       psql.WhereNull[Q, string](cols.Comments),
		Creationdate:   psql.WhereNull[Q, int64](cols.Creationdate),
		Creator:        psql.WhereNull[Q, string](cols.Creator),
		Enddatetime:    psql.WhereNull[Q, int64](cols.Enddatetime),
		Equiptype:      psql.WhereNull[Q, string](cols.Equiptype),
		Externalid:     psql.WhereNull[Q, string](cols.Externalid),
		Editdate:       psql.WhereNull[Q, int64](cols.Editdate),
		Editor:         psql.WhereNull[Q, string](cols.Editor),
		Fieldtech:      psql.WhereNull[Q, string](cols.Fieldtech),
		Globalid:       psql.Where[Q, string](cols.Globalid),
		Lclocid:        psql.WhereNull[Q, string](cols.Lclocid),
		Linelocid:      psql.WhereNull[Q, string](cols.Linelocid),
		Locationname:   psql.WhereNull[Q, string](cols.Locationname),
		Objectid:       psql.Where[Q, int32](cols.Objectid),
		Pointlocid:     psql.WhereNull[Q, string](cols.Pointlocid),
		Polygonlocid:   psql.WhereNull[Q, string](cols.Polygonlocid),
		Samplelocid:    psql.WhereNull[Q, string](cols.Samplelocid),
		Srid:           psql.WhereNull[Q, string](cols.Srid),
		Startdatetime:  psql.WhereNull[Q, int64](cols.Startdatetime),
		Traplocid:      psql.WhereNull[Q, string](cols.Traplocid),
		Zone:           psql.WhereNull[Q, string](cols.Zone),
		Zone2:          psql.WhereNull[Q, string](cols.Zone2),
		CreatedDate:    psql.WhereNull[Q, int64](cols.CreatedDate),
		CreatedUser:    psql.WhereNull[Q, string](cols.CreatedUser),
		GeometryX:      psql.WhereNull[Q, float64](cols.GeometryX),
		GeometryY:      psql.WhereNull[Q, float64](cols.GeometryY),
		LastEditedDate: psql.WhereNull[Q, int64](cols.LastEditedDate),
		LastEditedUser: psql.WhereNull[Q, string](cols.LastEditedUser),
		Rodentlocid:    psql.WhereNull[Q, string](cols.Rodentlocid),
		Updated:        psql.Where[Q, time.Time](cols.Updated),
	}
}

func (o *FSTimecard) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Organization":
		rel, ok := retrieved.(*Organization)
		if !ok {
			return fmt.Errorf("fsTimecard cannot load %T as %q", retrieved, name)
		}

		o.R.Organization = rel

		if rel != nil {
			rel.R.FSTimecards = FSTimecardSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("fsTimecard has no relationship %q", name)
	}
}

type fsTimecardPreloader struct {
	Organization func(...psql.PreloadOption) psql.Preloader
}

func buildFSTimecardPreloader() fsTimecardPreloader {
	return fsTimecardPreloader{
		Organization: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Organization, OrganizationSlice](psql.PreloadRel{
				Name: "Organization",
				Sides: []psql.PreloadSide{
					{
						From:        FSTimecards,
						To:          Organizations,
						FromColumns: []string{"organization_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Organizations.Columns.Names(), opts...)
		},
	}
}

type fsTimecardThenLoader[Q orm.Loadable] struct {
	Organization func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildFSTimecardThenLoader[Q orm.Loadable]() fsTimecardThenLoader[Q] {
	type OrganizationLoadInterface interface {
		LoadOrganization(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return fsTimecardThenLoader[Q]{
		Organization: thenLoadBuilder[Q](
			"Organization",
			func(ctx context.Context, exec bob.Executor, retrieved OrganizationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrganization(ctx, exec, mods...)
			},
		),
	}
}

// LoadOrganization loads the fsTimecard's Organization into the .R struct
func (o *FSTimecard) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Organization = nil

	related, err := o.Organization(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.FSTimecards = FSTimecardSlice{o}

	o.R.Organization = related
	return nil
}

// LoadOrganization loads the fsTimecard's Organization into the .R struct
func (os FSTimecardSlice) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	organizations, err := os.Organization(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range organizations {

			if !(o.OrganizationID == rel.ID) {
				continue
			}

			rel.R.FSTimecards = append(rel.R.FSTimecards, o)

			o.R.Organization = rel
			break
		}
	}

	return nil
}

type fsTimecardJoins[Q dialect.Joinable] struct {
	typ          string
	Organization modAs[Q, organizationColumns]
}

func (j fsTimecardJoins[Q]) aliasedAs(alias string) fsTimecardJoins[Q] {
	return buildFSTimecardJoins[Q](buildFSTimecardColumns(alias), j.typ)
}

func buildFSTimecardJoins[Q dialect.Joinable](cols fsTimecardColumns, typ string) fsTimecardJoins[Q] {
	return fsTimecardJoins[Q]{
		typ: typ,
		Organization: modAs[Q, organizationColumns]{
			c: Organizations.Columns,
			f: func(to organizationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Organizations.Name().As(to.Alias())).On(
						to.ID.EQ(cols.OrganizationID),
					))
				}

				return mods
			},
		},
	}
}
