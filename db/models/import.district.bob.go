// Code generated by BobGen psql v0.42.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"

	"github.com/Gleipnir-Technology/bob"
	"github.com/Gleipnir-Technology/bob/dialect/psql"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dialect"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dm"
	"github.com/Gleipnir-Technology/bob/dialect/psql/sm"
	"github.com/Gleipnir-Technology/bob/dialect/psql/um"
	"github.com/Gleipnir-Technology/bob/expr"
	"github.com/Gleipnir-Technology/bob/mods"
	"github.com/Gleipnir-Technology/bob/orm"
	"github.com/Gleipnir-Technology/bob/types/pgtypes"
	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/shopspring/decimal"
)

// ImportDistrict is an object representing the database table.
type ImportDistrict struct {
	Gid          int32                     `db:"gid,pk" `
	ID           null.Val[decimal.Decimal] `db:"id" `
	Website      null.Val[string]          `db:"website" `
	Contact      null.Val[string]          `db:"contact" `
	Address      null.Val[string]          `db:"address" `
	Regionid     null.Val[decimal.Decimal] `db:"regionid" `
	PostalCod    null.Val[decimal.Decimal] `db:"postal_cod" `
	Phone1       null.Val[string]          `db:"phone1" `
	Fax1         null.Val[string]          `db:"fax1" `
	Agency       null.Val[string]          `db:"agency" `
	Code1        null.Val[string]          `db:"code1" `
	City1        null.Val[string]          `db:"city1" `
	ShapeLeng    null.Val[decimal.Decimal] `db:"shape_leng" `
	Address2     null.Val[string]          `db:"address2" `
	GeneralMG    null.Val[string]          `db:"general_mg" `
	City2        null.Val[string]          `db:"city2" `
	PostalC1     null.Val[decimal.Decimal] `db:"postal_c_1" `
	Fax2         null.Val[string]          `db:"fax2" `
	Phone2       null.Val[string]          `db:"phone2" `
	ShapeLe1     null.Val[decimal.Decimal] `db:"shape_le_1" `
	ShapeArea    null.Val[decimal.Decimal] `db:"shape_area" `
	Geom         null.Val[string]          `db:"geom" `
	Geom4326     null.Val[string]          `db:"geom_4326,generated" `
	Centroid4326 null.Val[string]          `db:"centroid_4326,generated" `
	Extent4326   null.Val[string]          `db:"extent_4326,generated" `

	R importDistrictR `db:"-" `
}

// ImportDistrictSlice is an alias for a slice of pointers to ImportDistrict.
// This should almost always be used instead of []*ImportDistrict.
type ImportDistrictSlice []*ImportDistrict

// ImportDistricts contains methods to work with the district table
var ImportDistricts = psql.NewTablex[*ImportDistrict, ImportDistrictSlice, *ImportDistrictSetter]("import", "district", buildImportDistrictColumns("import.district"))

// ImportDistrictsQuery is a query on the district table
type ImportDistrictsQuery = *psql.ViewQuery[*ImportDistrict, ImportDistrictSlice]

// importDistrictR is where relationships are stored.
type importDistrictR struct {
	ImportDistrictGidOrganization *Organization // organization.organization_import_district_gid_fkey
}

func buildImportDistrictColumns(alias string) importDistrictColumns {
	return importDistrictColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"gid", "id", "website", "contact", "address", "regionid", "postal_cod", "phone1", "fax1", "agency", "code1", "city1", "shape_leng", "address2", "general_mg", "city2", "postal_c_1", "fax2", "phone2", "shape_le_1", "shape_area", "geom", "geom_4326", "centroid_4326", "extent_4326",
		).WithParent("import.district"),
		tableAlias:   alias,
		Gid:          psql.Quote(alias, "gid"),
		ID:           psql.Quote(alias, "id"),
		Website:      psql.Quote(alias, "website"),
		Contact:      psql.Quote(alias, "contact"),
		Address:      psql.Quote(alias, "address"),
		Regionid:     psql.Quote(alias, "regionid"),
		PostalCod:    psql.Quote(alias, "postal_cod"),
		Phone1:       psql.Quote(alias, "phone1"),
		Fax1:         psql.Quote(alias, "fax1"),
		Agency:       psql.Quote(alias, "agency"),
		Code1:        psql.Quote(alias, "code1"),
		City1:        psql.Quote(alias, "city1"),
		ShapeLeng:    psql.Quote(alias, "shape_leng"),
		Address2:     psql.Quote(alias, "address2"),
		GeneralMG:    psql.Quote(alias, "general_mg"),
		City2:        psql.Quote(alias, "city2"),
		PostalC1:     psql.Quote(alias, "postal_c_1"),
		Fax2:         psql.Quote(alias, "fax2"),
		Phone2:       psql.Quote(alias, "phone2"),
		ShapeLe1:     psql.Quote(alias, "shape_le_1"),
		ShapeArea:    psql.Quote(alias, "shape_area"),
		Geom:         psql.Quote(alias, "geom"),
		Geom4326:     psql.Quote(alias, "geom_4326"),
		Centroid4326: psql.Quote(alias, "centroid_4326"),
		Extent4326:   psql.Quote(alias, "extent_4326"),
	}
}

type importDistrictColumns struct {
	expr.ColumnsExpr
	tableAlias   string
	Gid          psql.Expression
	ID           psql.Expression
	Website      psql.Expression
	Contact      psql.Expression
	Address      psql.Expression
	Regionid     psql.Expression
	PostalCod    psql.Expression
	Phone1       psql.Expression
	Fax1         psql.Expression
	Agency       psql.Expression
	Code1        psql.Expression
	City1        psql.Expression
	ShapeLeng    psql.Expression
	Address2     psql.Expression
	GeneralMG    psql.Expression
	City2        psql.Expression
	PostalC1     psql.Expression
	Fax2         psql.Expression
	Phone2       psql.Expression
	ShapeLe1     psql.Expression
	ShapeArea    psql.Expression
	Geom         psql.Expression
	Geom4326     psql.Expression
	Centroid4326 psql.Expression
	Extent4326   psql.Expression
}

func (c importDistrictColumns) Alias() string {
	return c.tableAlias
}

func (importDistrictColumns) AliasedAs(alias string) importDistrictColumns {
	return buildImportDistrictColumns(alias)
}

// ImportDistrictSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type ImportDistrictSetter struct {
	Gid       omit.Val[int32]               `db:"gid,pk" `
	ID        omitnull.Val[decimal.Decimal] `db:"id" `
	Website   omitnull.Val[string]          `db:"website" `
	Contact   omitnull.Val[string]          `db:"contact" `
	Address   omitnull.Val[string]          `db:"address" `
	Regionid  omitnull.Val[decimal.Decimal] `db:"regionid" `
	PostalCod omitnull.Val[decimal.Decimal] `db:"postal_cod" `
	Phone1    omitnull.Val[string]          `db:"phone1" `
	Fax1      omitnull.Val[string]          `db:"fax1" `
	Agency    omitnull.Val[string]          `db:"agency" `
	Code1     omitnull.Val[string]          `db:"code1" `
	City1     omitnull.Val[string]          `db:"city1" `
	ShapeLeng omitnull.Val[decimal.Decimal] `db:"shape_leng" `
	Address2  omitnull.Val[string]          `db:"address2" `
	GeneralMG omitnull.Val[string]          `db:"general_mg" `
	City2     omitnull.Val[string]          `db:"city2" `
	PostalC1  omitnull.Val[decimal.Decimal] `db:"postal_c_1" `
	Fax2      omitnull.Val[string]          `db:"fax2" `
	Phone2    omitnull.Val[string]          `db:"phone2" `
	ShapeLe1  omitnull.Val[decimal.Decimal] `db:"shape_le_1" `
	ShapeArea omitnull.Val[decimal.Decimal] `db:"shape_area" `
	Geom      omitnull.Val[string]          `db:"geom" `
}

func (s ImportDistrictSetter) SetColumns() []string {
	vals := make([]string, 0, 22)
	if s.Gid.IsValue() {
		vals = append(vals, "gid")
	}
	if !s.ID.IsUnset() {
		vals = append(vals, "id")
	}
	if !s.Website.IsUnset() {
		vals = append(vals, "website")
	}
	if !s.Contact.IsUnset() {
		vals = append(vals, "contact")
	}
	if !s.Address.IsUnset() {
		vals = append(vals, "address")
	}
	if !s.Regionid.IsUnset() {
		vals = append(vals, "regionid")
	}
	if !s.PostalCod.IsUnset() {
		vals = append(vals, "postal_cod")
	}
	if !s.Phone1.IsUnset() {
		vals = append(vals, "phone1")
	}
	if !s.Fax1.IsUnset() {
		vals = append(vals, "fax1")
	}
	if !s.Agency.IsUnset() {
		vals = append(vals, "agency")
	}
	if !s.Code1.IsUnset() {
		vals = append(vals, "code1")
	}
	if !s.City1.IsUnset() {
		vals = append(vals, "city1")
	}
	if !s.ShapeLeng.IsUnset() {
		vals = append(vals, "shape_leng")
	}
	if !s.Address2.IsUnset() {
		vals = append(vals, "address2")
	}
	if !s.GeneralMG.IsUnset() {
		vals = append(vals, "general_mg")
	}
	if !s.City2.IsUnset() {
		vals = append(vals, "city2")
	}
	if !s.PostalC1.IsUnset() {
		vals = append(vals, "postal_c_1")
	}
	if !s.Fax2.IsUnset() {
		vals = append(vals, "fax2")
	}
	if !s.Phone2.IsUnset() {
		vals = append(vals, "phone2")
	}
	if !s.ShapeLe1.IsUnset() {
		vals = append(vals, "shape_le_1")
	}
	if !s.ShapeArea.IsUnset() {
		vals = append(vals, "shape_area")
	}
	if !s.Geom.IsUnset() {
		vals = append(vals, "geom")
	}
	return vals
}

func (s ImportDistrictSetter) Overwrite(t *ImportDistrict) {
	if s.Gid.IsValue() {
		t.Gid = s.Gid.MustGet()
	}
	if !s.ID.IsUnset() {
		t.ID = s.ID.MustGetNull()
	}
	if !s.Website.IsUnset() {
		t.Website = s.Website.MustGetNull()
	}
	if !s.Contact.IsUnset() {
		t.Contact = s.Contact.MustGetNull()
	}
	if !s.Address.IsUnset() {
		t.Address = s.Address.MustGetNull()
	}
	if !s.Regionid.IsUnset() {
		t.Regionid = s.Regionid.MustGetNull()
	}
	if !s.PostalCod.IsUnset() {
		t.PostalCod = s.PostalCod.MustGetNull()
	}
	if !s.Phone1.IsUnset() {
		t.Phone1 = s.Phone1.MustGetNull()
	}
	if !s.Fax1.IsUnset() {
		t.Fax1 = s.Fax1.MustGetNull()
	}
	if !s.Agency.IsUnset() {
		t.Agency = s.Agency.MustGetNull()
	}
	if !s.Code1.IsUnset() {
		t.Code1 = s.Code1.MustGetNull()
	}
	if !s.City1.IsUnset() {
		t.City1 = s.City1.MustGetNull()
	}
	if !s.ShapeLeng.IsUnset() {
		t.ShapeLeng = s.ShapeLeng.MustGetNull()
	}
	if !s.Address2.IsUnset() {
		t.Address2 = s.Address2.MustGetNull()
	}
	if !s.GeneralMG.IsUnset() {
		t.GeneralMG = s.GeneralMG.MustGetNull()
	}
	if !s.City2.IsUnset() {
		t.City2 = s.City2.MustGetNull()
	}
	if !s.PostalC1.IsUnset() {
		t.PostalC1 = s.PostalC1.MustGetNull()
	}
	if !s.Fax2.IsUnset() {
		t.Fax2 = s.Fax2.MustGetNull()
	}
	if !s.Phone2.IsUnset() {
		t.Phone2 = s.Phone2.MustGetNull()
	}
	if !s.ShapeLe1.IsUnset() {
		t.ShapeLe1 = s.ShapeLe1.MustGetNull()
	}
	if !s.ShapeArea.IsUnset() {
		t.ShapeArea = s.ShapeArea.MustGetNull()
	}
	if !s.Geom.IsUnset() {
		t.Geom = s.Geom.MustGetNull()
	}
}

func (s *ImportDistrictSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return ImportDistricts.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 22)
		if s.Gid.IsValue() {
			vals[0] = psql.Arg(s.Gid.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.ID.IsUnset() {
			vals[1] = psql.Arg(s.ID.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Website.IsUnset() {
			vals[2] = psql.Arg(s.Website.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Contact.IsUnset() {
			vals[3] = psql.Arg(s.Contact.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Address.IsUnset() {
			vals[4] = psql.Arg(s.Address.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Regionid.IsUnset() {
			vals[5] = psql.Arg(s.Regionid.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.PostalCod.IsUnset() {
			vals[6] = psql.Arg(s.PostalCod.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Phone1.IsUnset() {
			vals[7] = psql.Arg(s.Phone1.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Fax1.IsUnset() {
			vals[8] = psql.Arg(s.Fax1.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Agency.IsUnset() {
			vals[9] = psql.Arg(s.Agency.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Code1.IsUnset() {
			vals[10] = psql.Arg(s.Code1.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.City1.IsUnset() {
			vals[11] = psql.Arg(s.City1.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.ShapeLeng.IsUnset() {
			vals[12] = psql.Arg(s.ShapeLeng.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Address2.IsUnset() {
			vals[13] = psql.Arg(s.Address2.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.GeneralMG.IsUnset() {
			vals[14] = psql.Arg(s.GeneralMG.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.City2.IsUnset() {
			vals[15] = psql.Arg(s.City2.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if !s.PostalC1.IsUnset() {
			vals[16] = psql.Arg(s.PostalC1.MustGetNull())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.Fax2.IsUnset() {
			vals[17] = psql.Arg(s.Fax2.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.Phone2.IsUnset() {
			vals[18] = psql.Arg(s.Phone2.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.ShapeLe1.IsUnset() {
			vals[19] = psql.Arg(s.ShapeLe1.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.ShapeArea.IsUnset() {
			vals[20] = psql.Arg(s.ShapeArea.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.Geom.IsUnset() {
			vals[21] = psql.Arg(s.Geom.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s ImportDistrictSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s ImportDistrictSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 22)

	if s.Gid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "gid")...),
			psql.Arg(s.Gid),
		}})
	}

	if !s.ID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if !s.Website.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "website")...),
			psql.Arg(s.Website),
		}})
	}

	if !s.Contact.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "contact")...),
			psql.Arg(s.Contact),
		}})
	}

	if !s.Address.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address")...),
			psql.Arg(s.Address),
		}})
	}

	if !s.Regionid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "regionid")...),
			psql.Arg(s.Regionid),
		}})
	}

	if !s.PostalCod.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "postal_cod")...),
			psql.Arg(s.PostalCod),
		}})
	}

	if !s.Phone1.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "phone1")...),
			psql.Arg(s.Phone1),
		}})
	}

	if !s.Fax1.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "fax1")...),
			psql.Arg(s.Fax1),
		}})
	}

	if !s.Agency.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "agency")...),
			psql.Arg(s.Agency),
		}})
	}

	if !s.Code1.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "code1")...),
			psql.Arg(s.Code1),
		}})
	}

	if !s.City1.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "city1")...),
			psql.Arg(s.City1),
		}})
	}

	if !s.ShapeLeng.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "shape_leng")...),
			psql.Arg(s.ShapeLeng),
		}})
	}

	if !s.Address2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "address2")...),
			psql.Arg(s.Address2),
		}})
	}

	if !s.GeneralMG.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "general_mg")...),
			psql.Arg(s.GeneralMG),
		}})
	}

	if !s.City2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "city2")...),
			psql.Arg(s.City2),
		}})
	}

	if !s.PostalC1.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "postal_c_1")...),
			psql.Arg(s.PostalC1),
		}})
	}

	if !s.Fax2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "fax2")...),
			psql.Arg(s.Fax2),
		}})
	}

	if !s.Phone2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "phone2")...),
			psql.Arg(s.Phone2),
		}})
	}

	if !s.ShapeLe1.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "shape_le_1")...),
			psql.Arg(s.ShapeLe1),
		}})
	}

	if !s.ShapeArea.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "shape_area")...),
			psql.Arg(s.ShapeArea),
		}})
	}

	if !s.Geom.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geom")...),
			psql.Arg(s.Geom),
		}})
	}

	return exprs
}

// FindImportDistrict retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindImportDistrict(ctx context.Context, exec bob.Executor, GidPK int32, cols ...string) (*ImportDistrict, error) {
	if len(cols) == 0 {
		return ImportDistricts.Query(
			sm.Where(ImportDistricts.Columns.Gid.EQ(psql.Arg(GidPK))),
		).One(ctx, exec)
	}

	return ImportDistricts.Query(
		sm.Where(ImportDistricts.Columns.Gid.EQ(psql.Arg(GidPK))),
		sm.Columns(ImportDistricts.Columns.Only(cols...)),
	).One(ctx, exec)
}

// ImportDistrictExists checks the presence of a single record by primary key
func ImportDistrictExists(ctx context.Context, exec bob.Executor, GidPK int32) (bool, error) {
	return ImportDistricts.Query(
		sm.Where(ImportDistricts.Columns.Gid.EQ(psql.Arg(GidPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after ImportDistrict is retrieved from the database
func (o *ImportDistrict) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = ImportDistricts.AfterSelectHooks.RunHooks(ctx, exec, ImportDistrictSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = ImportDistricts.AfterInsertHooks.RunHooks(ctx, exec, ImportDistrictSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = ImportDistricts.AfterUpdateHooks.RunHooks(ctx, exec, ImportDistrictSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = ImportDistricts.AfterDeleteHooks.RunHooks(ctx, exec, ImportDistrictSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the ImportDistrict
func (o *ImportDistrict) primaryKeyVals() bob.Expression {
	return psql.Arg(o.Gid)
}

func (o *ImportDistrict) pkEQ() dialect.Expression {
	return psql.Quote("import.district", "gid").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the ImportDistrict
func (o *ImportDistrict) Update(ctx context.Context, exec bob.Executor, s *ImportDistrictSetter) error {
	v, err := ImportDistricts.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single ImportDistrict record with an executor
func (o *ImportDistrict) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := ImportDistricts.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the ImportDistrict using the executor
func (o *ImportDistrict) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := ImportDistricts.Query(
		sm.Where(ImportDistricts.Columns.Gid.EQ(psql.Arg(o.Gid))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after ImportDistrictSlice is retrieved from the database
func (o ImportDistrictSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = ImportDistricts.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = ImportDistricts.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = ImportDistricts.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = ImportDistricts.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o ImportDistrictSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("import.district", "gid").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o ImportDistrictSlice) copyMatchingRows(from ...*ImportDistrict) {
	for i, old := range o {
		for _, new := range from {
			if new.Gid != old.Gid {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o ImportDistrictSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return ImportDistricts.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *ImportDistrict:
				o.copyMatchingRows(retrieved)
			case []*ImportDistrict:
				o.copyMatchingRows(retrieved...)
			case ImportDistrictSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a ImportDistrict or a slice of ImportDistrict
				// then run the AfterUpdateHooks on the slice
				_, err = ImportDistricts.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o ImportDistrictSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return ImportDistricts.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *ImportDistrict:
				o.copyMatchingRows(retrieved)
			case []*ImportDistrict:
				o.copyMatchingRows(retrieved...)
			case ImportDistrictSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a ImportDistrict or a slice of ImportDistrict
				// then run the AfterDeleteHooks on the slice
				_, err = ImportDistricts.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o ImportDistrictSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals ImportDistrictSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := ImportDistricts.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o ImportDistrictSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := ImportDistricts.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o ImportDistrictSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := ImportDistricts.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// ImportDistrictGidOrganization starts a query for related objects on organization
func (o *ImportDistrict) ImportDistrictGidOrganization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	return Organizations.Query(append(mods,
		sm.Where(Organizations.Columns.ImportDistrictGid.EQ(psql.Arg(o.Gid))),
	)...)
}

func (os ImportDistrictSlice) ImportDistrictGidOrganization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	pkGid := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkGid = append(pkGid, o.Gid)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkGid), "integer[]")),
	))

	return Organizations.Query(append(mods,
		sm.Where(psql.Group(Organizations.Columns.ImportDistrictGid).OP("IN", PKArgExpr)),
	)...)
}

func insertImportDistrictImportDistrictGidOrganization0(ctx context.Context, exec bob.Executor, organization1 *OrganizationSetter, importDistrict0 *ImportDistrict) (*Organization, error) {
	organization1.ImportDistrictGid = omitnull.From(importDistrict0.Gid)

	ret, err := Organizations.Insert(organization1).One(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertImportDistrictImportDistrictGidOrganization0: %w", err)
	}

	return ret, nil
}

func attachImportDistrictImportDistrictGidOrganization0(ctx context.Context, exec bob.Executor, count int, organization1 *Organization, importDistrict0 *ImportDistrict) (*Organization, error) {
	setter := &OrganizationSetter{
		ImportDistrictGid: omitnull.From(importDistrict0.Gid),
	}

	err := organization1.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachImportDistrictImportDistrictGidOrganization0: %w", err)
	}

	return organization1, nil
}

func (importDistrict0 *ImportDistrict) InsertImportDistrictGidOrganization(ctx context.Context, exec bob.Executor, related *OrganizationSetter) error {
	var err error

	organization1, err := insertImportDistrictImportDistrictGidOrganization0(ctx, exec, related, importDistrict0)
	if err != nil {
		return err
	}

	importDistrict0.R.ImportDistrictGidOrganization = organization1

	organization1.R.ImportDistrictGidDistrict = importDistrict0

	return nil
}

func (importDistrict0 *ImportDistrict) AttachImportDistrictGidOrganization(ctx context.Context, exec bob.Executor, organization1 *Organization) error {
	var err error

	_, err = attachImportDistrictImportDistrictGidOrganization0(ctx, exec, 1, organization1, importDistrict0)
	if err != nil {
		return err
	}

	importDistrict0.R.ImportDistrictGidOrganization = organization1

	organization1.R.ImportDistrictGidDistrict = importDistrict0

	return nil
}

type importDistrictWhere[Q psql.Filterable] struct {
	Gid          psql.WhereMod[Q, int32]
	ID           psql.WhereNullMod[Q, decimal.Decimal]
	Website      psql.WhereNullMod[Q, string]
	Contact      psql.WhereNullMod[Q, string]
	Address      psql.WhereNullMod[Q, string]
	Regionid     psql.WhereNullMod[Q, decimal.Decimal]
	PostalCod    psql.WhereNullMod[Q, decimal.Decimal]
	Phone1       psql.WhereNullMod[Q, string]
	Fax1         psql.WhereNullMod[Q, string]
	Agency       psql.WhereNullMod[Q, string]
	Code1        psql.WhereNullMod[Q, string]
	City1        psql.WhereNullMod[Q, string]
	ShapeLeng    psql.WhereNullMod[Q, decimal.Decimal]
	Address2     psql.WhereNullMod[Q, string]
	GeneralMG    psql.WhereNullMod[Q, string]
	City2        psql.WhereNullMod[Q, string]
	PostalC1     psql.WhereNullMod[Q, decimal.Decimal]
	Fax2         psql.WhereNullMod[Q, string]
	Phone2       psql.WhereNullMod[Q, string]
	ShapeLe1     psql.WhereNullMod[Q, decimal.Decimal]
	ShapeArea    psql.WhereNullMod[Q, decimal.Decimal]
	Geom         psql.WhereNullMod[Q, string]
	Geom4326     psql.WhereNullMod[Q, string]
	Centroid4326 psql.WhereNullMod[Q, string]
	Extent4326   psql.WhereNullMod[Q, string]
}

func (importDistrictWhere[Q]) AliasedAs(alias string) importDistrictWhere[Q] {
	return buildImportDistrictWhere[Q](buildImportDistrictColumns(alias))
}

func buildImportDistrictWhere[Q psql.Filterable](cols importDistrictColumns) importDistrictWhere[Q] {
	return importDistrictWhere[Q]{
		Gid:          psql.Where[Q, int32](cols.Gid),
		ID:           psql.WhereNull[Q, decimal.Decimal](cols.ID),
		Website:      psql.WhereNull[Q, string](cols.Website),
		Contact:      psql.WhereNull[Q, string](cols.Contact),
		Address:      psql.WhereNull[Q, string](cols.Address),
		Regionid:     psql.WhereNull[Q, decimal.Decimal](cols.Regionid),
		PostalCod:    psql.WhereNull[Q, decimal.Decimal](cols.PostalCod),
		Phone1:       psql.WhereNull[Q, string](cols.Phone1),
		Fax1:         psql.WhereNull[Q, string](cols.Fax1),
		Agency:       psql.WhereNull[Q, string](cols.Agency),
		Code1:        psql.WhereNull[Q, string](cols.Code1),
		City1:        psql.WhereNull[Q, string](cols.City1),
		ShapeLeng:    psql.WhereNull[Q, decimal.Decimal](cols.ShapeLeng),
		Address2:     psql.WhereNull[Q, string](cols.Address2),
		GeneralMG:    psql.WhereNull[Q, string](cols.GeneralMG),
		City2:        psql.WhereNull[Q, string](cols.City2),
		PostalC1:     psql.WhereNull[Q, decimal.Decimal](cols.PostalC1),
		Fax2:         psql.WhereNull[Q, string](cols.Fax2),
		Phone2:       psql.WhereNull[Q, string](cols.Phone2),
		ShapeLe1:     psql.WhereNull[Q, decimal.Decimal](cols.ShapeLe1),
		ShapeArea:    psql.WhereNull[Q, decimal.Decimal](cols.ShapeArea),
		Geom:         psql.WhereNull[Q, string](cols.Geom),
		Geom4326:     psql.WhereNull[Q, string](cols.Geom4326),
		Centroid4326: psql.WhereNull[Q, string](cols.Centroid4326),
		Extent4326:   psql.WhereNull[Q, string](cols.Extent4326),
	}
}

func (o *ImportDistrict) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "ImportDistrictGidOrganization":
		rel, ok := retrieved.(*Organization)
		if !ok {
			return fmt.Errorf("importDistrict cannot load %T as %q", retrieved, name)
		}

		o.R.ImportDistrictGidOrganization = rel

		if rel != nil {
			rel.R.ImportDistrictGidDistrict = o
		}
		return nil
	default:
		return fmt.Errorf("importDistrict has no relationship %q", name)
	}
}

type importDistrictPreloader struct {
	ImportDistrictGidOrganization func(...psql.PreloadOption) psql.Preloader
}

func buildImportDistrictPreloader() importDistrictPreloader {
	return importDistrictPreloader{
		ImportDistrictGidOrganization: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Organization, OrganizationSlice](psql.PreloadRel{
				Name: "ImportDistrictGidOrganization",
				Sides: []psql.PreloadSide{
					{
						From:        ImportDistricts,
						To:          Organizations,
						FromColumns: []string{"gid"},
						ToColumns:   []string{"import_district_gid"},
					},
				},
			}, Organizations.Columns.Names(), opts...)
		},
	}
}

type importDistrictThenLoader[Q orm.Loadable] struct {
	ImportDistrictGidOrganization func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildImportDistrictThenLoader[Q orm.Loadable]() importDistrictThenLoader[Q] {
	type ImportDistrictGidOrganizationLoadInterface interface {
		LoadImportDistrictGidOrganization(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return importDistrictThenLoader[Q]{
		ImportDistrictGidOrganization: thenLoadBuilder[Q](
			"ImportDistrictGidOrganization",
			func(ctx context.Context, exec bob.Executor, retrieved ImportDistrictGidOrganizationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadImportDistrictGidOrganization(ctx, exec, mods...)
			},
		),
	}
}

// LoadImportDistrictGidOrganization loads the importDistrict's ImportDistrictGidOrganization into the .R struct
func (o *ImportDistrict) LoadImportDistrictGidOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ImportDistrictGidOrganization = nil

	related, err := o.ImportDistrictGidOrganization(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.ImportDistrictGidDistrict = o

	o.R.ImportDistrictGidOrganization = related
	return nil
}

// LoadImportDistrictGidOrganization loads the importDistrict's ImportDistrictGidOrganization into the .R struct
func (os ImportDistrictSlice) LoadImportDistrictGidOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	organizations, err := os.ImportDistrictGidOrganization(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range organizations {

			if !rel.ImportDistrictGid.IsValue() {
				continue
			}
			if !(rel.ImportDistrictGid.IsValue() && o.Gid == rel.ImportDistrictGid.MustGet()) {
				continue
			}

			rel.R.ImportDistrictGidDistrict = o

			o.R.ImportDistrictGidOrganization = rel
			break
		}
	}

	return nil
}

type importDistrictJoins[Q dialect.Joinable] struct {
	typ                           string
	ImportDistrictGidOrganization modAs[Q, organizationColumns]
}

func (j importDistrictJoins[Q]) aliasedAs(alias string) importDistrictJoins[Q] {
	return buildImportDistrictJoins[Q](buildImportDistrictColumns(alias), j.typ)
}

func buildImportDistrictJoins[Q dialect.Joinable](cols importDistrictColumns, typ string) importDistrictJoins[Q] {
	return importDistrictJoins[Q]{
		typ: typ,
		ImportDistrictGidOrganization: modAs[Q, organizationColumns]{
			c: Organizations.Columns,
			f: func(to organizationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Organizations.Name().As(to.Alias())).On(
						to.ImportDistrictGid.EQ(cols.Gid),
					))
				}

				return mods
			},
		},
	}
}
