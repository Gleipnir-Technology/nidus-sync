// Code generated by BobGen psql v0.42.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"io"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/scan"
)

var (
	PreloadCount        = getPreloadCount()
	ThenLoadCount       = getThenLoadCount[*dialect.SelectQuery]()
	InsertThenLoadCount = getThenLoadCount[*dialect.InsertQuery]()
)

type preloadCounts struct {
	ArcgisUser        arcgisuserCountPreloader
	NoteAudio         noteAudioCountPreloader
	NoteImage         noteImageCountPreloader
	Organization      organizationCountPreloader
	PublicreportPool  publicreportPoolCountPreloader
	PublicreportQuick publicreportQuickCountPreloader
	User              userCountPreloader
}

func getPreloadCount() preloadCounts {
	return preloadCounts{
		ArcgisUser:        buildArcgisUserCountPreloader(),
		NoteAudio:         buildNoteAudioCountPreloader(),
		NoteImage:         buildNoteImageCountPreloader(),
		Organization:      buildOrganizationCountPreloader(),
		PublicreportPool:  buildPublicreportPoolCountPreloader(),
		PublicreportQuick: buildPublicreportQuickCountPreloader(),
		User:              buildUserCountPreloader(),
	}
}

type thenLoadCounts[Q orm.Loadable] struct {
	ArcgisUser        arcgisuserCountThenLoader[Q]
	NoteAudio         noteAudioCountThenLoader[Q]
	NoteImage         noteImageCountThenLoader[Q]
	Organization      organizationCountThenLoader[Q]
	PublicreportPool  publicreportPoolCountThenLoader[Q]
	PublicreportQuick publicreportQuickCountThenLoader[Q]
	User              userCountThenLoader[Q]
}

func getThenLoadCount[Q orm.Loadable]() thenLoadCounts[Q] {
	return thenLoadCounts[Q]{
		ArcgisUser:        buildArcgisUserCountThenLoader[Q](),
		NoteAudio:         buildNoteAudioCountThenLoader[Q](),
		NoteImage:         buildNoteImageCountThenLoader[Q](),
		Organization:      buildOrganizationCountThenLoader[Q](),
		PublicreportPool:  buildPublicreportPoolCountThenLoader[Q](),
		PublicreportQuick: buildPublicreportQuickCountThenLoader[Q](),
		User:              buildUserCountThenLoader[Q](),
	}
}

func countThenLoadBuilder[Q orm.Loadable, T any](name string, f func(context.Context, bob.Executor, T, ...bob.Mod[*dialect.SelectQuery]) error) func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
	return func(queryMods ...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
		return func(ctx context.Context, exec bob.Executor, retrieved any) error {
			loader, isLoader := retrieved.(T)
			if !isLoader {
				return nil // silently skip if not the right type
			}

			return f(ctx, exec, loader, queryMods...)
		}
	}
}

// countPreloadable is an interface for models that can have counts preloaded
type countPreloadable interface {
	PreloadCount(name string, count int64) error
}

// countPreloadMod is used to add a count subquery to the SELECT
type countPreloadMod[T countPreloadable] struct {
	name      string
	countExpr func(from string) bob.Expression
}

// Apply implements bob.Mod
func (c countPreloadMod[T]) Apply(q *dialect.SelectQuery) {
	c.applyCount(q, "")
}

// applyCount adds the count subquery to the query
func (c countPreloadMod[T]) applyCount(q *dialect.SelectQuery, parent string) {
	countCol := c.countExpr(parent)
	q.AppendPreloadSelect(aliasedExpr{expr: countCol, alias: "__count_" + c.name})
}

// aliasedExpr wraps an expression with an alias
type aliasedExpr struct {
	expr  bob.Expression
	alias string
}

func (a aliasedExpr) WriteSQL(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
	args, err := a.expr.WriteSQL(ctx, w, d, start)
	if err != nil {
		return nil, err
	}
	w.WriteString(" AS ")
	d.WriteQuoted(w, a.alias)
	return args, nil
}

// countPreloader returns a Preloader that adds a count subquery
func countPreloader[T countPreloadable](name string, countExpr func(from string) bob.Expression) psql.Preloader {
	return func(parent string) (bob.Mod[*dialect.SelectQuery], scan.MapperMod, []bob.Loader) {
		m := countPreloadMod[T]{
			name:      name,
			countExpr: countExpr,
		}

		queryMod := bob.ModFunc[*dialect.SelectQuery](func(q *dialect.SelectQuery) {
			m.applyCount(q, parent)
		})

		mapperMod := func(ctx context.Context, cols []string) (scan.BeforeFunc, scan.AfterMod) {
			// Find the count column
			countColName := "__count_" + name
			colIndex := -1
			for i, col := range cols {
				if col == countColName {
					colIndex = i
					break
				}
			}

			return func(r *scan.Row) (any, error) {
					if colIndex >= 0 {
						var count *int64
						r.ScheduleScanByIndex(colIndex, &count)
						return &count, nil
					}
					return nil, nil
				}, func(link, retrieved any) error {
					if link == nil {
						return nil
					}
					countPtr, ok := link.(**int64)
					if !ok || countPtr == nil || *countPtr == nil {
						return nil
					}

					loader, isLoader := retrieved.(countPreloadable)
					if !isLoader {
						return nil
					}

					return loader.PreloadCount(name, **countPtr)
				}
		}

		return queryMod, mapperMod, nil
	}
}
