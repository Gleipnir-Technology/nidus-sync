// Code generated by BobGen psql v0.42.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package sql

import (
	"context"
	_ "embed"
	"io"
	"iter"

	"github.com/Gleipnir-Technology/bob"
	"github.com/Gleipnir-Technology/bob/dialect/psql"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dialect"
	"github.com/Gleipnir-Technology/bob/orm"
	"github.com/google/uuid"
	"github.com/stephenafamo/scan"
)

//go:embed traplocation_by_source_id.bob.sql
var formattedQueries_traplocation_by_source_id string

var trapLocationBySourceIDSQL = formattedQueries_traplocation_by_source_id[160:453]

type TrapLocationBySourceIDQuery = orm.ModQuery[*dialect.SelectQuery, trapLocationBySourceID, TrapLocationBySourceIDRow, []TrapLocationBySourceIDRow, trapLocationBySourceIDTransformer]

func TrapLocationBySourceID(OrganizationID int32, Globalid uuid.UUID) *TrapLocationBySourceIDQuery {
	var expressionTypArgs trapLocationBySourceID

	expressionTypArgs.OrganizationID = psql.Arg(OrganizationID)
	expressionTypArgs.Globalid = psql.Arg(Globalid)

	return &TrapLocationBySourceIDQuery{
		Query: orm.Query[trapLocationBySourceID, TrapLocationBySourceIDRow, []TrapLocationBySourceIDRow, trapLocationBySourceIDTransformer]{
			ExecQuery: orm.ExecQuery[trapLocationBySourceID]{
				BaseQuery: bob.BaseQuery[trapLocationBySourceID]{
					Expression: expressionTypArgs,
					Dialect:    dialect.Dialect,
					QueryType:  bob.QueryTypeSelect,
				},
			},
			Scanner: func(context.Context, []string) (func(*scan.Row) (any, error), func(any) (TrapLocationBySourceIDRow, error)) {
				return func(row *scan.Row) (any, error) {
						var t TrapLocationBySourceIDRow
						row.ScheduleScanByIndex(0, &t.TrapLocationGlobalid)
						row.ScheduleScanByIndex(1, &t.Distance)
						return &t, nil
					}, func(v any) (TrapLocationBySourceIDRow, error) {
						return *(v.(*TrapLocationBySourceIDRow)), nil
					}
			},
		},
		Mod: bob.ModFunc[*dialect.SelectQuery](func(q *dialect.SelectQuery) {
			q.AppendSelect(expressionTypArgs.subExpr(9, 102))
			q.SetTable(expressionTypArgs.subExpr(110, 178))
			q.AppendWhere(expressionTypArgs.subExpr(187, 232))
			q.CombinedOrder.AppendOrder(expressionTypArgs.subExpr(244, 285))
			q.CombinedLimit.SetLimit(expressionTypArgs.subExpr(292, 293))
		}),
	}
}

type TrapLocationBySourceIDRow = struct {
	TrapLocationGlobalid uuid.UUID `db:"trap_location_globalid"`
	Distance             string    `db:"distance"`
}

type trapLocationBySourceIDTransformer = bob.SliceTransformer[TrapLocationBySourceIDRow, []TrapLocationBySourceIDRow]

type trapLocationBySourceID struct {
	OrganizationID bob.Expression
	Globalid       bob.Expression
}

func (o trapLocationBySourceID) args() iter.Seq[orm.ArgWithPosition] {
	return func(yield func(arg orm.ArgWithPosition) bool) {
		if !yield(orm.ArgWithPosition{
			Name:       "organizationID",
			Start:      208,
			Stop:       210,
			Expression: o.OrganizationID,
		}) {
			return
		}

		if !yield(orm.ArgWithPosition{
			Name:       "globalid",
			Start:      230,
			Stop:       232,
			Expression: o.Globalid,
		}) {
			return
		}
	}
}

func (o trapLocationBySourceID) raw(from, to int) string {
	return trapLocationBySourceIDSQL[from:to]
}

func (o trapLocationBySourceID) subExpr(from, to int) bob.Expression {
	return orm.ArgsToExpression(trapLocationBySourceIDSQL, from, to, o.args())
}

func (o trapLocationBySourceID) WriteSQL(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
	return o.subExpr(0, len(trapLocationBySourceIDSQL)).WriteSQL(ctx, w, d, start)
}
