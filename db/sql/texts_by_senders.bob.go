// Code generated by BobGen psql v0.42.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package sql

import (
	"context"
	_ "embed"
	"io"
	"iter"
	"time"

	"github.com/Gleipnir-Technology/bob"
	"github.com/Gleipnir-Technology/bob/dialect/psql"
	"github.com/Gleipnir-Technology/bob/dialect/psql/dialect"
	"github.com/Gleipnir-Technology/bob/orm"
	enums "github.com/Gleipnir-Technology/nidus-sync/db/enums"
	"github.com/stephenafamo/scan"
)

//go:embed texts_by_senders.bob.sql
var formattedQueries_texts_by_senders string

var textsBySendersSQL = formattedQueries_texts_by_senders[152:416]

type TextsBySendersQuery = orm.ModQuery[*dialect.SelectQuery, textsBySenders, TextsBySendersRow, []TextsBySendersRow, textsBySendersTransformer]

func TextsBySenders(Destination string, Source string) *TextsBySendersQuery {
	var expressionTypArgs textsBySenders

	expressionTypArgs.Destination = psql.Arg(Destination)
	expressionTypArgs.Source = psql.Arg(Source)

	return &TextsBySendersQuery{
		Query: orm.Query[textsBySenders, TextsBySendersRow, []TextsBySendersRow, textsBySendersTransformer]{
			ExecQuery: orm.ExecQuery[textsBySenders]{
				BaseQuery: bob.BaseQuery[textsBySenders]{
					Expression: expressionTypArgs,
					Dialect:    dialect.Dialect,
					QueryType:  bob.QueryTypeSelect,
				},
			},
			Scanner: func(context.Context, []string) (func(*scan.Row) (any, error), func(any) (TextsBySendersRow, error)) {
				return func(row *scan.Row) (any, error) {
						var t TextsBySendersRow
						row.ScheduleScanByIndex(0, &t.ID)
						row.ScheduleScanByIndex(1, &t.Content)
						row.ScheduleScanByIndex(2, &t.Created)
						row.ScheduleScanByIndex(3, &t.Source)
						row.ScheduleScanByIndex(4, &t.Destination)
						row.ScheduleScanByIndex(5, &t.IsVisibleToLLM)
						row.ScheduleScanByIndex(6, &t.IsWelcome)
						row.ScheduleScanByIndex(7, &t.Origin)
						return &t, nil
					}, func(v any) (TextsBySendersRow, error) {
						return *(v.(*TextsBySendersRow)), nil
					}
			},
		},
		Mod: bob.ModFunc[*dialect.SelectQuery](func(q *dialect.SelectQuery) {
			q.AppendSelect(expressionTypArgs.subExpr(12, 120))
			q.SetTable(expressionTypArgs.subExpr(131, 145))
			q.AppendWhere(expressionTypArgs.subExpr(158, 237))
			q.CombinedOrder.AppendOrder(expressionTypArgs.subExpr(253, 264))
		}),
	}
}

type TextsBySendersRow = struct {
	ID             int32                 `db:"id"`
	Content        string                `db:"content"`
	Created        time.Time             `db:"created"`
	Source         string                `db:"source"`
	Destination    string                `db:"destination"`
	IsVisibleToLLM bool                  `db:"is_visible_to_llm"`
	IsWelcome      bool                  `db:"is_welcome"`
	Origin         enums.CommsTextorigin `db:"origin"`
}

type textsBySendersTransformer = bob.SliceTransformer[TextsBySendersRow, []TextsBySendersRow]

type textsBySenders struct {
	Destination bob.Expression
	Source      bob.Expression
}

func (o textsBySenders) args() iter.Seq[orm.ArgWithPosition] {
	return func(yield func(arg orm.ArgWithPosition) bool) {
		if !yield(orm.ArgWithPosition{
			Name:       "destination",
			Start:      167,
			Stop:       169,
			Expression: o.Destination,
		}) {
			return
		}

		if !yield(orm.ArgWithPosition{
			Name:       "source",
			Start:      188,
			Stop:       190,
			Expression: o.Source,
		}) {
			return
		}

		if !yield(orm.ArgWithPosition{
			Name:       "source",
			Start:      214,
			Stop:       216,
			Expression: o.Source,
		}) {
			return
		}

		if !yield(orm.ArgWithPosition{
			Name:       "destination",
			Start:      235,
			Stop:       237,
			Expression: o.Destination,
		}) {
			return
		}
	}
}

func (o textsBySenders) raw(from, to int) string {
	return textsBySendersSQL[from:to]
}

func (o textsBySenders) subExpr(from, to int) bob.Expression {
	return orm.ArgsToExpression(textsBySendersSQL, from, to, o.args())
}

func (o textsBySenders) WriteSQL(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
	return o.subExpr(0, len(textsBySendersSQL)).WriteSQL(ctx, w, d, start)
}
