// Code generated by BobGen psql v0.42.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package enums

import (
	"database/sql/driver"
	"fmt"
)

// Enum values for Arcgislicensetype
const (
	ArcgislicensetypeAdvancedut             Arcgislicensetype = "advancedUT"
	ArcgislicensetypeBasicut                Arcgislicensetype = "basicUT"
	ArcgislicensetypeCreatorut              Arcgislicensetype = "creatorUT"
	ArcgislicensetypeEditorut               Arcgislicensetype = "editorUT"
	ArcgislicensetypeFieldworkerut          Arcgislicensetype = "fieldWorkerUT"
	ArcgislicensetypeGisprofessionaladvut   Arcgislicensetype = "GISProfessionalAdvUT"
	ArcgislicensetypeGisprofessionalbasicut Arcgislicensetype = "GISProfessionalBasicUT"
	ArcgislicensetypeGisprofessionalstdut   Arcgislicensetype = "GISProfessionalStdUT"
	ArcgislicensetypeIndoorsuserut          Arcgislicensetype = "IndoorsUserUT"
	ArcgislicensetypeInsightsanalystut      Arcgislicensetype = "insightsAnalystUT"
	ArcgislicensetypeLiteut                 Arcgislicensetype = "liteUT"
	ArcgislicensetypeStandardut             Arcgislicensetype = "standardUT"
	ArcgislicensetypeStorytellerut          Arcgislicensetype = "storytellerUT"
	ArcgislicensetypeViewerut               Arcgislicensetype = "viewerUT"
)

func AllArcgislicensetype() []Arcgislicensetype {
	return []Arcgislicensetype{
		ArcgislicensetypeAdvancedut,
		ArcgislicensetypeBasicut,
		ArcgislicensetypeCreatorut,
		ArcgislicensetypeEditorut,
		ArcgislicensetypeFieldworkerut,
		ArcgislicensetypeGisprofessionaladvut,
		ArcgislicensetypeGisprofessionalbasicut,
		ArcgislicensetypeGisprofessionalstdut,
		ArcgislicensetypeIndoorsuserut,
		ArcgislicensetypeInsightsanalystut,
		ArcgislicensetypeLiteut,
		ArcgislicensetypeStandardut,
		ArcgislicensetypeStorytellerut,
		ArcgislicensetypeViewerut,
	}
}

type Arcgislicensetype string

func (e Arcgislicensetype) String() string {
	return string(e)
}

func (e Arcgislicensetype) Valid() bool {
	switch e {
	case ArcgislicensetypeAdvancedut,
		ArcgislicensetypeBasicut,
		ArcgislicensetypeCreatorut,
		ArcgislicensetypeEditorut,
		ArcgislicensetypeFieldworkerut,
		ArcgislicensetypeGisprofessionaladvut,
		ArcgislicensetypeGisprofessionalbasicut,
		ArcgislicensetypeGisprofessionalstdut,
		ArcgislicensetypeIndoorsuserut,
		ArcgislicensetypeInsightsanalystut,
		ArcgislicensetypeLiteut,
		ArcgislicensetypeStandardut,
		ArcgislicensetypeStorytellerut,
		ArcgislicensetypeViewerut:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e Arcgislicensetype) All() []Arcgislicensetype {
	return AllArcgislicensetype()
}

func (e Arcgislicensetype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *Arcgislicensetype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e Arcgislicensetype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *Arcgislicensetype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e Arcgislicensetype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *Arcgislicensetype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = Arcgislicensetype(x)
	case []byte:
		*e = Arcgislicensetype(x)
	case nil:
		return fmt.Errorf("cannot nil into Arcgislicensetype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid Arcgislicensetype value: %s", *e)
	}

	return nil
}

// Enum values for Audiodatatype
const (
	AudiodatatypeRaw           Audiodatatype = "raw"
	AudiodatatypeRawNormalized Audiodatatype = "raw_normalized"
	AudiodatatypeOgg           Audiodatatype = "ogg"
)

func AllAudiodatatype() []Audiodatatype {
	return []Audiodatatype{
		AudiodatatypeRaw,
		AudiodatatypeRawNormalized,
		AudiodatatypeOgg,
	}
}

type Audiodatatype string

func (e Audiodatatype) String() string {
	return string(e)
}

func (e Audiodatatype) Valid() bool {
	switch e {
	case AudiodatatypeRaw,
		AudiodatatypeRawNormalized,
		AudiodatatypeOgg:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e Audiodatatype) All() []Audiodatatype {
	return AllAudiodatatype()
}

func (e Audiodatatype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *Audiodatatype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e Audiodatatype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *Audiodatatype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e Audiodatatype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *Audiodatatype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = Audiodatatype(x)
	case []byte:
		*e = Audiodatatype(x)
	case nil:
		return fmt.Errorf("cannot nil into Audiodatatype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid Audiodatatype value: %s", *e)
	}

	return nil
}

// Enum values for CommsEmailmessagetype
const (
	CommsEmailmessagetypeReportSubscriptionConfirmation CommsEmailmessagetype = "report-subscription-confirmation"
	CommsEmailmessagetypeReportStatusScheduled          CommsEmailmessagetype = "report-status-scheduled"
	CommsEmailmessagetypeReportStatusComplete           CommsEmailmessagetype = "report-status-complete"
)

func AllCommsEmailmessagetype() []CommsEmailmessagetype {
	return []CommsEmailmessagetype{
		CommsEmailmessagetypeReportSubscriptionConfirmation,
		CommsEmailmessagetypeReportStatusScheduled,
		CommsEmailmessagetypeReportStatusComplete,
	}
}

type CommsEmailmessagetype string

func (e CommsEmailmessagetype) String() string {
	return string(e)
}

func (e CommsEmailmessagetype) Valid() bool {
	switch e {
	case CommsEmailmessagetypeReportSubscriptionConfirmation,
		CommsEmailmessagetypeReportStatusScheduled,
		CommsEmailmessagetypeReportStatusComplete:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e CommsEmailmessagetype) All() []CommsEmailmessagetype {
	return AllCommsEmailmessagetype()
}

func (e CommsEmailmessagetype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *CommsEmailmessagetype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e CommsEmailmessagetype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *CommsEmailmessagetype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e CommsEmailmessagetype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *CommsEmailmessagetype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = CommsEmailmessagetype(x)
	case []byte:
		*e = CommsEmailmessagetype(x)
	case nil:
		return fmt.Errorf("cannot nil into CommsEmailmessagetype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid CommsEmailmessagetype value: %s", *e)
	}

	return nil
}

// Enum values for CommsSmsmessagetype
const (
	CommsSmsmessagetypeReportSubscriptionConfirmation CommsSmsmessagetype = "report-subscription-confirmation"
	CommsSmsmessagetypeReportStatusScheduled          CommsSmsmessagetype = "report-status-scheduled"
	CommsSmsmessagetypeReportStatusComplete           CommsSmsmessagetype = "report-status-complete"
)

func AllCommsSmsmessagetype() []CommsSmsmessagetype {
	return []CommsSmsmessagetype{
		CommsSmsmessagetypeReportSubscriptionConfirmation,
		CommsSmsmessagetypeReportStatusScheduled,
		CommsSmsmessagetypeReportStatusComplete,
	}
}

type CommsSmsmessagetype string

func (e CommsSmsmessagetype) String() string {
	return string(e)
}

func (e CommsSmsmessagetype) Valid() bool {
	switch e {
	case CommsSmsmessagetypeReportSubscriptionConfirmation,
		CommsSmsmessagetypeReportStatusScheduled,
		CommsSmsmessagetypeReportStatusComplete:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e CommsSmsmessagetype) All() []CommsSmsmessagetype {
	return AllCommsSmsmessagetype()
}

func (e CommsSmsmessagetype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *CommsSmsmessagetype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e CommsSmsmessagetype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *CommsSmsmessagetype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e CommsSmsmessagetype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *CommsSmsmessagetype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = CommsSmsmessagetype(x)
	case []byte:
		*e = CommsSmsmessagetype(x)
	case nil:
		return fmt.Errorf("cannot nil into CommsSmsmessagetype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid CommsSmsmessagetype value: %s", *e)
	}

	return nil
}

// Enum values for H3aggregationtype
const (
	H3aggregationtypeMosquitosource H3aggregationtype = "MosquitoSource"
	H3aggregationtypeServicerequest H3aggregationtype = "ServiceRequest"
	H3aggregationtypeTrap           H3aggregationtype = "Trap"
)

func AllH3aggregationtype() []H3aggregationtype {
	return []H3aggregationtype{
		H3aggregationtypeMosquitosource,
		H3aggregationtypeServicerequest,
		H3aggregationtypeTrap,
	}
}

type H3aggregationtype string

func (e H3aggregationtype) String() string {
	return string(e)
}

func (e H3aggregationtype) Valid() bool {
	switch e {
	case H3aggregationtypeMosquitosource,
		H3aggregationtypeServicerequest,
		H3aggregationtypeTrap:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e H3aggregationtype) All() []H3aggregationtype {
	return AllH3aggregationtype()
}

func (e H3aggregationtype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *H3aggregationtype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e H3aggregationtype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *H3aggregationtype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e H3aggregationtype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *H3aggregationtype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = H3aggregationtype(x)
	case []byte:
		*e = H3aggregationtype(x)
	case nil:
		return fmt.Errorf("cannot nil into H3aggregationtype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid H3aggregationtype value: %s", *e)
	}

	return nil
}

// Enum values for Hashtype
const (
	HashtypeBcrypt14 Hashtype = "bcrypt-14"
)

func AllHashtype() []Hashtype {
	return []Hashtype{
		HashtypeBcrypt14,
	}
}

type Hashtype string

func (e Hashtype) String() string {
	return string(e)
}

func (e Hashtype) Valid() bool {
	switch e {
	case HashtypeBcrypt14:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e Hashtype) All() []Hashtype {
	return AllHashtype()
}

func (e Hashtype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *Hashtype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e Hashtype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *Hashtype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e Hashtype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *Hashtype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = Hashtype(x)
	case []byte:
		*e = Hashtype(x)
	case nil:
		return fmt.Errorf("cannot nil into Hashtype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid Hashtype value: %s", *e)
	}

	return nil
}

// Enum values for Imagedatatype
const (
	ImagedatatypeRaw Imagedatatype = "raw"
	ImagedatatypePNG Imagedatatype = "png"
)

func AllImagedatatype() []Imagedatatype {
	return []Imagedatatype{
		ImagedatatypeRaw,
		ImagedatatypePNG,
	}
}

type Imagedatatype string

func (e Imagedatatype) String() string {
	return string(e)
}

func (e Imagedatatype) Valid() bool {
	switch e {
	case ImagedatatypeRaw, ImagedatatypePNG:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e Imagedatatype) All() []Imagedatatype {
	return AllImagedatatype()
}

func (e Imagedatatype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *Imagedatatype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e Imagedatatype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *Imagedatatype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e Imagedatatype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *Imagedatatype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = Imagedatatype(x)
	case []byte:
		*e = Imagedatatype(x)
	case nil:
		return fmt.Errorf("cannot nil into Imagedatatype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid Imagedatatype value: %s", *e)
	}

	return nil
}

// Enum values for Notificationtype
const (
	NotificationtypeOauthTokenInvalidated Notificationtype = "oauth_token_invalidated"
)

func AllNotificationtype() []Notificationtype {
	return []Notificationtype{
		NotificationtypeOauthTokenInvalidated,
	}
}

type Notificationtype string

func (e Notificationtype) String() string {
	return string(e)
}

func (e Notificationtype) Valid() bool {
	switch e {
	case NotificationtypeOauthTokenInvalidated:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e Notificationtype) All() []Notificationtype {
	return AllNotificationtype()
}

func (e Notificationtype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *Notificationtype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e Notificationtype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *Notificationtype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e Notificationtype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *Notificationtype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = Notificationtype(x)
	case []byte:
		*e = Notificationtype(x)
	case nil:
		return fmt.Errorf("cannot nil into Notificationtype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid Notificationtype value: %s", *e)
	}

	return nil
}

// Enum values for PublicreportNuisancedurationtype
const (
	PublicreportNuisancedurationtypeNone        PublicreportNuisancedurationtype = "none"
	PublicreportNuisancedurationtypeJustNoticed PublicreportNuisancedurationtype = "just-noticed"
	PublicreportNuisancedurationtypeFewDays     PublicreportNuisancedurationtype = "few-days"
	PublicreportNuisancedurationtype12Weeks     PublicreportNuisancedurationtype = "1-2-weeks"
	PublicreportNuisancedurationtype24Weeks     PublicreportNuisancedurationtype = "2-4-weeks"
	PublicreportNuisancedurationtype13Months    PublicreportNuisancedurationtype = "1-3-months"
	PublicreportNuisancedurationtypeSeasonal    PublicreportNuisancedurationtype = "seasonal"
)

func AllPublicreportNuisancedurationtype() []PublicreportNuisancedurationtype {
	return []PublicreportNuisancedurationtype{
		PublicreportNuisancedurationtypeNone,
		PublicreportNuisancedurationtypeJustNoticed,
		PublicreportNuisancedurationtypeFewDays,
		PublicreportNuisancedurationtype12Weeks,
		PublicreportNuisancedurationtype24Weeks,
		PublicreportNuisancedurationtype13Months,
		PublicreportNuisancedurationtypeSeasonal,
	}
}

type PublicreportNuisancedurationtype string

func (e PublicreportNuisancedurationtype) String() string {
	return string(e)
}

func (e PublicreportNuisancedurationtype) Valid() bool {
	switch e {
	case PublicreportNuisancedurationtypeNone,
		PublicreportNuisancedurationtypeJustNoticed,
		PublicreportNuisancedurationtypeFewDays,
		PublicreportNuisancedurationtype12Weeks,
		PublicreportNuisancedurationtype24Weeks,
		PublicreportNuisancedurationtype13Months,
		PublicreportNuisancedurationtypeSeasonal:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e PublicreportNuisancedurationtype) All() []PublicreportNuisancedurationtype {
	return AllPublicreportNuisancedurationtype()
}

func (e PublicreportNuisancedurationtype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisancedurationtype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e PublicreportNuisancedurationtype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisancedurationtype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e PublicreportNuisancedurationtype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *PublicreportNuisancedurationtype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = PublicreportNuisancedurationtype(x)
	case []byte:
		*e = PublicreportNuisancedurationtype(x)
	case nil:
		return fmt.Errorf("cannot nil into PublicreportNuisancedurationtype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid PublicreportNuisancedurationtype value: %s", *e)
	}

	return nil
}

// Enum values for PublicreportNuisanceinspectiontype
const (
	PublicreportNuisanceinspectiontypeNeighborhood PublicreportNuisanceinspectiontype = "neighborhood"
	PublicreportNuisanceinspectiontypeProperty     PublicreportNuisanceinspectiontype = "property"
)

func AllPublicreportNuisanceinspectiontype() []PublicreportNuisanceinspectiontype {
	return []PublicreportNuisanceinspectiontype{
		PublicreportNuisanceinspectiontypeNeighborhood,
		PublicreportNuisanceinspectiontypeProperty,
	}
}

type PublicreportNuisanceinspectiontype string

func (e PublicreportNuisanceinspectiontype) String() string {
	return string(e)
}

func (e PublicreportNuisanceinspectiontype) Valid() bool {
	switch e {
	case PublicreportNuisanceinspectiontypeNeighborhood,
		PublicreportNuisanceinspectiontypeProperty:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e PublicreportNuisanceinspectiontype) All() []PublicreportNuisanceinspectiontype {
	return AllPublicreportNuisanceinspectiontype()
}

func (e PublicreportNuisanceinspectiontype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisanceinspectiontype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e PublicreportNuisanceinspectiontype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisanceinspectiontype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e PublicreportNuisanceinspectiontype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *PublicreportNuisanceinspectiontype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = PublicreportNuisanceinspectiontype(x)
	case []byte:
		*e = PublicreportNuisanceinspectiontype(x)
	case nil:
		return fmt.Errorf("cannot nil into PublicreportNuisanceinspectiontype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid PublicreportNuisanceinspectiontype value: %s", *e)
	}

	return nil
}

// Enum values for PublicreportNuisancelocationtype
const (
	PublicreportNuisancelocationtypeNone       PublicreportNuisancelocationtype = "none"
	PublicreportNuisancelocationtypeFrontYard  PublicreportNuisancelocationtype = "front-yard"
	PublicreportNuisancelocationtypeBackyard   PublicreportNuisancelocationtype = "backyard"
	PublicreportNuisancelocationtypePatio      PublicreportNuisancelocationtype = "patio"
	PublicreportNuisancelocationtypeGarden     PublicreportNuisancelocationtype = "garden"
	PublicreportNuisancelocationtypePoolArea   PublicreportNuisancelocationtype = "pool-area"
	PublicreportNuisancelocationtypeThroughout PublicreportNuisancelocationtype = "throughout"
	PublicreportNuisancelocationtypeIndoors    PublicreportNuisancelocationtype = "indoors"
	PublicreportNuisancelocationtypeOther      PublicreportNuisancelocationtype = "other"
)

func AllPublicreportNuisancelocationtype() []PublicreportNuisancelocationtype {
	return []PublicreportNuisancelocationtype{
		PublicreportNuisancelocationtypeNone,
		PublicreportNuisancelocationtypeFrontYard,
		PublicreportNuisancelocationtypeBackyard,
		PublicreportNuisancelocationtypePatio,
		PublicreportNuisancelocationtypeGarden,
		PublicreportNuisancelocationtypePoolArea,
		PublicreportNuisancelocationtypeThroughout,
		PublicreportNuisancelocationtypeIndoors,
		PublicreportNuisancelocationtypeOther,
	}
}

type PublicreportNuisancelocationtype string

func (e PublicreportNuisancelocationtype) String() string {
	return string(e)
}

func (e PublicreportNuisancelocationtype) Valid() bool {
	switch e {
	case PublicreportNuisancelocationtypeNone,
		PublicreportNuisancelocationtypeFrontYard,
		PublicreportNuisancelocationtypeBackyard,
		PublicreportNuisancelocationtypePatio,
		PublicreportNuisancelocationtypeGarden,
		PublicreportNuisancelocationtypePoolArea,
		PublicreportNuisancelocationtypeThroughout,
		PublicreportNuisancelocationtypeIndoors,
		PublicreportNuisancelocationtypeOther:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e PublicreportNuisancelocationtype) All() []PublicreportNuisancelocationtype {
	return AllPublicreportNuisancelocationtype()
}

func (e PublicreportNuisancelocationtype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisancelocationtype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e PublicreportNuisancelocationtype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisancelocationtype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e PublicreportNuisancelocationtype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *PublicreportNuisancelocationtype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = PublicreportNuisancelocationtype(x)
	case []byte:
		*e = PublicreportNuisancelocationtype(x)
	case nil:
		return fmt.Errorf("cannot nil into PublicreportNuisancelocationtype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid PublicreportNuisancelocationtype value: %s", *e)
	}

	return nil
}

// Enum values for PublicreportNuisancepreferreddaterangetype
const (
	PublicreportNuisancepreferreddaterangetypeNone       PublicreportNuisancepreferreddaterangetype = "none"
	PublicreportNuisancepreferreddaterangetypeAnyTime    PublicreportNuisancepreferreddaterangetype = "any-time"
	PublicreportNuisancepreferreddaterangetypeInTwoWeeks PublicreportNuisancepreferreddaterangetype = "in-two-weeks"
	PublicreportNuisancepreferreddaterangetypeNextWeek   PublicreportNuisancepreferreddaterangetype = "next-week"
)

func AllPublicreportNuisancepreferreddaterangetype() []PublicreportNuisancepreferreddaterangetype {
	return []PublicreportNuisancepreferreddaterangetype{
		PublicreportNuisancepreferreddaterangetypeNone,
		PublicreportNuisancepreferreddaterangetypeAnyTime,
		PublicreportNuisancepreferreddaterangetypeInTwoWeeks,
		PublicreportNuisancepreferreddaterangetypeNextWeek,
	}
}

type PublicreportNuisancepreferreddaterangetype string

func (e PublicreportNuisancepreferreddaterangetype) String() string {
	return string(e)
}

func (e PublicreportNuisancepreferreddaterangetype) Valid() bool {
	switch e {
	case PublicreportNuisancepreferreddaterangetypeNone,
		PublicreportNuisancepreferreddaterangetypeAnyTime,
		PublicreportNuisancepreferreddaterangetypeInTwoWeeks,
		PublicreportNuisancepreferreddaterangetypeNextWeek:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e PublicreportNuisancepreferreddaterangetype) All() []PublicreportNuisancepreferreddaterangetype {
	return AllPublicreportNuisancepreferreddaterangetype()
}

func (e PublicreportNuisancepreferreddaterangetype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisancepreferreddaterangetype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e PublicreportNuisancepreferreddaterangetype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisancepreferreddaterangetype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e PublicreportNuisancepreferreddaterangetype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *PublicreportNuisancepreferreddaterangetype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = PublicreportNuisancepreferreddaterangetype(x)
	case []byte:
		*e = PublicreportNuisancepreferreddaterangetype(x)
	case nil:
		return fmt.Errorf("cannot nil into PublicreportNuisancepreferreddaterangetype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid PublicreportNuisancepreferreddaterangetype value: %s", *e)
	}

	return nil
}

// Enum values for PublicreportNuisancepreferredtimetype
const (
	PublicreportNuisancepreferredtimetypeNone      PublicreportNuisancepreferredtimetype = "none"
	PublicreportNuisancepreferredtimetypeAfternoon PublicreportNuisancepreferredtimetype = "afternoon"
	PublicreportNuisancepreferredtimetypeAnyTime   PublicreportNuisancepreferredtimetype = "any-time"
	PublicreportNuisancepreferredtimetypeMorning   PublicreportNuisancepreferredtimetype = "morning"
)

func AllPublicreportNuisancepreferredtimetype() []PublicreportNuisancepreferredtimetype {
	return []PublicreportNuisancepreferredtimetype{
		PublicreportNuisancepreferredtimetypeNone,
		PublicreportNuisancepreferredtimetypeAfternoon,
		PublicreportNuisancepreferredtimetypeAnyTime,
		PublicreportNuisancepreferredtimetypeMorning,
	}
}

type PublicreportNuisancepreferredtimetype string

func (e PublicreportNuisancepreferredtimetype) String() string {
	return string(e)
}

func (e PublicreportNuisancepreferredtimetype) Valid() bool {
	switch e {
	case PublicreportNuisancepreferredtimetypeNone,
		PublicreportNuisancepreferredtimetypeAfternoon,
		PublicreportNuisancepreferredtimetypeAnyTime,
		PublicreportNuisancepreferredtimetypeMorning:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e PublicreportNuisancepreferredtimetype) All() []PublicreportNuisancepreferredtimetype {
	return AllPublicreportNuisancepreferredtimetype()
}

func (e PublicreportNuisancepreferredtimetype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisancepreferredtimetype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e PublicreportNuisancepreferredtimetype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportNuisancepreferredtimetype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e PublicreportNuisancepreferredtimetype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *PublicreportNuisancepreferredtimetype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = PublicreportNuisancepreferredtimetype(x)
	case []byte:
		*e = PublicreportNuisancepreferredtimetype(x)
	case nil:
		return fmt.Errorf("cannot nil into PublicreportNuisancepreferredtimetype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid PublicreportNuisancepreferredtimetype value: %s", *e)
	}

	return nil
}

// Enum values for PublicreportPoolsourceduration
const (
	PublicreportPoolsourcedurationNone            PublicreportPoolsourceduration = "none"
	PublicreportPoolsourcedurationLessThanWeek    PublicreportPoolsourceduration = "less-than-week"
	PublicreportPoolsourceduration12Weeks         PublicreportPoolsourceduration = "1-2-weeks"
	PublicreportPoolsourceduration24Weeks         PublicreportPoolsourceduration = "2-4-weeks"
	PublicreportPoolsourceduration13Months        PublicreportPoolsourceduration = "1-3-months"
	PublicreportPoolsourcedurationMoreThan3Months PublicreportPoolsourceduration = "more-than-3-months"
)

func AllPublicreportPoolsourceduration() []PublicreportPoolsourceduration {
	return []PublicreportPoolsourceduration{
		PublicreportPoolsourcedurationNone,
		PublicreportPoolsourcedurationLessThanWeek,
		PublicreportPoolsourceduration12Weeks,
		PublicreportPoolsourceduration24Weeks,
		PublicreportPoolsourceduration13Months,
		PublicreportPoolsourcedurationMoreThan3Months,
	}
}

type PublicreportPoolsourceduration string

func (e PublicreportPoolsourceduration) String() string {
	return string(e)
}

func (e PublicreportPoolsourceduration) Valid() bool {
	switch e {
	case PublicreportPoolsourcedurationNone,
		PublicreportPoolsourcedurationLessThanWeek,
		PublicreportPoolsourceduration12Weeks,
		PublicreportPoolsourceduration24Weeks,
		PublicreportPoolsourceduration13Months,
		PublicreportPoolsourcedurationMoreThan3Months:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e PublicreportPoolsourceduration) All() []PublicreportPoolsourceduration {
	return AllPublicreportPoolsourceduration()
}

func (e PublicreportPoolsourceduration) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportPoolsourceduration) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e PublicreportPoolsourceduration) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportPoolsourceduration) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e PublicreportPoolsourceduration) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *PublicreportPoolsourceduration) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = PublicreportPoolsourceduration(x)
	case []byte:
		*e = PublicreportPoolsourceduration(x)
	case nil:
		return fmt.Errorf("cannot nil into PublicreportPoolsourceduration")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid PublicreportPoolsourceduration value: %s", *e)
	}

	return nil
}

// Enum values for PublicreportReportstatustype
const (
	PublicreportReportstatustypeReported  PublicreportReportstatustype = "reported"
	PublicreportReportstatustypeReviewed  PublicreportReportstatustype = "reviewed"
	PublicreportReportstatustypeScheduled PublicreportReportstatustype = "scheduled"
	PublicreportReportstatustypeTreated   PublicreportReportstatustype = "treated"
)

func AllPublicreportReportstatustype() []PublicreportReportstatustype {
	return []PublicreportReportstatustype{
		PublicreportReportstatustypeReported,
		PublicreportReportstatustypeReviewed,
		PublicreportReportstatustypeScheduled,
		PublicreportReportstatustypeTreated,
	}
}

type PublicreportReportstatustype string

func (e PublicreportReportstatustype) String() string {
	return string(e)
}

func (e PublicreportReportstatustype) Valid() bool {
	switch e {
	case PublicreportReportstatustypeReported,
		PublicreportReportstatustypeReviewed,
		PublicreportReportstatustypeScheduled,
		PublicreportReportstatustypeTreated:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e PublicreportReportstatustype) All() []PublicreportReportstatustype {
	return AllPublicreportReportstatustype()
}

func (e PublicreportReportstatustype) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportReportstatustype) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e PublicreportReportstatustype) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *PublicreportReportstatustype) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e PublicreportReportstatustype) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *PublicreportReportstatustype) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = PublicreportReportstatustype(x)
	case []byte:
		*e = PublicreportReportstatustype(x)
	case nil:
		return fmt.Errorf("cannot nil into PublicreportReportstatustype")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid PublicreportReportstatustype value: %s", *e)
	}

	return nil
}
