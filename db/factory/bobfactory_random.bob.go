// Code generated by BobGen psql v0.42.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"math"
	"strconv"
	"strings"
	"time"

	"github.com/Gleipnir-Technology/bob/types"
	"github.com/Gleipnir-Technology/bob/types/pgtypes"
	enums "github.com/Gleipnir-Technology/nidus-sync/db/enums"
	"github.com/google/uuid"
	"github.com/jaswdr/faker/v2"
	"github.com/lib/pq"
	"github.com/shopspring/decimal"
)

var defaultFaker = faker.New()

func random___byte(f *faker.Faker, limits ...string) []byte {
	if f == nil {
		f = &defaultFaker
	}

	return []byte(random_string(f, limits...))
}

func random_bool(f *faker.Faker, limits ...string) bool {
	if f == nil {
		f = &defaultFaker
	}

	return f.Bool()
}

func random_decimal_Decimal(f *faker.Faker, limits ...string) decimal.Decimal {
	if f == nil {
		f = &defaultFaker
	}

	var precision int64 = 7
	var scale int64 = 3

	if len(limits) > 0 {
		precision, _ = strconv.ParseInt(limits[0], 10, 32)
	}

	if len(limits) > 1 {
		scale, _ = strconv.ParseInt(limits[1], 10, 32)
	}

	baseVal := f.Float32(10, -1, 1)
	for baseVal == -1 || baseVal == 0 || baseVal == 1 {
		baseVal = f.Float32(10, -1, 1)
	}

	precisionDecimal, _ := decimal.NewFromInt(10).PowInt32(int32(precision))
	val := decimal.
		NewFromFloat32(baseVal).
		Mul(precisionDecimal).
		Shift(int32(-1 * scale)).
		RoundDown(int32(scale))

	return val
}

func random_enums_Arcgislicensetype(f *faker.Faker, limits ...string) enums.Arcgislicensetype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.Arcgislicensetype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_Audiodatatype(f *faker.Faker, limits ...string) enums.Audiodatatype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.Audiodatatype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_CommsMessagetypeemail(f *faker.Faker, limits ...string) enums.CommsMessagetypeemail {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.CommsMessagetypeemail
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_CommsPhonestatustype(f *faker.Faker, limits ...string) enums.CommsPhonestatustype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.CommsPhonestatustype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_CommsTextjobsource(f *faker.Faker, limits ...string) enums.CommsTextjobsource {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.CommsTextjobsource
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_CommsTextjobtype(f *faker.Faker, limits ...string) enums.CommsTextjobtype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.CommsTextjobtype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_CommsTextorigin(f *faker.Faker, limits ...string) enums.CommsTextorigin {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.CommsTextorigin
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_H3aggregationtype(f *faker.Faker, limits ...string) enums.H3aggregationtype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.H3aggregationtype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_Hashtype(f *faker.Faker, limits ...string) enums.Hashtype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.Hashtype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_Notificationtype(f *faker.Faker, limits ...string) enums.Notificationtype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.Notificationtype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_PublicreportAccuracytype(f *faker.Faker, limits ...string) enums.PublicreportAccuracytype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.PublicreportAccuracytype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_PublicreportNuisancedurationtype(f *faker.Faker, limits ...string) enums.PublicreportNuisancedurationtype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.PublicreportNuisancedurationtype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_enums_PublicreportReportstatustype(f *faker.Faker, limits ...string) enums.PublicreportReportstatustype {
	if f == nil {
		f = &defaultFaker
	}

	var e enums.PublicreportReportstatustype
	all := e.All()
	return all[f.IntBetween(0, len(all)-1)]
}

func random_float32(f *faker.Faker, limits ...string) float32 {
	if f == nil {
		f = &defaultFaker
	}

	var precision int64 = 5
	var scale int64 = 2

	if len(limits) > 0 {
		precision, _ = strconv.ParseInt(limits[0], 10, 32)
	}

	if len(limits) > 1 {
		scale, _ = strconv.ParseInt(limits[1], 10, 32)
	}

	baseVal := f.Float64(10, -1, 1)
	for baseVal == -1 || baseVal == 0 || baseVal == 1 {
		baseVal = f.Float64(10, -1, 1)
	}

	scaleFloat := math.Pow10(int(scale))

	val := baseVal * math.Pow10(int(precision))
	val = math.Trunc(val) / scaleFloat

	return float32(val)
}

func random_float64(f *faker.Faker, limits ...string) float64 {
	if f == nil {
		f = &defaultFaker
	}

	var precision int64 = 5
	var scale int64 = 2

	if len(limits) > 0 {
		precision, _ = strconv.ParseInt(limits[0], 10, 32)
	}

	if len(limits) > 1 {
		scale, _ = strconv.ParseInt(limits[1], 10, 32)
	}

	baseVal := f.Float64(10, -1, 1)
	for baseVal == -1 || baseVal == 0 || baseVal == 1 {
		baseVal = f.Float64(10, -1, 1)
	}

	scaleFloat := math.Pow10(int(scale))

	val := baseVal * math.Pow10(int(precision))
	val = math.Trunc(val) / scaleFloat

	return val
}

func random_int16(f *faker.Faker, limits ...string) int16 {
	if f == nil {
		f = &defaultFaker
	}

	return f.Int16()
}

func random_int32(f *faker.Faker, limits ...string) int32 {
	if f == nil {
		f = &defaultFaker
	}

	return f.Int32()
}

func random_int64(f *faker.Faker, limits ...string) int64 {
	if f == nil {
		f = &defaultFaker
	}

	return f.Int64()
}

func random_pgtypes_HStore(f *faker.Faker, limits ...string) pgtypes.HStore {
	if f == nil {
		f = &defaultFaker
	}

	hs := make(pgtypes.HStore)
	for range f.IntBetween(1, 5) {
		hs[random_string(f)] = sql.Null[string]{V: random_string(f, limits...), Valid: f.Bool()}
	}
	return hs
}

func random_pq_BoolArray(f *faker.Faker, limits ...string) pq.BoolArray {
	if f == nil {
		f = &defaultFaker
	}

	arr := make(pq.BoolArray, f.IntBetween(1, 5))
	for i := range arr {
		arr[i] = random_bool(f, limits...)
	}
	return arr
}

func random_pq_Float64Array(f *faker.Faker, limits ...string) pq.Float64Array {
	if f == nil {
		f = &defaultFaker
	}

	arr := make(pq.Float64Array, f.IntBetween(1, 5))
	for i := range arr {
		arr[i] = random_float64(f, limits...)
	}
	return arr
}

func random_pq_StringArray(f *faker.Faker, limits ...string) pq.StringArray {
	if f == nil {
		f = &defaultFaker
	}

	arr := make(pq.StringArray, f.IntBetween(1, 5))
	for i := range arr {
		arr[i] = random_string(f, limits...)
	}
	return arr
}

func random_string(f *faker.Faker, limits ...string) string {
	if f == nil {
		f = &defaultFaker
	}

	val := strings.Join(f.Lorem().Words(f.IntBetween(1, 5)), " ")
	if len(limits) == 0 {
		return val
	}
	limitInt, _ := strconv.Atoi(limits[0])
	if limitInt > 0 && limitInt < len(val) {
		val = val[:limitInt]
	}
	return val
}

func random_time_Time(f *faker.Faker, limits ...string) time.Time {
	if f == nil {
		f = &defaultFaker
	}

	year := time.Hour * 24 * 365
	min := time.Now().Add(-year)
	max := time.Now().Add(year)
	return f.Time().TimeBetween(min, max)
}

func random_types_JSON_json_RawMessage_(f *faker.Faker, limits ...string) types.JSON[json.RawMessage] {
	if f == nil {
		f = &defaultFaker
	}

	s := &bytes.Buffer{}
	s.WriteRune('{')
	for i := range f.IntBetween(1, 5) {
		if i > 0 {
			fmt.Fprint(s, ", ")
		}
		fmt.Fprintf(s, "%q:%q", f.Lorem().Word(), f.Lorem().Word())
	}
	s.WriteRune('}')
	return types.NewJSON[json.RawMessage](s.Bytes())
}

func random_uuid_UUID(f *faker.Faker, limits ...string) uuid.UUID {
	if f == nil {
		f = &defaultFaker
	}

	return uuid.New()
}
