// Code generated by BobGen psql v0.42.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"testing"
	"time"

	"github.com/Gleipnir-Technology/bob"
	models "github.com/Gleipnir-Technology/nidus-sync/db/models"
	"github.com/aarondl/opt/omit"
	"github.com/jaswdr/faker/v2"
)

type ArcgisUserMod interface {
	Apply(context.Context, *ArcgisUserTemplate)
}

type ArcgisUserModFunc func(context.Context, *ArcgisUserTemplate)

func (f ArcgisUserModFunc) Apply(ctx context.Context, n *ArcgisUserTemplate) {
	f(ctx, n)
}

type ArcgisUserModSlice []ArcgisUserMod

func (mods ArcgisUserModSlice) Apply(ctx context.Context, n *ArcgisUserTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// ArcgisUserTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type ArcgisUserTemplate struct {
	Access            func() string
	Created           func() time.Time
	Email             func() string
	FullName          func() string
	ID                func() string
	Level             func() string
	OrgID             func() string
	PublicUserID      func() int32
	Region            func() string
	Role              func() string
	RoleID            func() string
	Username          func() string
	UserLicenseTypeID func() string
	UserType          func() string

	r arcgisuserR
	f *Factory

	alreadyPersisted bool
}

type arcgisuserR struct {
	PublicUserUser     *arcgisuserRPublicUserUserR
	UserUserPrivileges []*arcgisuserRUserUserPrivilegesR
}

type arcgisuserRPublicUserUserR struct {
	o *UserTemplate
}
type arcgisuserRUserUserPrivilegesR struct {
	number int
	o      *ArcgisUserPrivilegeTemplate
}

// Apply mods to the ArcgisUserTemplate
func (o *ArcgisUserTemplate) Apply(ctx context.Context, mods ...ArcgisUserMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// setModelRels creates and sets the relationships on *models.ArcgisUser
// according to the relationships in the template. Nothing is inserted into the db
func (t ArcgisUserTemplate) setModelRels(o *models.ArcgisUser) {
	if t.r.PublicUserUser != nil {
		rel := t.r.PublicUserUser.o.Build()
		rel.R.PublicUserUser = append(rel.R.PublicUserUser, o)
		o.PublicUserID = rel.ID // h2
		o.R.PublicUserUser = rel
	}

	if t.r.UserUserPrivileges != nil {
		rel := models.ArcgisUserPrivilegeSlice{}
		for _, r := range t.r.UserUserPrivileges {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.UserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.UserUserPrivileges = rel
	}
}

// BuildSetter returns an *models.ArcgisUserSetter
// this does nothing with the relationship templates
func (o ArcgisUserTemplate) BuildSetter() *models.ArcgisUserSetter {
	m := &models.ArcgisUserSetter{}

	if o.Access != nil {
		val := o.Access()
		m.Access = omit.From(val)
	}
	if o.Created != nil {
		val := o.Created()
		m.Created = omit.From(val)
	}
	if o.Email != nil {
		val := o.Email()
		m.Email = omit.From(val)
	}
	if o.FullName != nil {
		val := o.FullName()
		m.FullName = omit.From(val)
	}
	if o.ID != nil {
		val := o.ID()
		m.ID = omit.From(val)
	}
	if o.Level != nil {
		val := o.Level()
		m.Level = omit.From(val)
	}
	if o.OrgID != nil {
		val := o.OrgID()
		m.OrgID = omit.From(val)
	}
	if o.PublicUserID != nil {
		val := o.PublicUserID()
		m.PublicUserID = omit.From(val)
	}
	if o.Region != nil {
		val := o.Region()
		m.Region = omit.From(val)
	}
	if o.Role != nil {
		val := o.Role()
		m.Role = omit.From(val)
	}
	if o.RoleID != nil {
		val := o.RoleID()
		m.RoleID = omit.From(val)
	}
	if o.Username != nil {
		val := o.Username()
		m.Username = omit.From(val)
	}
	if o.UserLicenseTypeID != nil {
		val := o.UserLicenseTypeID()
		m.UserLicenseTypeID = omit.From(val)
	}
	if o.UserType != nil {
		val := o.UserType()
		m.UserType = omit.From(val)
	}

	return m
}

// BuildManySetter returns an []*models.ArcgisUserSetter
// this does nothing with the relationship templates
func (o ArcgisUserTemplate) BuildManySetter(number int) []*models.ArcgisUserSetter {
	m := make([]*models.ArcgisUserSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.ArcgisUser
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use ArcgisUserTemplate.Create
func (o ArcgisUserTemplate) Build() *models.ArcgisUser {
	m := &models.ArcgisUser{}

	if o.Access != nil {
		m.Access = o.Access()
	}
	if o.Created != nil {
		m.Created = o.Created()
	}
	if o.Email != nil {
		m.Email = o.Email()
	}
	if o.FullName != nil {
		m.FullName = o.FullName()
	}
	if o.ID != nil {
		m.ID = o.ID()
	}
	if o.Level != nil {
		m.Level = o.Level()
	}
	if o.OrgID != nil {
		m.OrgID = o.OrgID()
	}
	if o.PublicUserID != nil {
		m.PublicUserID = o.PublicUserID()
	}
	if o.Region != nil {
		m.Region = o.Region()
	}
	if o.Role != nil {
		m.Role = o.Role()
	}
	if o.RoleID != nil {
		m.RoleID = o.RoleID()
	}
	if o.Username != nil {
		m.Username = o.Username()
	}
	if o.UserLicenseTypeID != nil {
		m.UserLicenseTypeID = o.UserLicenseTypeID()
	}
	if o.UserType != nil {
		m.UserType = o.UserType()
	}

	o.setModelRels(m)

	return m
}

// BuildMany returns an models.ArcgisUserSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use ArcgisUserTemplate.CreateMany
func (o ArcgisUserTemplate) BuildMany(number int) models.ArcgisUserSlice {
	m := make(models.ArcgisUserSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableArcgisUser(m *models.ArcgisUserSetter) {
	if !(m.Access.IsValue()) {
		val := random_string(nil)
		m.Access = omit.From(val)
	}
	if !(m.Created.IsValue()) {
		val := random_time_Time(nil)
		m.Created = omit.From(val)
	}
	if !(m.Email.IsValue()) {
		val := random_string(nil)
		m.Email = omit.From(val)
	}
	if !(m.FullName.IsValue()) {
		val := random_string(nil)
		m.FullName = omit.From(val)
	}
	if !(m.ID.IsValue()) {
		val := random_string(nil)
		m.ID = omit.From(val)
	}
	if !(m.Level.IsValue()) {
		val := random_string(nil)
		m.Level = omit.From(val)
	}
	if !(m.OrgID.IsValue()) {
		val := random_string(nil)
		m.OrgID = omit.From(val)
	}
	if !(m.PublicUserID.IsValue()) {
		val := random_int32(nil)
		m.PublicUserID = omit.From(val)
	}
	if !(m.Region.IsValue()) {
		val := random_string(nil)
		m.Region = omit.From(val)
	}
	if !(m.Role.IsValue()) {
		val := random_string(nil)
		m.Role = omit.From(val)
	}
	if !(m.RoleID.IsValue()) {
		val := random_string(nil)
		m.RoleID = omit.From(val)
	}
	if !(m.Username.IsValue()) {
		val := random_string(nil)
		m.Username = omit.From(val)
	}
	if !(m.UserLicenseTypeID.IsValue()) {
		val := random_string(nil)
		m.UserLicenseTypeID = omit.From(val)
	}
	if !(m.UserType.IsValue()) {
		val := random_string(nil)
		m.UserType = omit.From(val)
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.ArcgisUser
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *ArcgisUserTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.ArcgisUser) error {
	var err error

	isUserUserPrivilegesDone, _ := arcgisuserRelUserUserPrivilegesCtx.Value(ctx)
	if !isUserUserPrivilegesDone && o.r.UserUserPrivileges != nil {
		ctx = arcgisuserRelUserUserPrivilegesCtx.WithValue(ctx, true)
		for _, r := range o.r.UserUserPrivileges {
			if r.o.alreadyPersisted {
				m.R.UserUserPrivileges = append(m.R.UserUserPrivileges, r.o.Build())
			} else {
				rel1, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachUserUserPrivileges(ctx, exec, rel1...)
				if err != nil {
					return err
				}
			}
		}
	}

	return err
}

// Create builds a arcgisuser and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *ArcgisUserTemplate) Create(ctx context.Context, exec bob.Executor) (*models.ArcgisUser, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableArcgisUser(opt)

	if o.r.PublicUserUser == nil {
		ArcgisUserMods.WithNewPublicUserUser().Apply(ctx, o)
	}

	var rel0 *models.User

	if o.r.PublicUserUser.o.alreadyPersisted {
		rel0 = o.r.PublicUserUser.o.Build()
	} else {
		rel0, err = o.r.PublicUserUser.o.Create(ctx, exec)
		if err != nil {
			return nil, err
		}
	}

	opt.PublicUserID = omit.From(rel0.ID)

	m, err := models.ArcgisUsers.Insert(opt).One(ctx, exec)
	if err != nil {
		return nil, err
	}

	m.R.PublicUserUser = rel0

	if err := o.insertOptRels(ctx, exec, m); err != nil {
		return nil, err
	}
	return m, err
}

// MustCreate builds a arcgisuser and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *ArcgisUserTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.ArcgisUser {
	m, err := o.Create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a arcgisuser and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *ArcgisUserTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.ArcgisUser {
	tb.Helper()
	m, err := o.Create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// CreateMany builds multiple arcgisusers and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o ArcgisUserTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.ArcgisUserSlice, error) {
	var err error
	m := make(models.ArcgisUserSlice, number)

	for i := range m {
		m[i], err = o.Create(ctx, exec)
		if err != nil {
			return nil, err
		}
	}

	return m, nil
}

// MustCreateMany builds multiple arcgisusers and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o ArcgisUserTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.ArcgisUserSlice {
	m, err := o.CreateMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple arcgisusers and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o ArcgisUserTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.ArcgisUserSlice {
	tb.Helper()
	m, err := o.CreateMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// ArcgisUser has methods that act as mods for the ArcgisUserTemplate
var ArcgisUserMods arcgisuserMods

type arcgisuserMods struct{}

func (m arcgisuserMods) RandomizeAllColumns(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModSlice{
		ArcgisUserMods.RandomAccess(f),
		ArcgisUserMods.RandomCreated(f),
		ArcgisUserMods.RandomEmail(f),
		ArcgisUserMods.RandomFullName(f),
		ArcgisUserMods.RandomID(f),
		ArcgisUserMods.RandomLevel(f),
		ArcgisUserMods.RandomOrgID(f),
		ArcgisUserMods.RandomPublicUserID(f),
		ArcgisUserMods.RandomRegion(f),
		ArcgisUserMods.RandomRole(f),
		ArcgisUserMods.RandomRoleID(f),
		ArcgisUserMods.RandomUsername(f),
		ArcgisUserMods.RandomUserLicenseTypeID(f),
		ArcgisUserMods.RandomUserType(f),
	}
}

// Set the model columns to this value
func (m arcgisuserMods) Access(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Access = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) AccessFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Access = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetAccess() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Access = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomAccess(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Access = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) Created(val time.Time) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Created = func() time.Time { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) CreatedFunc(f func() time.Time) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Created = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetCreated() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Created = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomCreated(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Created = func() time.Time {
			return random_time_Time(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) Email(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Email = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) EmailFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Email = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetEmail() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Email = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomEmail(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Email = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) FullName(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.FullName = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) FullNameFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.FullName = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetFullName() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.FullName = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomFullName(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.FullName = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) ID(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.ID = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) IDFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.ID = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetID() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.ID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomID(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.ID = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) Level(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Level = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) LevelFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Level = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetLevel() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Level = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomLevel(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Level = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) OrgID(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.OrgID = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) OrgIDFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.OrgID = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetOrgID() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.OrgID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomOrgID(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.OrgID = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) PublicUserID(val int32) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.PublicUserID = func() int32 { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) PublicUserIDFunc(f func() int32) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.PublicUserID = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetPublicUserID() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.PublicUserID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomPublicUserID(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.PublicUserID = func() int32 {
			return random_int32(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) Region(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Region = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) RegionFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Region = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetRegion() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Region = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomRegion(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Region = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) Role(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Role = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) RoleFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Role = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetRole() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Role = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomRole(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Role = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) RoleID(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.RoleID = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) RoleIDFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.RoleID = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetRoleID() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.RoleID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomRoleID(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.RoleID = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) Username(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Username = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) UsernameFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Username = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetUsername() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Username = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomUsername(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.Username = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) UserLicenseTypeID(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.UserLicenseTypeID = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) UserLicenseTypeIDFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.UserLicenseTypeID = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetUserLicenseTypeID() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.UserLicenseTypeID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomUserLicenseTypeID(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.UserLicenseTypeID = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m arcgisuserMods) UserType(val string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.UserType = func() string { return val }
	})
}

// Set the Column from the function
func (m arcgisuserMods) UserTypeFunc(f func() string) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.UserType = f
	})
}

// Clear any values for the column
func (m arcgisuserMods) UnsetUserType() ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.UserType = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m arcgisuserMods) RandomUserType(f *faker.Faker) ArcgisUserMod {
	return ArcgisUserModFunc(func(_ context.Context, o *ArcgisUserTemplate) {
		o.UserType = func() string {
			return random_string(f)
		}
	})
}

func (m arcgisuserMods) WithParentsCascading() ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		if isDone, _ := arcgisuserWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = arcgisuserWithParentsCascadingCtx.WithValue(ctx, true)
		{

			related := o.f.NewUserWithContext(ctx, UserMods.WithParentsCascading())
			m.WithPublicUserUser(related).Apply(ctx, o)
		}
	})
}

func (m arcgisuserMods) WithPublicUserUser(rel *UserTemplate) ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		o.r.PublicUserUser = &arcgisuserRPublicUserUserR{
			o: rel,
		}
	})
}

func (m arcgisuserMods) WithNewPublicUserUser(mods ...UserMod) ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		related := o.f.NewUserWithContext(ctx, mods...)

		m.WithPublicUserUser(related).Apply(ctx, o)
	})
}

func (m arcgisuserMods) WithExistingPublicUserUser(em *models.User) ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		o.r.PublicUserUser = &arcgisuserRPublicUserUserR{
			o: o.f.FromExistingUser(em),
		}
	})
}

func (m arcgisuserMods) WithoutPublicUserUser() ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		o.r.PublicUserUser = nil
	})
}

func (m arcgisuserMods) WithUserUserPrivileges(number int, related *ArcgisUserPrivilegeTemplate) ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		o.r.UserUserPrivileges = []*arcgisuserRUserUserPrivilegesR{{
			number: number,
			o:      related,
		}}
	})
}

func (m arcgisuserMods) WithNewUserUserPrivileges(number int, mods ...ArcgisUserPrivilegeMod) ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		related := o.f.NewArcgisUserPrivilegeWithContext(ctx, mods...)
		m.WithUserUserPrivileges(number, related).Apply(ctx, o)
	})
}

func (m arcgisuserMods) AddUserUserPrivileges(number int, related *ArcgisUserPrivilegeTemplate) ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		o.r.UserUserPrivileges = append(o.r.UserUserPrivileges, &arcgisuserRUserUserPrivilegesR{
			number: number,
			o:      related,
		})
	})
}

func (m arcgisuserMods) AddNewUserUserPrivileges(number int, mods ...ArcgisUserPrivilegeMod) ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		related := o.f.NewArcgisUserPrivilegeWithContext(ctx, mods...)
		m.AddUserUserPrivileges(number, related).Apply(ctx, o)
	})
}

func (m arcgisuserMods) AddExistingUserUserPrivileges(existingModels ...*models.ArcgisUserPrivilege) ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		for _, em := range existingModels {
			o.r.UserUserPrivileges = append(o.r.UserUserPrivileges, &arcgisuserRUserUserPrivilegesR{
				o: o.f.FromExistingArcgisUserPrivilege(em),
			})
		}
	})
}

func (m arcgisuserMods) WithoutUserUserPrivileges() ArcgisUserMod {
	return ArcgisUserModFunc(func(ctx context.Context, o *ArcgisUserTemplate) {
		o.r.UserUserPrivileges = nil
	})
}
