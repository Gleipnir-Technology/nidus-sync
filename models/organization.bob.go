// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// Organization is an object representing the database table.
type Organization struct {
	ID             int32            `db:"id,pk" `
	Name           null.Val[string] `db:"name" `
	ArcgisID       null.Val[string] `db:"arcgis_id" `
	ArcgisName     null.Val[string] `db:"arcgis_name" `
	FieldseekerURL null.Val[string] `db:"fieldseeker_url" `

	R organizationR `db:"-" `
}

// OrganizationSlice is an alias for a slice of pointers to Organization.
// This should almost always be used instead of []*Organization.
type OrganizationSlice []*Organization

// Organizations contains methods to work with the organization table
var Organizations = psql.NewTablex[*Organization, OrganizationSlice, *OrganizationSetter]("", "organization", buildOrganizationColumns("organization"))

// OrganizationsQuery is a query on the organization table
type OrganizationsQuery = *psql.ViewQuery[*Organization, OrganizationSlice]

// organizationR is where relationships are stored.
type organizationR struct {
	FSContainerrelates             FSContainerrelateSlice             // fs_containerrelate.fs_containerrelate_organization_id_fkey
	FSFieldscoutinglogs            FSFieldscoutinglogSlice            // fs_fieldscoutinglog.fs_fieldscoutinglog_organization_id_fkey
	FSHabitatrelates               FSHabitatrelateSlice               // fs_habitatrelate.fs_habitatrelate_organization_id_fkey
	FSInspectionsamples            FSInspectionsampleSlice            // fs_inspectionsample.fs_inspectionsample_organization_id_fkey
	FSInspectionsampledetails      FSInspectionsampledetailSlice      // fs_inspectionsampledetail.fs_inspectionsampledetail_organization_id_fkey
	FSLinelocations                FSLinelocationSlice                // fs_linelocation.fs_linelocation_organization_id_fkey
	FSLocationtrackings            FSLocationtrackingSlice            // fs_locationtracking.fs_locationtracking_organization_id_fkey
	FSMosquitoinspections          FSMosquitoinspectionSlice          // fs_mosquitoinspection.fs_mosquitoinspection_organization_id_fkey
	FSPointlocations               FSPointlocationSlice               // fs_pointlocation.fs_pointlocation_organization_id_fkey
	FSPolygonlocations             FSPolygonlocationSlice             // fs_polygonlocation.fs_polygonlocation_organization_id_fkey
	FSPools                        FSPoolSlice                        // fs_pool.fs_pool_organization_id_fkey
	FSPooldetails                  FSPooldetailSlice                  // fs_pooldetail.fs_pooldetail_organization_id_fkey
	FSProposedtreatmentareas       FSProposedtreatmentareaSlice       // fs_proposedtreatmentarea.fs_proposedtreatmentarea_organization_id_fkey
	FSQamosquitoinspections        FSQamosquitoinspectionSlice        // fs_qamosquitoinspection.fs_qamosquitoinspection_organization_id_fkey
	FSRodentlocations              FSRodentlocationSlice              // fs_rodentlocation.fs_rodentlocation_organization_id_fkey
	FSSamplecollections            FSSamplecollectionSlice            // fs_samplecollection.fs_samplecollection_organization_id_fkey
	FSSamplelocations              FSSamplelocationSlice              // fs_samplelocation.fs_samplelocation_organization_id_fkey
	FSServicerequests              FSServicerequestSlice              // fs_servicerequest.fs_servicerequest_organization_id_fkey
	FSSpeciesabundances            FSSpeciesabundanceSlice            // fs_speciesabundance.fs_speciesabundance_organization_id_fkey
	FSStormdrains                  FSStormdrainSlice                  // fs_stormdrain.fs_stormdrain_organization_id_fkey
	FSTimecards                    FSTimecardSlice                    // fs_timecard.fs_timecard_organization_id_fkey
	FSTrapdata                     FSTrapdatumSlice                   // fs_trapdata.fs_trapdata_organization_id_fkey
	FSTraplocations                FSTraplocationSlice                // fs_traplocation.fs_traplocation_organization_id_fkey
	FSTreatments                   FSTreatmentSlice                   // fs_treatment.fs_treatment_organization_id_fkey
	FSTreatmentareas               FSTreatmentareaSlice               // fs_treatmentarea.fs_treatmentarea_organization_id_fkey
	FSZones                        FSZoneSlice                        // fs_zones.fs_zones_organization_id_fkey
	FSZones2s                      FSZones2Slice                      // fs_zones2.fs_zones2_organization_id_fkey
	HistoryContainerrelates        HistoryContainerrelateSlice        // history_containerrelate.history_containerrelate_organization_id_fkey
	HistoryFieldscoutinglogs       HistoryFieldscoutinglogSlice       // history_fieldscoutinglog.history_fieldscoutinglog_organization_id_fkey
	HistoryHabitatrelates          HistoryHabitatrelateSlice          // history_habitatrelate.history_habitatrelate_organization_id_fkey
	HistoryInspectionsamples       HistoryInspectionsampleSlice       // history_inspectionsample.history_inspectionsample_organization_id_fkey
	HistoryInspectionsampledetails HistoryInspectionsampledetailSlice // history_inspectionsampledetail.history_inspectionsampledetail_organization_id_fkey
	HistoryLinelocations           HistoryLinelocationSlice           // history_linelocation.history_linelocation_organization_id_fkey
	HistoryLocationtrackings       HistoryLocationtrackingSlice       // history_locationtracking.history_locationtracking_organization_id_fkey
	HistoryMosquitoinspections     HistoryMosquitoinspectionSlice     // history_mosquitoinspection.history_mosquitoinspection_organization_id_fkey
	HistoryPointlocations          HistoryPointlocationSlice          // history_pointlocation.history_pointlocation_organization_id_fkey
	HistoryPolygonlocations        HistoryPolygonlocationSlice        // history_polygonlocation.history_polygonlocation_organization_id_fkey
	HistoryPools                   HistoryPoolSlice                   // history_pool.history_pool_organization_id_fkey
	HistoryPooldetails             HistoryPooldetailSlice             // history_pooldetail.history_pooldetail_organization_id_fkey
	HistoryProposedtreatmentareas  HistoryProposedtreatmentareaSlice  // history_proposedtreatmentarea.history_proposedtreatmentarea_organization_id_fkey
	HistoryQamosquitoinspections   HistoryQamosquitoinspectionSlice   // history_qamosquitoinspection.history_qamosquitoinspection_organization_id_fkey
	HistoryRodentlocations         HistoryRodentlocationSlice         // history_rodentlocation.history_rodentlocation_organization_id_fkey
	HistorySamplecollections       HistorySamplecollectionSlice       // history_samplecollection.history_samplecollection_organization_id_fkey
	HistorySamplelocations         HistorySamplelocationSlice         // history_samplelocation.history_samplelocation_organization_id_fkey
	HistoryServicerequests         HistoryServicerequestSlice         // history_servicerequest.history_servicerequest_organization_id_fkey
	HistorySpeciesabundances       HistorySpeciesabundanceSlice       // history_speciesabundance.history_speciesabundance_organization_id_fkey
	HistoryStormdrains             HistoryStormdrainSlice             // history_stormdrain.history_stormdrain_organization_id_fkey
	HistoryTimecards               HistoryTimecardSlice               // history_timecard.history_timecard_organization_id_fkey
	HistoryTrapdata                HistoryTrapdatumSlice              // history_trapdata.history_trapdata_organization_id_fkey
	HistoryTraplocations           HistoryTraplocationSlice           // history_traplocation.history_traplocation_organization_id_fkey
	HistoryTreatments              HistoryTreatmentSlice              // history_treatment.history_treatment_organization_id_fkey
	HistoryTreatmentareas          HistoryTreatmentareaSlice          // history_treatmentarea.history_treatmentarea_organization_id_fkey
	HistoryZones                   HistoryZoneSlice                   // history_zones.history_zones_organization_id_fkey
	HistoryZones2s                 HistoryZones2Slice                 // history_zones2.history_zones2_organization_id_fkey
	User                           UserSlice                          // user_.user__organization_id_fkey
}

func buildOrganizationColumns(alias string) organizationColumns {
	return organizationColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "name", "arcgis_id", "arcgis_name", "fieldseeker_url",
		).WithParent("organization"),
		tableAlias:     alias,
		ID:             psql.Quote(alias, "id"),
		Name:           psql.Quote(alias, "name"),
		ArcgisID:       psql.Quote(alias, "arcgis_id"),
		ArcgisName:     psql.Quote(alias, "arcgis_name"),
		FieldseekerURL: psql.Quote(alias, "fieldseeker_url"),
	}
}

type organizationColumns struct {
	expr.ColumnsExpr
	tableAlias     string
	ID             psql.Expression
	Name           psql.Expression
	ArcgisID       psql.Expression
	ArcgisName     psql.Expression
	FieldseekerURL psql.Expression
}

func (c organizationColumns) Alias() string {
	return c.tableAlias
}

func (organizationColumns) AliasedAs(alias string) organizationColumns {
	return buildOrganizationColumns(alias)
}

// OrganizationSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type OrganizationSetter struct {
	ID             omit.Val[int32]      `db:"id,pk" `
	Name           omitnull.Val[string] `db:"name" `
	ArcgisID       omitnull.Val[string] `db:"arcgis_id" `
	ArcgisName     omitnull.Val[string] `db:"arcgis_name" `
	FieldseekerURL omitnull.Val[string] `db:"fieldseeker_url" `
}

func (s OrganizationSetter) SetColumns() []string {
	vals := make([]string, 0, 5)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if !s.Name.IsUnset() {
		vals = append(vals, "name")
	}
	if !s.ArcgisID.IsUnset() {
		vals = append(vals, "arcgis_id")
	}
	if !s.ArcgisName.IsUnset() {
		vals = append(vals, "arcgis_name")
	}
	if !s.FieldseekerURL.IsUnset() {
		vals = append(vals, "fieldseeker_url")
	}
	return vals
}

func (s OrganizationSetter) Overwrite(t *Organization) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if !s.Name.IsUnset() {
		t.Name = s.Name.MustGetNull()
	}
	if !s.ArcgisID.IsUnset() {
		t.ArcgisID = s.ArcgisID.MustGetNull()
	}
	if !s.ArcgisName.IsUnset() {
		t.ArcgisName = s.ArcgisName.MustGetNull()
	}
	if !s.FieldseekerURL.IsUnset() {
		t.FieldseekerURL = s.FieldseekerURL.MustGetNull()
	}
}

func (s *OrganizationSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Organizations.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 5)
		if s.ID.IsValue() {
			vals[0] = psql.Arg(s.ID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Name.IsUnset() {
			vals[1] = psql.Arg(s.Name.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.ArcgisID.IsUnset() {
			vals[2] = psql.Arg(s.ArcgisID.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.ArcgisName.IsUnset() {
			vals[3] = psql.Arg(s.ArcgisName.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.FieldseekerURL.IsUnset() {
			vals[4] = psql.Arg(s.FieldseekerURL.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s OrganizationSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s OrganizationSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 5)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if !s.Name.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "name")...),
			psql.Arg(s.Name),
		}})
	}

	if !s.ArcgisID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "arcgis_id")...),
			psql.Arg(s.ArcgisID),
		}})
	}

	if !s.ArcgisName.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "arcgis_name")...),
			psql.Arg(s.ArcgisName),
		}})
	}

	if !s.FieldseekerURL.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "fieldseeker_url")...),
			psql.Arg(s.FieldseekerURL),
		}})
	}

	return exprs
}

// FindOrganization retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindOrganization(ctx context.Context, exec bob.Executor, IDPK int32, cols ...string) (*Organization, error) {
	if len(cols) == 0 {
		return Organizations.Query(
			sm.Where(Organizations.Columns.ID.EQ(psql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return Organizations.Query(
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(IDPK))),
		sm.Columns(Organizations.Columns.Only(cols...)),
	).One(ctx, exec)
}

// OrganizationExists checks the presence of a single record by primary key
func OrganizationExists(ctx context.Context, exec bob.Executor, IDPK int32) (bool, error) {
	return Organizations.Query(
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Organization is retrieved from the database
func (o *Organization) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Organizations.AfterSelectHooks.RunHooks(ctx, exec, OrganizationSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Organizations.AfterInsertHooks.RunHooks(ctx, exec, OrganizationSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Organizations.AfterUpdateHooks.RunHooks(ctx, exec, OrganizationSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Organizations.AfterDeleteHooks.RunHooks(ctx, exec, OrganizationSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Organization
func (o *Organization) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *Organization) pkEQ() dialect.Expression {
	return psql.Quote("organization", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Organization
func (o *Organization) Update(ctx context.Context, exec bob.Executor, s *OrganizationSetter) error {
	v, err := Organizations.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Organization record with an executor
func (o *Organization) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Organizations.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Organization using the executor
func (o *Organization) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Organizations.Query(
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after OrganizationSlice is retrieved from the database
func (o OrganizationSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Organizations.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Organizations.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Organizations.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Organizations.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o OrganizationSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("organization", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o OrganizationSlice) copyMatchingRows(from ...*Organization) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o OrganizationSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Organizations.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Organization:
				o.copyMatchingRows(retrieved)
			case []*Organization:
				o.copyMatchingRows(retrieved...)
			case OrganizationSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Organization or a slice of Organization
				// then run the AfterUpdateHooks on the slice
				_, err = Organizations.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o OrganizationSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Organizations.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Organization:
				o.copyMatchingRows(retrieved)
			case []*Organization:
				o.copyMatchingRows(retrieved...)
			case OrganizationSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Organization or a slice of Organization
				// then run the AfterDeleteHooks on the slice
				_, err = Organizations.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o OrganizationSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals OrganizationSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Organizations.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o OrganizationSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Organizations.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o OrganizationSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Organizations.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// FSContainerrelates starts a query for related objects on fs_containerrelate
func (o *Organization) FSContainerrelates(mods ...bob.Mod[*dialect.SelectQuery]) FSContainerrelatesQuery {
	return FSContainerrelates.Query(append(mods,
		sm.Where(FSContainerrelates.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSContainerrelates(mods ...bob.Mod[*dialect.SelectQuery]) FSContainerrelatesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSContainerrelates.Query(append(mods,
		sm.Where(psql.Group(FSContainerrelates.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSFieldscoutinglogs starts a query for related objects on fs_fieldscoutinglog
func (o *Organization) FSFieldscoutinglogs(mods ...bob.Mod[*dialect.SelectQuery]) FSFieldscoutinglogsQuery {
	return FSFieldscoutinglogs.Query(append(mods,
		sm.Where(FSFieldscoutinglogs.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSFieldscoutinglogs(mods ...bob.Mod[*dialect.SelectQuery]) FSFieldscoutinglogsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSFieldscoutinglogs.Query(append(mods,
		sm.Where(psql.Group(FSFieldscoutinglogs.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSHabitatrelates starts a query for related objects on fs_habitatrelate
func (o *Organization) FSHabitatrelates(mods ...bob.Mod[*dialect.SelectQuery]) FSHabitatrelatesQuery {
	return FSHabitatrelates.Query(append(mods,
		sm.Where(FSHabitatrelates.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSHabitatrelates(mods ...bob.Mod[*dialect.SelectQuery]) FSHabitatrelatesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSHabitatrelates.Query(append(mods,
		sm.Where(psql.Group(FSHabitatrelates.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSInspectionsamples starts a query for related objects on fs_inspectionsample
func (o *Organization) FSInspectionsamples(mods ...bob.Mod[*dialect.SelectQuery]) FSInspectionsamplesQuery {
	return FSInspectionsamples.Query(append(mods,
		sm.Where(FSInspectionsamples.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSInspectionsamples(mods ...bob.Mod[*dialect.SelectQuery]) FSInspectionsamplesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSInspectionsamples.Query(append(mods,
		sm.Where(psql.Group(FSInspectionsamples.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSInspectionsampledetails starts a query for related objects on fs_inspectionsampledetail
func (o *Organization) FSInspectionsampledetails(mods ...bob.Mod[*dialect.SelectQuery]) FSInspectionsampledetailsQuery {
	return FSInspectionsampledetails.Query(append(mods,
		sm.Where(FSInspectionsampledetails.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSInspectionsampledetails(mods ...bob.Mod[*dialect.SelectQuery]) FSInspectionsampledetailsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSInspectionsampledetails.Query(append(mods,
		sm.Where(psql.Group(FSInspectionsampledetails.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSLinelocations starts a query for related objects on fs_linelocation
func (o *Organization) FSLinelocations(mods ...bob.Mod[*dialect.SelectQuery]) FSLinelocationsQuery {
	return FSLinelocations.Query(append(mods,
		sm.Where(FSLinelocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSLinelocations(mods ...bob.Mod[*dialect.SelectQuery]) FSLinelocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSLinelocations.Query(append(mods,
		sm.Where(psql.Group(FSLinelocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSLocationtrackings starts a query for related objects on fs_locationtracking
func (o *Organization) FSLocationtrackings(mods ...bob.Mod[*dialect.SelectQuery]) FSLocationtrackingsQuery {
	return FSLocationtrackings.Query(append(mods,
		sm.Where(FSLocationtrackings.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSLocationtrackings(mods ...bob.Mod[*dialect.SelectQuery]) FSLocationtrackingsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSLocationtrackings.Query(append(mods,
		sm.Where(psql.Group(FSLocationtrackings.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSMosquitoinspections starts a query for related objects on fs_mosquitoinspection
func (o *Organization) FSMosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) FSMosquitoinspectionsQuery {
	return FSMosquitoinspections.Query(append(mods,
		sm.Where(FSMosquitoinspections.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSMosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) FSMosquitoinspectionsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSMosquitoinspections.Query(append(mods,
		sm.Where(psql.Group(FSMosquitoinspections.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSPointlocations starts a query for related objects on fs_pointlocation
func (o *Organization) FSPointlocations(mods ...bob.Mod[*dialect.SelectQuery]) FSPointlocationsQuery {
	return FSPointlocations.Query(append(mods,
		sm.Where(FSPointlocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSPointlocations(mods ...bob.Mod[*dialect.SelectQuery]) FSPointlocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSPointlocations.Query(append(mods,
		sm.Where(psql.Group(FSPointlocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSPolygonlocations starts a query for related objects on fs_polygonlocation
func (o *Organization) FSPolygonlocations(mods ...bob.Mod[*dialect.SelectQuery]) FSPolygonlocationsQuery {
	return FSPolygonlocations.Query(append(mods,
		sm.Where(FSPolygonlocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSPolygonlocations(mods ...bob.Mod[*dialect.SelectQuery]) FSPolygonlocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSPolygonlocations.Query(append(mods,
		sm.Where(psql.Group(FSPolygonlocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSPools starts a query for related objects on fs_pool
func (o *Organization) FSPools(mods ...bob.Mod[*dialect.SelectQuery]) FSPoolsQuery {
	return FSPools.Query(append(mods,
		sm.Where(FSPools.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSPools(mods ...bob.Mod[*dialect.SelectQuery]) FSPoolsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSPools.Query(append(mods,
		sm.Where(psql.Group(FSPools.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSPooldetails starts a query for related objects on fs_pooldetail
func (o *Organization) FSPooldetails(mods ...bob.Mod[*dialect.SelectQuery]) FSPooldetailsQuery {
	return FSPooldetails.Query(append(mods,
		sm.Where(FSPooldetails.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSPooldetails(mods ...bob.Mod[*dialect.SelectQuery]) FSPooldetailsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSPooldetails.Query(append(mods,
		sm.Where(psql.Group(FSPooldetails.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSProposedtreatmentareas starts a query for related objects on fs_proposedtreatmentarea
func (o *Organization) FSProposedtreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) FSProposedtreatmentareasQuery {
	return FSProposedtreatmentareas.Query(append(mods,
		sm.Where(FSProposedtreatmentareas.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSProposedtreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) FSProposedtreatmentareasQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSProposedtreatmentareas.Query(append(mods,
		sm.Where(psql.Group(FSProposedtreatmentareas.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSQamosquitoinspections starts a query for related objects on fs_qamosquitoinspection
func (o *Organization) FSQamosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) FSQamosquitoinspectionsQuery {
	return FSQamosquitoinspections.Query(append(mods,
		sm.Where(FSQamosquitoinspections.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSQamosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) FSQamosquitoinspectionsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSQamosquitoinspections.Query(append(mods,
		sm.Where(psql.Group(FSQamosquitoinspections.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSRodentlocations starts a query for related objects on fs_rodentlocation
func (o *Organization) FSRodentlocations(mods ...bob.Mod[*dialect.SelectQuery]) FSRodentlocationsQuery {
	return FSRodentlocations.Query(append(mods,
		sm.Where(FSRodentlocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSRodentlocations(mods ...bob.Mod[*dialect.SelectQuery]) FSRodentlocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSRodentlocations.Query(append(mods,
		sm.Where(psql.Group(FSRodentlocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSSamplecollections starts a query for related objects on fs_samplecollection
func (o *Organization) FSSamplecollections(mods ...bob.Mod[*dialect.SelectQuery]) FSSamplecollectionsQuery {
	return FSSamplecollections.Query(append(mods,
		sm.Where(FSSamplecollections.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSSamplecollections(mods ...bob.Mod[*dialect.SelectQuery]) FSSamplecollectionsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSSamplecollections.Query(append(mods,
		sm.Where(psql.Group(FSSamplecollections.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSSamplelocations starts a query for related objects on fs_samplelocation
func (o *Organization) FSSamplelocations(mods ...bob.Mod[*dialect.SelectQuery]) FSSamplelocationsQuery {
	return FSSamplelocations.Query(append(mods,
		sm.Where(FSSamplelocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSSamplelocations(mods ...bob.Mod[*dialect.SelectQuery]) FSSamplelocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSSamplelocations.Query(append(mods,
		sm.Where(psql.Group(FSSamplelocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSServicerequests starts a query for related objects on fs_servicerequest
func (o *Organization) FSServicerequests(mods ...bob.Mod[*dialect.SelectQuery]) FSServicerequestsQuery {
	return FSServicerequests.Query(append(mods,
		sm.Where(FSServicerequests.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSServicerequests(mods ...bob.Mod[*dialect.SelectQuery]) FSServicerequestsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSServicerequests.Query(append(mods,
		sm.Where(psql.Group(FSServicerequests.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSSpeciesabundances starts a query for related objects on fs_speciesabundance
func (o *Organization) FSSpeciesabundances(mods ...bob.Mod[*dialect.SelectQuery]) FSSpeciesabundancesQuery {
	return FSSpeciesabundances.Query(append(mods,
		sm.Where(FSSpeciesabundances.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSSpeciesabundances(mods ...bob.Mod[*dialect.SelectQuery]) FSSpeciesabundancesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSSpeciesabundances.Query(append(mods,
		sm.Where(psql.Group(FSSpeciesabundances.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSStormdrains starts a query for related objects on fs_stormdrain
func (o *Organization) FSStormdrains(mods ...bob.Mod[*dialect.SelectQuery]) FSStormdrainsQuery {
	return FSStormdrains.Query(append(mods,
		sm.Where(FSStormdrains.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSStormdrains(mods ...bob.Mod[*dialect.SelectQuery]) FSStormdrainsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSStormdrains.Query(append(mods,
		sm.Where(psql.Group(FSStormdrains.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSTimecards starts a query for related objects on fs_timecard
func (o *Organization) FSTimecards(mods ...bob.Mod[*dialect.SelectQuery]) FSTimecardsQuery {
	return FSTimecards.Query(append(mods,
		sm.Where(FSTimecards.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSTimecards(mods ...bob.Mod[*dialect.SelectQuery]) FSTimecardsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSTimecards.Query(append(mods,
		sm.Where(psql.Group(FSTimecards.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSTrapdata starts a query for related objects on fs_trapdata
func (o *Organization) FSTrapdata(mods ...bob.Mod[*dialect.SelectQuery]) FSTrapdataQuery {
	return FSTrapdata.Query(append(mods,
		sm.Where(FSTrapdata.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSTrapdata(mods ...bob.Mod[*dialect.SelectQuery]) FSTrapdataQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSTrapdata.Query(append(mods,
		sm.Where(psql.Group(FSTrapdata.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSTraplocations starts a query for related objects on fs_traplocation
func (o *Organization) FSTraplocations(mods ...bob.Mod[*dialect.SelectQuery]) FSTraplocationsQuery {
	return FSTraplocations.Query(append(mods,
		sm.Where(FSTraplocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSTraplocations(mods ...bob.Mod[*dialect.SelectQuery]) FSTraplocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSTraplocations.Query(append(mods,
		sm.Where(psql.Group(FSTraplocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSTreatments starts a query for related objects on fs_treatment
func (o *Organization) FSTreatments(mods ...bob.Mod[*dialect.SelectQuery]) FSTreatmentsQuery {
	return FSTreatments.Query(append(mods,
		sm.Where(FSTreatments.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSTreatments(mods ...bob.Mod[*dialect.SelectQuery]) FSTreatmentsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSTreatments.Query(append(mods,
		sm.Where(psql.Group(FSTreatments.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSTreatmentareas starts a query for related objects on fs_treatmentarea
func (o *Organization) FSTreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) FSTreatmentareasQuery {
	return FSTreatmentareas.Query(append(mods,
		sm.Where(FSTreatmentareas.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSTreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) FSTreatmentareasQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSTreatmentareas.Query(append(mods,
		sm.Where(psql.Group(FSTreatmentareas.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSZones starts a query for related objects on fs_zones
func (o *Organization) FSZones(mods ...bob.Mod[*dialect.SelectQuery]) FSZonesQuery {
	return FSZones.Query(append(mods,
		sm.Where(FSZones.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSZones(mods ...bob.Mod[*dialect.SelectQuery]) FSZonesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSZones.Query(append(mods,
		sm.Where(psql.Group(FSZones.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// FSZones2s starts a query for related objects on fs_zones2
func (o *Organization) FSZones2s(mods ...bob.Mod[*dialect.SelectQuery]) FSZones2sQuery {
	return FSZones2s.Query(append(mods,
		sm.Where(FSZones2s.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) FSZones2s(mods ...bob.Mod[*dialect.SelectQuery]) FSZones2sQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return FSZones2s.Query(append(mods,
		sm.Where(psql.Group(FSZones2s.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryContainerrelates starts a query for related objects on history_containerrelate
func (o *Organization) HistoryContainerrelates(mods ...bob.Mod[*dialect.SelectQuery]) HistoryContainerrelatesQuery {
	return HistoryContainerrelates.Query(append(mods,
		sm.Where(HistoryContainerrelates.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryContainerrelates(mods ...bob.Mod[*dialect.SelectQuery]) HistoryContainerrelatesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryContainerrelates.Query(append(mods,
		sm.Where(psql.Group(HistoryContainerrelates.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryFieldscoutinglogs starts a query for related objects on history_fieldscoutinglog
func (o *Organization) HistoryFieldscoutinglogs(mods ...bob.Mod[*dialect.SelectQuery]) HistoryFieldscoutinglogsQuery {
	return HistoryFieldscoutinglogs.Query(append(mods,
		sm.Where(HistoryFieldscoutinglogs.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryFieldscoutinglogs(mods ...bob.Mod[*dialect.SelectQuery]) HistoryFieldscoutinglogsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryFieldscoutinglogs.Query(append(mods,
		sm.Where(psql.Group(HistoryFieldscoutinglogs.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryHabitatrelates starts a query for related objects on history_habitatrelate
func (o *Organization) HistoryHabitatrelates(mods ...bob.Mod[*dialect.SelectQuery]) HistoryHabitatrelatesQuery {
	return HistoryHabitatrelates.Query(append(mods,
		sm.Where(HistoryHabitatrelates.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryHabitatrelates(mods ...bob.Mod[*dialect.SelectQuery]) HistoryHabitatrelatesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryHabitatrelates.Query(append(mods,
		sm.Where(psql.Group(HistoryHabitatrelates.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryInspectionsamples starts a query for related objects on history_inspectionsample
func (o *Organization) HistoryInspectionsamples(mods ...bob.Mod[*dialect.SelectQuery]) HistoryInspectionsamplesQuery {
	return HistoryInspectionsamples.Query(append(mods,
		sm.Where(HistoryInspectionsamples.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryInspectionsamples(mods ...bob.Mod[*dialect.SelectQuery]) HistoryInspectionsamplesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryInspectionsamples.Query(append(mods,
		sm.Where(psql.Group(HistoryInspectionsamples.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryInspectionsampledetails starts a query for related objects on history_inspectionsampledetail
func (o *Organization) HistoryInspectionsampledetails(mods ...bob.Mod[*dialect.SelectQuery]) HistoryInspectionsampledetailsQuery {
	return HistoryInspectionsampledetails.Query(append(mods,
		sm.Where(HistoryInspectionsampledetails.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryInspectionsampledetails(mods ...bob.Mod[*dialect.SelectQuery]) HistoryInspectionsampledetailsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryInspectionsampledetails.Query(append(mods,
		sm.Where(psql.Group(HistoryInspectionsampledetails.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryLinelocations starts a query for related objects on history_linelocation
func (o *Organization) HistoryLinelocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryLinelocationsQuery {
	return HistoryLinelocations.Query(append(mods,
		sm.Where(HistoryLinelocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryLinelocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryLinelocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryLinelocations.Query(append(mods,
		sm.Where(psql.Group(HistoryLinelocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryLocationtrackings starts a query for related objects on history_locationtracking
func (o *Organization) HistoryLocationtrackings(mods ...bob.Mod[*dialect.SelectQuery]) HistoryLocationtrackingsQuery {
	return HistoryLocationtrackings.Query(append(mods,
		sm.Where(HistoryLocationtrackings.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryLocationtrackings(mods ...bob.Mod[*dialect.SelectQuery]) HistoryLocationtrackingsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryLocationtrackings.Query(append(mods,
		sm.Where(psql.Group(HistoryLocationtrackings.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryMosquitoinspections starts a query for related objects on history_mosquitoinspection
func (o *Organization) HistoryMosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) HistoryMosquitoinspectionsQuery {
	return HistoryMosquitoinspections.Query(append(mods,
		sm.Where(HistoryMosquitoinspections.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryMosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) HistoryMosquitoinspectionsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryMosquitoinspections.Query(append(mods,
		sm.Where(psql.Group(HistoryMosquitoinspections.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryPointlocations starts a query for related objects on history_pointlocation
func (o *Organization) HistoryPointlocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryPointlocationsQuery {
	return HistoryPointlocations.Query(append(mods,
		sm.Where(HistoryPointlocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryPointlocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryPointlocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryPointlocations.Query(append(mods,
		sm.Where(psql.Group(HistoryPointlocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryPolygonlocations starts a query for related objects on history_polygonlocation
func (o *Organization) HistoryPolygonlocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryPolygonlocationsQuery {
	return HistoryPolygonlocations.Query(append(mods,
		sm.Where(HistoryPolygonlocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryPolygonlocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryPolygonlocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryPolygonlocations.Query(append(mods,
		sm.Where(psql.Group(HistoryPolygonlocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryPools starts a query for related objects on history_pool
func (o *Organization) HistoryPools(mods ...bob.Mod[*dialect.SelectQuery]) HistoryPoolsQuery {
	return HistoryPools.Query(append(mods,
		sm.Where(HistoryPools.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryPools(mods ...bob.Mod[*dialect.SelectQuery]) HistoryPoolsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryPools.Query(append(mods,
		sm.Where(psql.Group(HistoryPools.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryPooldetails starts a query for related objects on history_pooldetail
func (o *Organization) HistoryPooldetails(mods ...bob.Mod[*dialect.SelectQuery]) HistoryPooldetailsQuery {
	return HistoryPooldetails.Query(append(mods,
		sm.Where(HistoryPooldetails.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryPooldetails(mods ...bob.Mod[*dialect.SelectQuery]) HistoryPooldetailsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryPooldetails.Query(append(mods,
		sm.Where(psql.Group(HistoryPooldetails.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryProposedtreatmentareas starts a query for related objects on history_proposedtreatmentarea
func (o *Organization) HistoryProposedtreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) HistoryProposedtreatmentareasQuery {
	return HistoryProposedtreatmentareas.Query(append(mods,
		sm.Where(HistoryProposedtreatmentareas.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryProposedtreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) HistoryProposedtreatmentareasQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryProposedtreatmentareas.Query(append(mods,
		sm.Where(psql.Group(HistoryProposedtreatmentareas.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryQamosquitoinspections starts a query for related objects on history_qamosquitoinspection
func (o *Organization) HistoryQamosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) HistoryQamosquitoinspectionsQuery {
	return HistoryQamosquitoinspections.Query(append(mods,
		sm.Where(HistoryQamosquitoinspections.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryQamosquitoinspections(mods ...bob.Mod[*dialect.SelectQuery]) HistoryQamosquitoinspectionsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryQamosquitoinspections.Query(append(mods,
		sm.Where(psql.Group(HistoryQamosquitoinspections.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryRodentlocations starts a query for related objects on history_rodentlocation
func (o *Organization) HistoryRodentlocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryRodentlocationsQuery {
	return HistoryRodentlocations.Query(append(mods,
		sm.Where(HistoryRodentlocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryRodentlocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryRodentlocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryRodentlocations.Query(append(mods,
		sm.Where(psql.Group(HistoryRodentlocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistorySamplecollections starts a query for related objects on history_samplecollection
func (o *Organization) HistorySamplecollections(mods ...bob.Mod[*dialect.SelectQuery]) HistorySamplecollectionsQuery {
	return HistorySamplecollections.Query(append(mods,
		sm.Where(HistorySamplecollections.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistorySamplecollections(mods ...bob.Mod[*dialect.SelectQuery]) HistorySamplecollectionsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistorySamplecollections.Query(append(mods,
		sm.Where(psql.Group(HistorySamplecollections.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistorySamplelocations starts a query for related objects on history_samplelocation
func (o *Organization) HistorySamplelocations(mods ...bob.Mod[*dialect.SelectQuery]) HistorySamplelocationsQuery {
	return HistorySamplelocations.Query(append(mods,
		sm.Where(HistorySamplelocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistorySamplelocations(mods ...bob.Mod[*dialect.SelectQuery]) HistorySamplelocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistorySamplelocations.Query(append(mods,
		sm.Where(psql.Group(HistorySamplelocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryServicerequests starts a query for related objects on history_servicerequest
func (o *Organization) HistoryServicerequests(mods ...bob.Mod[*dialect.SelectQuery]) HistoryServicerequestsQuery {
	return HistoryServicerequests.Query(append(mods,
		sm.Where(HistoryServicerequests.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryServicerequests(mods ...bob.Mod[*dialect.SelectQuery]) HistoryServicerequestsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryServicerequests.Query(append(mods,
		sm.Where(psql.Group(HistoryServicerequests.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistorySpeciesabundances starts a query for related objects on history_speciesabundance
func (o *Organization) HistorySpeciesabundances(mods ...bob.Mod[*dialect.SelectQuery]) HistorySpeciesabundancesQuery {
	return HistorySpeciesabundances.Query(append(mods,
		sm.Where(HistorySpeciesabundances.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistorySpeciesabundances(mods ...bob.Mod[*dialect.SelectQuery]) HistorySpeciesabundancesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistorySpeciesabundances.Query(append(mods,
		sm.Where(psql.Group(HistorySpeciesabundances.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryStormdrains starts a query for related objects on history_stormdrain
func (o *Organization) HistoryStormdrains(mods ...bob.Mod[*dialect.SelectQuery]) HistoryStormdrainsQuery {
	return HistoryStormdrains.Query(append(mods,
		sm.Where(HistoryStormdrains.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryStormdrains(mods ...bob.Mod[*dialect.SelectQuery]) HistoryStormdrainsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryStormdrains.Query(append(mods,
		sm.Where(psql.Group(HistoryStormdrains.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryTimecards starts a query for related objects on history_timecard
func (o *Organization) HistoryTimecards(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTimecardsQuery {
	return HistoryTimecards.Query(append(mods,
		sm.Where(HistoryTimecards.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryTimecards(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTimecardsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryTimecards.Query(append(mods,
		sm.Where(psql.Group(HistoryTimecards.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryTrapdata starts a query for related objects on history_trapdata
func (o *Organization) HistoryTrapdata(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTrapdataQuery {
	return HistoryTrapdata.Query(append(mods,
		sm.Where(HistoryTrapdata.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryTrapdata(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTrapdataQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryTrapdata.Query(append(mods,
		sm.Where(psql.Group(HistoryTrapdata.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryTraplocations starts a query for related objects on history_traplocation
func (o *Organization) HistoryTraplocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTraplocationsQuery {
	return HistoryTraplocations.Query(append(mods,
		sm.Where(HistoryTraplocations.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryTraplocations(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTraplocationsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryTraplocations.Query(append(mods,
		sm.Where(psql.Group(HistoryTraplocations.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryTreatments starts a query for related objects on history_treatment
func (o *Organization) HistoryTreatments(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTreatmentsQuery {
	return HistoryTreatments.Query(append(mods,
		sm.Where(HistoryTreatments.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryTreatments(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTreatmentsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryTreatments.Query(append(mods,
		sm.Where(psql.Group(HistoryTreatments.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryTreatmentareas starts a query for related objects on history_treatmentarea
func (o *Organization) HistoryTreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTreatmentareasQuery {
	return HistoryTreatmentareas.Query(append(mods,
		sm.Where(HistoryTreatmentareas.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryTreatmentareas(mods ...bob.Mod[*dialect.SelectQuery]) HistoryTreatmentareasQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryTreatmentareas.Query(append(mods,
		sm.Where(psql.Group(HistoryTreatmentareas.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryZones starts a query for related objects on history_zones
func (o *Organization) HistoryZones(mods ...bob.Mod[*dialect.SelectQuery]) HistoryZonesQuery {
	return HistoryZones.Query(append(mods,
		sm.Where(HistoryZones.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryZones(mods ...bob.Mod[*dialect.SelectQuery]) HistoryZonesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryZones.Query(append(mods,
		sm.Where(psql.Group(HistoryZones.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// HistoryZones2s starts a query for related objects on history_zones2
func (o *Organization) HistoryZones2s(mods ...bob.Mod[*dialect.SelectQuery]) HistoryZones2sQuery {
	return HistoryZones2s.Query(append(mods,
		sm.Where(HistoryZones2s.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) HistoryZones2s(mods ...bob.Mod[*dialect.SelectQuery]) HistoryZones2sQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return HistoryZones2s.Query(append(mods,
		sm.Where(psql.Group(HistoryZones2s.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

// User starts a query for related objects on user_
func (o *Organization) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(Users.Columns.OrganizationID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os OrganizationSlice) User(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(Users.Columns.OrganizationID).OP("IN", PKArgExpr)),
	)...)
}

func insertOrganizationFSContainerrelates0(ctx context.Context, exec bob.Executor, fsContainerrelates1 []*FSContainerrelateSetter, organization0 *Organization) (FSContainerrelateSlice, error) {
	for i := range fsContainerrelates1 {
		fsContainerrelates1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSContainerrelates.Insert(bob.ToMods(fsContainerrelates1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSContainerrelates0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSContainerrelates0(ctx context.Context, exec bob.Executor, count int, fsContainerrelates1 FSContainerrelateSlice, organization0 *Organization) (FSContainerrelateSlice, error) {
	setter := &FSContainerrelateSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsContainerrelates1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSContainerrelates0: %w", err)
	}

	return fsContainerrelates1, nil
}

func (organization0 *Organization) InsertFSContainerrelates(ctx context.Context, exec bob.Executor, related ...*FSContainerrelateSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsContainerrelates1, err := insertOrganizationFSContainerrelates0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSContainerrelates = append(organization0.R.FSContainerrelates, fsContainerrelates1...)

	for _, rel := range fsContainerrelates1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSContainerrelates(ctx context.Context, exec bob.Executor, related ...*FSContainerrelate) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsContainerrelates1 := FSContainerrelateSlice(related)

	_, err = attachOrganizationFSContainerrelates0(ctx, exec, len(related), fsContainerrelates1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSContainerrelates = append(organization0.R.FSContainerrelates, fsContainerrelates1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSFieldscoutinglogs0(ctx context.Context, exec bob.Executor, fsFieldscoutinglogs1 []*FSFieldscoutinglogSetter, organization0 *Organization) (FSFieldscoutinglogSlice, error) {
	for i := range fsFieldscoutinglogs1 {
		fsFieldscoutinglogs1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSFieldscoutinglogs.Insert(bob.ToMods(fsFieldscoutinglogs1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSFieldscoutinglogs0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSFieldscoutinglogs0(ctx context.Context, exec bob.Executor, count int, fsFieldscoutinglogs1 FSFieldscoutinglogSlice, organization0 *Organization) (FSFieldscoutinglogSlice, error) {
	setter := &FSFieldscoutinglogSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsFieldscoutinglogs1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSFieldscoutinglogs0: %w", err)
	}

	return fsFieldscoutinglogs1, nil
}

func (organization0 *Organization) InsertFSFieldscoutinglogs(ctx context.Context, exec bob.Executor, related ...*FSFieldscoutinglogSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsFieldscoutinglogs1, err := insertOrganizationFSFieldscoutinglogs0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSFieldscoutinglogs = append(organization0.R.FSFieldscoutinglogs, fsFieldscoutinglogs1...)

	for _, rel := range fsFieldscoutinglogs1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSFieldscoutinglogs(ctx context.Context, exec bob.Executor, related ...*FSFieldscoutinglog) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsFieldscoutinglogs1 := FSFieldscoutinglogSlice(related)

	_, err = attachOrganizationFSFieldscoutinglogs0(ctx, exec, len(related), fsFieldscoutinglogs1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSFieldscoutinglogs = append(organization0.R.FSFieldscoutinglogs, fsFieldscoutinglogs1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSHabitatrelates0(ctx context.Context, exec bob.Executor, fsHabitatrelates1 []*FSHabitatrelateSetter, organization0 *Organization) (FSHabitatrelateSlice, error) {
	for i := range fsHabitatrelates1 {
		fsHabitatrelates1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSHabitatrelates.Insert(bob.ToMods(fsHabitatrelates1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSHabitatrelates0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSHabitatrelates0(ctx context.Context, exec bob.Executor, count int, fsHabitatrelates1 FSHabitatrelateSlice, organization0 *Organization) (FSHabitatrelateSlice, error) {
	setter := &FSHabitatrelateSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsHabitatrelates1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSHabitatrelates0: %w", err)
	}

	return fsHabitatrelates1, nil
}

func (organization0 *Organization) InsertFSHabitatrelates(ctx context.Context, exec bob.Executor, related ...*FSHabitatrelateSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsHabitatrelates1, err := insertOrganizationFSHabitatrelates0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSHabitatrelates = append(organization0.R.FSHabitatrelates, fsHabitatrelates1...)

	for _, rel := range fsHabitatrelates1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSHabitatrelates(ctx context.Context, exec bob.Executor, related ...*FSHabitatrelate) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsHabitatrelates1 := FSHabitatrelateSlice(related)

	_, err = attachOrganizationFSHabitatrelates0(ctx, exec, len(related), fsHabitatrelates1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSHabitatrelates = append(organization0.R.FSHabitatrelates, fsHabitatrelates1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSInspectionsamples0(ctx context.Context, exec bob.Executor, fsInspectionsamples1 []*FSInspectionsampleSetter, organization0 *Organization) (FSInspectionsampleSlice, error) {
	for i := range fsInspectionsamples1 {
		fsInspectionsamples1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSInspectionsamples.Insert(bob.ToMods(fsInspectionsamples1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSInspectionsamples0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSInspectionsamples0(ctx context.Context, exec bob.Executor, count int, fsInspectionsamples1 FSInspectionsampleSlice, organization0 *Organization) (FSInspectionsampleSlice, error) {
	setter := &FSInspectionsampleSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsInspectionsamples1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSInspectionsamples0: %w", err)
	}

	return fsInspectionsamples1, nil
}

func (organization0 *Organization) InsertFSInspectionsamples(ctx context.Context, exec bob.Executor, related ...*FSInspectionsampleSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsInspectionsamples1, err := insertOrganizationFSInspectionsamples0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSInspectionsamples = append(organization0.R.FSInspectionsamples, fsInspectionsamples1...)

	for _, rel := range fsInspectionsamples1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSInspectionsamples(ctx context.Context, exec bob.Executor, related ...*FSInspectionsample) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsInspectionsamples1 := FSInspectionsampleSlice(related)

	_, err = attachOrganizationFSInspectionsamples0(ctx, exec, len(related), fsInspectionsamples1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSInspectionsamples = append(organization0.R.FSInspectionsamples, fsInspectionsamples1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSInspectionsampledetails0(ctx context.Context, exec bob.Executor, fsInspectionsampledetails1 []*FSInspectionsampledetailSetter, organization0 *Organization) (FSInspectionsampledetailSlice, error) {
	for i := range fsInspectionsampledetails1 {
		fsInspectionsampledetails1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSInspectionsampledetails.Insert(bob.ToMods(fsInspectionsampledetails1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSInspectionsampledetails0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSInspectionsampledetails0(ctx context.Context, exec bob.Executor, count int, fsInspectionsampledetails1 FSInspectionsampledetailSlice, organization0 *Organization) (FSInspectionsampledetailSlice, error) {
	setter := &FSInspectionsampledetailSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsInspectionsampledetails1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSInspectionsampledetails0: %w", err)
	}

	return fsInspectionsampledetails1, nil
}

func (organization0 *Organization) InsertFSInspectionsampledetails(ctx context.Context, exec bob.Executor, related ...*FSInspectionsampledetailSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsInspectionsampledetails1, err := insertOrganizationFSInspectionsampledetails0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSInspectionsampledetails = append(organization0.R.FSInspectionsampledetails, fsInspectionsampledetails1...)

	for _, rel := range fsInspectionsampledetails1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSInspectionsampledetails(ctx context.Context, exec bob.Executor, related ...*FSInspectionsampledetail) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsInspectionsampledetails1 := FSInspectionsampledetailSlice(related)

	_, err = attachOrganizationFSInspectionsampledetails0(ctx, exec, len(related), fsInspectionsampledetails1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSInspectionsampledetails = append(organization0.R.FSInspectionsampledetails, fsInspectionsampledetails1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSLinelocations0(ctx context.Context, exec bob.Executor, fsLinelocations1 []*FSLinelocationSetter, organization0 *Organization) (FSLinelocationSlice, error) {
	for i := range fsLinelocations1 {
		fsLinelocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSLinelocations.Insert(bob.ToMods(fsLinelocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSLinelocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSLinelocations0(ctx context.Context, exec bob.Executor, count int, fsLinelocations1 FSLinelocationSlice, organization0 *Organization) (FSLinelocationSlice, error) {
	setter := &FSLinelocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsLinelocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSLinelocations0: %w", err)
	}

	return fsLinelocations1, nil
}

func (organization0 *Organization) InsertFSLinelocations(ctx context.Context, exec bob.Executor, related ...*FSLinelocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsLinelocations1, err := insertOrganizationFSLinelocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSLinelocations = append(organization0.R.FSLinelocations, fsLinelocations1...)

	for _, rel := range fsLinelocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSLinelocations(ctx context.Context, exec bob.Executor, related ...*FSLinelocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsLinelocations1 := FSLinelocationSlice(related)

	_, err = attachOrganizationFSLinelocations0(ctx, exec, len(related), fsLinelocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSLinelocations = append(organization0.R.FSLinelocations, fsLinelocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSLocationtrackings0(ctx context.Context, exec bob.Executor, fsLocationtrackings1 []*FSLocationtrackingSetter, organization0 *Organization) (FSLocationtrackingSlice, error) {
	for i := range fsLocationtrackings1 {
		fsLocationtrackings1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSLocationtrackings.Insert(bob.ToMods(fsLocationtrackings1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSLocationtrackings0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSLocationtrackings0(ctx context.Context, exec bob.Executor, count int, fsLocationtrackings1 FSLocationtrackingSlice, organization0 *Organization) (FSLocationtrackingSlice, error) {
	setter := &FSLocationtrackingSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsLocationtrackings1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSLocationtrackings0: %w", err)
	}

	return fsLocationtrackings1, nil
}

func (organization0 *Organization) InsertFSLocationtrackings(ctx context.Context, exec bob.Executor, related ...*FSLocationtrackingSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsLocationtrackings1, err := insertOrganizationFSLocationtrackings0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSLocationtrackings = append(organization0.R.FSLocationtrackings, fsLocationtrackings1...)

	for _, rel := range fsLocationtrackings1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSLocationtrackings(ctx context.Context, exec bob.Executor, related ...*FSLocationtracking) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsLocationtrackings1 := FSLocationtrackingSlice(related)

	_, err = attachOrganizationFSLocationtrackings0(ctx, exec, len(related), fsLocationtrackings1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSLocationtrackings = append(organization0.R.FSLocationtrackings, fsLocationtrackings1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSMosquitoinspections0(ctx context.Context, exec bob.Executor, fsMosquitoinspections1 []*FSMosquitoinspectionSetter, organization0 *Organization) (FSMosquitoinspectionSlice, error) {
	for i := range fsMosquitoinspections1 {
		fsMosquitoinspections1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSMosquitoinspections.Insert(bob.ToMods(fsMosquitoinspections1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSMosquitoinspections0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSMosquitoinspections0(ctx context.Context, exec bob.Executor, count int, fsMosquitoinspections1 FSMosquitoinspectionSlice, organization0 *Organization) (FSMosquitoinspectionSlice, error) {
	setter := &FSMosquitoinspectionSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsMosquitoinspections1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSMosquitoinspections0: %w", err)
	}

	return fsMosquitoinspections1, nil
}

func (organization0 *Organization) InsertFSMosquitoinspections(ctx context.Context, exec bob.Executor, related ...*FSMosquitoinspectionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsMosquitoinspections1, err := insertOrganizationFSMosquitoinspections0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSMosquitoinspections = append(organization0.R.FSMosquitoinspections, fsMosquitoinspections1...)

	for _, rel := range fsMosquitoinspections1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSMosquitoinspections(ctx context.Context, exec bob.Executor, related ...*FSMosquitoinspection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsMosquitoinspections1 := FSMosquitoinspectionSlice(related)

	_, err = attachOrganizationFSMosquitoinspections0(ctx, exec, len(related), fsMosquitoinspections1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSMosquitoinspections = append(organization0.R.FSMosquitoinspections, fsMosquitoinspections1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSPointlocations0(ctx context.Context, exec bob.Executor, fsPointlocations1 []*FSPointlocationSetter, organization0 *Organization) (FSPointlocationSlice, error) {
	for i := range fsPointlocations1 {
		fsPointlocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSPointlocations.Insert(bob.ToMods(fsPointlocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSPointlocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSPointlocations0(ctx context.Context, exec bob.Executor, count int, fsPointlocations1 FSPointlocationSlice, organization0 *Organization) (FSPointlocationSlice, error) {
	setter := &FSPointlocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsPointlocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSPointlocations0: %w", err)
	}

	return fsPointlocations1, nil
}

func (organization0 *Organization) InsertFSPointlocations(ctx context.Context, exec bob.Executor, related ...*FSPointlocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsPointlocations1, err := insertOrganizationFSPointlocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSPointlocations = append(organization0.R.FSPointlocations, fsPointlocations1...)

	for _, rel := range fsPointlocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSPointlocations(ctx context.Context, exec bob.Executor, related ...*FSPointlocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsPointlocations1 := FSPointlocationSlice(related)

	_, err = attachOrganizationFSPointlocations0(ctx, exec, len(related), fsPointlocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSPointlocations = append(organization0.R.FSPointlocations, fsPointlocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSPolygonlocations0(ctx context.Context, exec bob.Executor, fsPolygonlocations1 []*FSPolygonlocationSetter, organization0 *Organization) (FSPolygonlocationSlice, error) {
	for i := range fsPolygonlocations1 {
		fsPolygonlocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSPolygonlocations.Insert(bob.ToMods(fsPolygonlocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSPolygonlocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSPolygonlocations0(ctx context.Context, exec bob.Executor, count int, fsPolygonlocations1 FSPolygonlocationSlice, organization0 *Organization) (FSPolygonlocationSlice, error) {
	setter := &FSPolygonlocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsPolygonlocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSPolygonlocations0: %w", err)
	}

	return fsPolygonlocations1, nil
}

func (organization0 *Organization) InsertFSPolygonlocations(ctx context.Context, exec bob.Executor, related ...*FSPolygonlocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsPolygonlocations1, err := insertOrganizationFSPolygonlocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSPolygonlocations = append(organization0.R.FSPolygonlocations, fsPolygonlocations1...)

	for _, rel := range fsPolygonlocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSPolygonlocations(ctx context.Context, exec bob.Executor, related ...*FSPolygonlocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsPolygonlocations1 := FSPolygonlocationSlice(related)

	_, err = attachOrganizationFSPolygonlocations0(ctx, exec, len(related), fsPolygonlocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSPolygonlocations = append(organization0.R.FSPolygonlocations, fsPolygonlocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSPools0(ctx context.Context, exec bob.Executor, fsPools1 []*FSPoolSetter, organization0 *Organization) (FSPoolSlice, error) {
	for i := range fsPools1 {
		fsPools1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSPools.Insert(bob.ToMods(fsPools1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSPools0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSPools0(ctx context.Context, exec bob.Executor, count int, fsPools1 FSPoolSlice, organization0 *Organization) (FSPoolSlice, error) {
	setter := &FSPoolSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsPools1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSPools0: %w", err)
	}

	return fsPools1, nil
}

func (organization0 *Organization) InsertFSPools(ctx context.Context, exec bob.Executor, related ...*FSPoolSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsPools1, err := insertOrganizationFSPools0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSPools = append(organization0.R.FSPools, fsPools1...)

	for _, rel := range fsPools1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSPools(ctx context.Context, exec bob.Executor, related ...*FSPool) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsPools1 := FSPoolSlice(related)

	_, err = attachOrganizationFSPools0(ctx, exec, len(related), fsPools1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSPools = append(organization0.R.FSPools, fsPools1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSPooldetails0(ctx context.Context, exec bob.Executor, fsPooldetails1 []*FSPooldetailSetter, organization0 *Organization) (FSPooldetailSlice, error) {
	for i := range fsPooldetails1 {
		fsPooldetails1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSPooldetails.Insert(bob.ToMods(fsPooldetails1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSPooldetails0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSPooldetails0(ctx context.Context, exec bob.Executor, count int, fsPooldetails1 FSPooldetailSlice, organization0 *Organization) (FSPooldetailSlice, error) {
	setter := &FSPooldetailSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsPooldetails1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSPooldetails0: %w", err)
	}

	return fsPooldetails1, nil
}

func (organization0 *Organization) InsertFSPooldetails(ctx context.Context, exec bob.Executor, related ...*FSPooldetailSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsPooldetails1, err := insertOrganizationFSPooldetails0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSPooldetails = append(organization0.R.FSPooldetails, fsPooldetails1...)

	for _, rel := range fsPooldetails1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSPooldetails(ctx context.Context, exec bob.Executor, related ...*FSPooldetail) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsPooldetails1 := FSPooldetailSlice(related)

	_, err = attachOrganizationFSPooldetails0(ctx, exec, len(related), fsPooldetails1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSPooldetails = append(organization0.R.FSPooldetails, fsPooldetails1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSProposedtreatmentareas0(ctx context.Context, exec bob.Executor, fsProposedtreatmentareas1 []*FSProposedtreatmentareaSetter, organization0 *Organization) (FSProposedtreatmentareaSlice, error) {
	for i := range fsProposedtreatmentareas1 {
		fsProposedtreatmentareas1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSProposedtreatmentareas.Insert(bob.ToMods(fsProposedtreatmentareas1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSProposedtreatmentareas0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSProposedtreatmentareas0(ctx context.Context, exec bob.Executor, count int, fsProposedtreatmentareas1 FSProposedtreatmentareaSlice, organization0 *Organization) (FSProposedtreatmentareaSlice, error) {
	setter := &FSProposedtreatmentareaSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsProposedtreatmentareas1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSProposedtreatmentareas0: %w", err)
	}

	return fsProposedtreatmentareas1, nil
}

func (organization0 *Organization) InsertFSProposedtreatmentareas(ctx context.Context, exec bob.Executor, related ...*FSProposedtreatmentareaSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsProposedtreatmentareas1, err := insertOrganizationFSProposedtreatmentareas0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSProposedtreatmentareas = append(organization0.R.FSProposedtreatmentareas, fsProposedtreatmentareas1...)

	for _, rel := range fsProposedtreatmentareas1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSProposedtreatmentareas(ctx context.Context, exec bob.Executor, related ...*FSProposedtreatmentarea) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsProposedtreatmentareas1 := FSProposedtreatmentareaSlice(related)

	_, err = attachOrganizationFSProposedtreatmentareas0(ctx, exec, len(related), fsProposedtreatmentareas1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSProposedtreatmentareas = append(organization0.R.FSProposedtreatmentareas, fsProposedtreatmentareas1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSQamosquitoinspections0(ctx context.Context, exec bob.Executor, fsQamosquitoinspections1 []*FSQamosquitoinspectionSetter, organization0 *Organization) (FSQamosquitoinspectionSlice, error) {
	for i := range fsQamosquitoinspections1 {
		fsQamosquitoinspections1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSQamosquitoinspections.Insert(bob.ToMods(fsQamosquitoinspections1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSQamosquitoinspections0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSQamosquitoinspections0(ctx context.Context, exec bob.Executor, count int, fsQamosquitoinspections1 FSQamosquitoinspectionSlice, organization0 *Organization) (FSQamosquitoinspectionSlice, error) {
	setter := &FSQamosquitoinspectionSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsQamosquitoinspections1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSQamosquitoinspections0: %w", err)
	}

	return fsQamosquitoinspections1, nil
}

func (organization0 *Organization) InsertFSQamosquitoinspections(ctx context.Context, exec bob.Executor, related ...*FSQamosquitoinspectionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsQamosquitoinspections1, err := insertOrganizationFSQamosquitoinspections0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSQamosquitoinspections = append(organization0.R.FSQamosquitoinspections, fsQamosquitoinspections1...)

	for _, rel := range fsQamosquitoinspections1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSQamosquitoinspections(ctx context.Context, exec bob.Executor, related ...*FSQamosquitoinspection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsQamosquitoinspections1 := FSQamosquitoinspectionSlice(related)

	_, err = attachOrganizationFSQamosquitoinspections0(ctx, exec, len(related), fsQamosquitoinspections1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSQamosquitoinspections = append(organization0.R.FSQamosquitoinspections, fsQamosquitoinspections1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSRodentlocations0(ctx context.Context, exec bob.Executor, fsRodentlocations1 []*FSRodentlocationSetter, organization0 *Organization) (FSRodentlocationSlice, error) {
	for i := range fsRodentlocations1 {
		fsRodentlocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSRodentlocations.Insert(bob.ToMods(fsRodentlocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSRodentlocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSRodentlocations0(ctx context.Context, exec bob.Executor, count int, fsRodentlocations1 FSRodentlocationSlice, organization0 *Organization) (FSRodentlocationSlice, error) {
	setter := &FSRodentlocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsRodentlocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSRodentlocations0: %w", err)
	}

	return fsRodentlocations1, nil
}

func (organization0 *Organization) InsertFSRodentlocations(ctx context.Context, exec bob.Executor, related ...*FSRodentlocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsRodentlocations1, err := insertOrganizationFSRodentlocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSRodentlocations = append(organization0.R.FSRodentlocations, fsRodentlocations1...)

	for _, rel := range fsRodentlocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSRodentlocations(ctx context.Context, exec bob.Executor, related ...*FSRodentlocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsRodentlocations1 := FSRodentlocationSlice(related)

	_, err = attachOrganizationFSRodentlocations0(ctx, exec, len(related), fsRodentlocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSRodentlocations = append(organization0.R.FSRodentlocations, fsRodentlocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSSamplecollections0(ctx context.Context, exec bob.Executor, fsSamplecollections1 []*FSSamplecollectionSetter, organization0 *Organization) (FSSamplecollectionSlice, error) {
	for i := range fsSamplecollections1 {
		fsSamplecollections1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSSamplecollections.Insert(bob.ToMods(fsSamplecollections1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSSamplecollections0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSSamplecollections0(ctx context.Context, exec bob.Executor, count int, fsSamplecollections1 FSSamplecollectionSlice, organization0 *Organization) (FSSamplecollectionSlice, error) {
	setter := &FSSamplecollectionSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsSamplecollections1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSSamplecollections0: %w", err)
	}

	return fsSamplecollections1, nil
}

func (organization0 *Organization) InsertFSSamplecollections(ctx context.Context, exec bob.Executor, related ...*FSSamplecollectionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsSamplecollections1, err := insertOrganizationFSSamplecollections0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSSamplecollections = append(organization0.R.FSSamplecollections, fsSamplecollections1...)

	for _, rel := range fsSamplecollections1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSSamplecollections(ctx context.Context, exec bob.Executor, related ...*FSSamplecollection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsSamplecollections1 := FSSamplecollectionSlice(related)

	_, err = attachOrganizationFSSamplecollections0(ctx, exec, len(related), fsSamplecollections1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSSamplecollections = append(organization0.R.FSSamplecollections, fsSamplecollections1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSSamplelocations0(ctx context.Context, exec bob.Executor, fsSamplelocations1 []*FSSamplelocationSetter, organization0 *Organization) (FSSamplelocationSlice, error) {
	for i := range fsSamplelocations1 {
		fsSamplelocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSSamplelocations.Insert(bob.ToMods(fsSamplelocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSSamplelocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSSamplelocations0(ctx context.Context, exec bob.Executor, count int, fsSamplelocations1 FSSamplelocationSlice, organization0 *Organization) (FSSamplelocationSlice, error) {
	setter := &FSSamplelocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsSamplelocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSSamplelocations0: %w", err)
	}

	return fsSamplelocations1, nil
}

func (organization0 *Organization) InsertFSSamplelocations(ctx context.Context, exec bob.Executor, related ...*FSSamplelocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsSamplelocations1, err := insertOrganizationFSSamplelocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSSamplelocations = append(organization0.R.FSSamplelocations, fsSamplelocations1...)

	for _, rel := range fsSamplelocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSSamplelocations(ctx context.Context, exec bob.Executor, related ...*FSSamplelocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsSamplelocations1 := FSSamplelocationSlice(related)

	_, err = attachOrganizationFSSamplelocations0(ctx, exec, len(related), fsSamplelocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSSamplelocations = append(organization0.R.FSSamplelocations, fsSamplelocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSServicerequests0(ctx context.Context, exec bob.Executor, fsServicerequests1 []*FSServicerequestSetter, organization0 *Organization) (FSServicerequestSlice, error) {
	for i := range fsServicerequests1 {
		fsServicerequests1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSServicerequests.Insert(bob.ToMods(fsServicerequests1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSServicerequests0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSServicerequests0(ctx context.Context, exec bob.Executor, count int, fsServicerequests1 FSServicerequestSlice, organization0 *Organization) (FSServicerequestSlice, error) {
	setter := &FSServicerequestSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsServicerequests1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSServicerequests0: %w", err)
	}

	return fsServicerequests1, nil
}

func (organization0 *Organization) InsertFSServicerequests(ctx context.Context, exec bob.Executor, related ...*FSServicerequestSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsServicerequests1, err := insertOrganizationFSServicerequests0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSServicerequests = append(organization0.R.FSServicerequests, fsServicerequests1...)

	for _, rel := range fsServicerequests1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSServicerequests(ctx context.Context, exec bob.Executor, related ...*FSServicerequest) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsServicerequests1 := FSServicerequestSlice(related)

	_, err = attachOrganizationFSServicerequests0(ctx, exec, len(related), fsServicerequests1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSServicerequests = append(organization0.R.FSServicerequests, fsServicerequests1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSSpeciesabundances0(ctx context.Context, exec bob.Executor, fsSpeciesabundances1 []*FSSpeciesabundanceSetter, organization0 *Organization) (FSSpeciesabundanceSlice, error) {
	for i := range fsSpeciesabundances1 {
		fsSpeciesabundances1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSSpeciesabundances.Insert(bob.ToMods(fsSpeciesabundances1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSSpeciesabundances0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSSpeciesabundances0(ctx context.Context, exec bob.Executor, count int, fsSpeciesabundances1 FSSpeciesabundanceSlice, organization0 *Organization) (FSSpeciesabundanceSlice, error) {
	setter := &FSSpeciesabundanceSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsSpeciesabundances1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSSpeciesabundances0: %w", err)
	}

	return fsSpeciesabundances1, nil
}

func (organization0 *Organization) InsertFSSpeciesabundances(ctx context.Context, exec bob.Executor, related ...*FSSpeciesabundanceSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsSpeciesabundances1, err := insertOrganizationFSSpeciesabundances0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSSpeciesabundances = append(organization0.R.FSSpeciesabundances, fsSpeciesabundances1...)

	for _, rel := range fsSpeciesabundances1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSSpeciesabundances(ctx context.Context, exec bob.Executor, related ...*FSSpeciesabundance) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsSpeciesabundances1 := FSSpeciesabundanceSlice(related)

	_, err = attachOrganizationFSSpeciesabundances0(ctx, exec, len(related), fsSpeciesabundances1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSSpeciesabundances = append(organization0.R.FSSpeciesabundances, fsSpeciesabundances1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSStormdrains0(ctx context.Context, exec bob.Executor, fsStormdrains1 []*FSStormdrainSetter, organization0 *Organization) (FSStormdrainSlice, error) {
	for i := range fsStormdrains1 {
		fsStormdrains1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSStormdrains.Insert(bob.ToMods(fsStormdrains1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSStormdrains0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSStormdrains0(ctx context.Context, exec bob.Executor, count int, fsStormdrains1 FSStormdrainSlice, organization0 *Organization) (FSStormdrainSlice, error) {
	setter := &FSStormdrainSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsStormdrains1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSStormdrains0: %w", err)
	}

	return fsStormdrains1, nil
}

func (organization0 *Organization) InsertFSStormdrains(ctx context.Context, exec bob.Executor, related ...*FSStormdrainSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsStormdrains1, err := insertOrganizationFSStormdrains0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSStormdrains = append(organization0.R.FSStormdrains, fsStormdrains1...)

	for _, rel := range fsStormdrains1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSStormdrains(ctx context.Context, exec bob.Executor, related ...*FSStormdrain) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsStormdrains1 := FSStormdrainSlice(related)

	_, err = attachOrganizationFSStormdrains0(ctx, exec, len(related), fsStormdrains1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSStormdrains = append(organization0.R.FSStormdrains, fsStormdrains1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSTimecards0(ctx context.Context, exec bob.Executor, fsTimecards1 []*FSTimecardSetter, organization0 *Organization) (FSTimecardSlice, error) {
	for i := range fsTimecards1 {
		fsTimecards1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSTimecards.Insert(bob.ToMods(fsTimecards1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSTimecards0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSTimecards0(ctx context.Context, exec bob.Executor, count int, fsTimecards1 FSTimecardSlice, organization0 *Organization) (FSTimecardSlice, error) {
	setter := &FSTimecardSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsTimecards1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSTimecards0: %w", err)
	}

	return fsTimecards1, nil
}

func (organization0 *Organization) InsertFSTimecards(ctx context.Context, exec bob.Executor, related ...*FSTimecardSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsTimecards1, err := insertOrganizationFSTimecards0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTimecards = append(organization0.R.FSTimecards, fsTimecards1...)

	for _, rel := range fsTimecards1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSTimecards(ctx context.Context, exec bob.Executor, related ...*FSTimecard) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsTimecards1 := FSTimecardSlice(related)

	_, err = attachOrganizationFSTimecards0(ctx, exec, len(related), fsTimecards1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTimecards = append(organization0.R.FSTimecards, fsTimecards1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSTrapdata0(ctx context.Context, exec bob.Executor, fsTrapdata1 []*FSTrapdatumSetter, organization0 *Organization) (FSTrapdatumSlice, error) {
	for i := range fsTrapdata1 {
		fsTrapdata1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSTrapdata.Insert(bob.ToMods(fsTrapdata1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSTrapdata0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSTrapdata0(ctx context.Context, exec bob.Executor, count int, fsTrapdata1 FSTrapdatumSlice, organization0 *Organization) (FSTrapdatumSlice, error) {
	setter := &FSTrapdatumSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsTrapdata1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSTrapdata0: %w", err)
	}

	return fsTrapdata1, nil
}

func (organization0 *Organization) InsertFSTrapdata(ctx context.Context, exec bob.Executor, related ...*FSTrapdatumSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsTrapdata1, err := insertOrganizationFSTrapdata0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTrapdata = append(organization0.R.FSTrapdata, fsTrapdata1...)

	for _, rel := range fsTrapdata1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSTrapdata(ctx context.Context, exec bob.Executor, related ...*FSTrapdatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsTrapdata1 := FSTrapdatumSlice(related)

	_, err = attachOrganizationFSTrapdata0(ctx, exec, len(related), fsTrapdata1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTrapdata = append(organization0.R.FSTrapdata, fsTrapdata1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSTraplocations0(ctx context.Context, exec bob.Executor, fsTraplocations1 []*FSTraplocationSetter, organization0 *Organization) (FSTraplocationSlice, error) {
	for i := range fsTraplocations1 {
		fsTraplocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSTraplocations.Insert(bob.ToMods(fsTraplocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSTraplocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSTraplocations0(ctx context.Context, exec bob.Executor, count int, fsTraplocations1 FSTraplocationSlice, organization0 *Organization) (FSTraplocationSlice, error) {
	setter := &FSTraplocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsTraplocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSTraplocations0: %w", err)
	}

	return fsTraplocations1, nil
}

func (organization0 *Organization) InsertFSTraplocations(ctx context.Context, exec bob.Executor, related ...*FSTraplocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsTraplocations1, err := insertOrganizationFSTraplocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTraplocations = append(organization0.R.FSTraplocations, fsTraplocations1...)

	for _, rel := range fsTraplocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSTraplocations(ctx context.Context, exec bob.Executor, related ...*FSTraplocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsTraplocations1 := FSTraplocationSlice(related)

	_, err = attachOrganizationFSTraplocations0(ctx, exec, len(related), fsTraplocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTraplocations = append(organization0.R.FSTraplocations, fsTraplocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSTreatments0(ctx context.Context, exec bob.Executor, fsTreatments1 []*FSTreatmentSetter, organization0 *Organization) (FSTreatmentSlice, error) {
	for i := range fsTreatments1 {
		fsTreatments1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSTreatments.Insert(bob.ToMods(fsTreatments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSTreatments0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSTreatments0(ctx context.Context, exec bob.Executor, count int, fsTreatments1 FSTreatmentSlice, organization0 *Organization) (FSTreatmentSlice, error) {
	setter := &FSTreatmentSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsTreatments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSTreatments0: %w", err)
	}

	return fsTreatments1, nil
}

func (organization0 *Organization) InsertFSTreatments(ctx context.Context, exec bob.Executor, related ...*FSTreatmentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsTreatments1, err := insertOrganizationFSTreatments0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTreatments = append(organization0.R.FSTreatments, fsTreatments1...)

	for _, rel := range fsTreatments1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSTreatments(ctx context.Context, exec bob.Executor, related ...*FSTreatment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsTreatments1 := FSTreatmentSlice(related)

	_, err = attachOrganizationFSTreatments0(ctx, exec, len(related), fsTreatments1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTreatments = append(organization0.R.FSTreatments, fsTreatments1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSTreatmentareas0(ctx context.Context, exec bob.Executor, fsTreatmentareas1 []*FSTreatmentareaSetter, organization0 *Organization) (FSTreatmentareaSlice, error) {
	for i := range fsTreatmentareas1 {
		fsTreatmentareas1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSTreatmentareas.Insert(bob.ToMods(fsTreatmentareas1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSTreatmentareas0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSTreatmentareas0(ctx context.Context, exec bob.Executor, count int, fsTreatmentareas1 FSTreatmentareaSlice, organization0 *Organization) (FSTreatmentareaSlice, error) {
	setter := &FSTreatmentareaSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsTreatmentareas1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSTreatmentareas0: %w", err)
	}

	return fsTreatmentareas1, nil
}

func (organization0 *Organization) InsertFSTreatmentareas(ctx context.Context, exec bob.Executor, related ...*FSTreatmentareaSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsTreatmentareas1, err := insertOrganizationFSTreatmentareas0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTreatmentareas = append(organization0.R.FSTreatmentareas, fsTreatmentareas1...)

	for _, rel := range fsTreatmentareas1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSTreatmentareas(ctx context.Context, exec bob.Executor, related ...*FSTreatmentarea) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsTreatmentareas1 := FSTreatmentareaSlice(related)

	_, err = attachOrganizationFSTreatmentareas0(ctx, exec, len(related), fsTreatmentareas1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSTreatmentareas = append(organization0.R.FSTreatmentareas, fsTreatmentareas1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSZones0(ctx context.Context, exec bob.Executor, fsZones1 []*FSZoneSetter, organization0 *Organization) (FSZoneSlice, error) {
	for i := range fsZones1 {
		fsZones1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSZones.Insert(bob.ToMods(fsZones1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSZones0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSZones0(ctx context.Context, exec bob.Executor, count int, fsZones1 FSZoneSlice, organization0 *Organization) (FSZoneSlice, error) {
	setter := &FSZoneSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsZones1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSZones0: %w", err)
	}

	return fsZones1, nil
}

func (organization0 *Organization) InsertFSZones(ctx context.Context, exec bob.Executor, related ...*FSZoneSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsZones1, err := insertOrganizationFSZones0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSZones = append(organization0.R.FSZones, fsZones1...)

	for _, rel := range fsZones1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSZones(ctx context.Context, exec bob.Executor, related ...*FSZone) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsZones1 := FSZoneSlice(related)

	_, err = attachOrganizationFSZones0(ctx, exec, len(related), fsZones1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSZones = append(organization0.R.FSZones, fsZones1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationFSZones2s0(ctx context.Context, exec bob.Executor, fsZones2s1 []*FSZones2Setter, organization0 *Organization) (FSZones2Slice, error) {
	for i := range fsZones2s1 {
		fsZones2s1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := FSZones2s.Insert(bob.ToMods(fsZones2s1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationFSZones2s0: %w", err)
	}

	return ret, nil
}

func attachOrganizationFSZones2s0(ctx context.Context, exec bob.Executor, count int, fsZones2s1 FSZones2Slice, organization0 *Organization) (FSZones2Slice, error) {
	setter := &FSZones2Setter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := fsZones2s1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationFSZones2s0: %w", err)
	}

	return fsZones2s1, nil
}

func (organization0 *Organization) InsertFSZones2s(ctx context.Context, exec bob.Executor, related ...*FSZones2Setter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	fsZones2s1, err := insertOrganizationFSZones2s0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSZones2s = append(organization0.R.FSZones2s, fsZones2s1...)

	for _, rel := range fsZones2s1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachFSZones2s(ctx context.Context, exec bob.Executor, related ...*FSZones2) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	fsZones2s1 := FSZones2Slice(related)

	_, err = attachOrganizationFSZones2s0(ctx, exec, len(related), fsZones2s1, organization0)
	if err != nil {
		return err
	}

	organization0.R.FSZones2s = append(organization0.R.FSZones2s, fsZones2s1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryContainerrelates0(ctx context.Context, exec bob.Executor, historyContainerrelates1 []*HistoryContainerrelateSetter, organization0 *Organization) (HistoryContainerrelateSlice, error) {
	for i := range historyContainerrelates1 {
		historyContainerrelates1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryContainerrelates.Insert(bob.ToMods(historyContainerrelates1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryContainerrelates0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryContainerrelates0(ctx context.Context, exec bob.Executor, count int, historyContainerrelates1 HistoryContainerrelateSlice, organization0 *Organization) (HistoryContainerrelateSlice, error) {
	setter := &HistoryContainerrelateSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyContainerrelates1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryContainerrelates0: %w", err)
	}

	return historyContainerrelates1, nil
}

func (organization0 *Organization) InsertHistoryContainerrelates(ctx context.Context, exec bob.Executor, related ...*HistoryContainerrelateSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyContainerrelates1, err := insertOrganizationHistoryContainerrelates0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryContainerrelates = append(organization0.R.HistoryContainerrelates, historyContainerrelates1...)

	for _, rel := range historyContainerrelates1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryContainerrelates(ctx context.Context, exec bob.Executor, related ...*HistoryContainerrelate) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyContainerrelates1 := HistoryContainerrelateSlice(related)

	_, err = attachOrganizationHistoryContainerrelates0(ctx, exec, len(related), historyContainerrelates1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryContainerrelates = append(organization0.R.HistoryContainerrelates, historyContainerrelates1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryFieldscoutinglogs0(ctx context.Context, exec bob.Executor, historyFieldscoutinglogs1 []*HistoryFieldscoutinglogSetter, organization0 *Organization) (HistoryFieldscoutinglogSlice, error) {
	for i := range historyFieldscoutinglogs1 {
		historyFieldscoutinglogs1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryFieldscoutinglogs.Insert(bob.ToMods(historyFieldscoutinglogs1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryFieldscoutinglogs0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryFieldscoutinglogs0(ctx context.Context, exec bob.Executor, count int, historyFieldscoutinglogs1 HistoryFieldscoutinglogSlice, organization0 *Organization) (HistoryFieldscoutinglogSlice, error) {
	setter := &HistoryFieldscoutinglogSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyFieldscoutinglogs1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryFieldscoutinglogs0: %w", err)
	}

	return historyFieldscoutinglogs1, nil
}

func (organization0 *Organization) InsertHistoryFieldscoutinglogs(ctx context.Context, exec bob.Executor, related ...*HistoryFieldscoutinglogSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyFieldscoutinglogs1, err := insertOrganizationHistoryFieldscoutinglogs0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryFieldscoutinglogs = append(organization0.R.HistoryFieldscoutinglogs, historyFieldscoutinglogs1...)

	for _, rel := range historyFieldscoutinglogs1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryFieldscoutinglogs(ctx context.Context, exec bob.Executor, related ...*HistoryFieldscoutinglog) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyFieldscoutinglogs1 := HistoryFieldscoutinglogSlice(related)

	_, err = attachOrganizationHistoryFieldscoutinglogs0(ctx, exec, len(related), historyFieldscoutinglogs1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryFieldscoutinglogs = append(organization0.R.HistoryFieldscoutinglogs, historyFieldscoutinglogs1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryHabitatrelates0(ctx context.Context, exec bob.Executor, historyHabitatrelates1 []*HistoryHabitatrelateSetter, organization0 *Organization) (HistoryHabitatrelateSlice, error) {
	for i := range historyHabitatrelates1 {
		historyHabitatrelates1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryHabitatrelates.Insert(bob.ToMods(historyHabitatrelates1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryHabitatrelates0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryHabitatrelates0(ctx context.Context, exec bob.Executor, count int, historyHabitatrelates1 HistoryHabitatrelateSlice, organization0 *Organization) (HistoryHabitatrelateSlice, error) {
	setter := &HistoryHabitatrelateSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyHabitatrelates1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryHabitatrelates0: %w", err)
	}

	return historyHabitatrelates1, nil
}

func (organization0 *Organization) InsertHistoryHabitatrelates(ctx context.Context, exec bob.Executor, related ...*HistoryHabitatrelateSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyHabitatrelates1, err := insertOrganizationHistoryHabitatrelates0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryHabitatrelates = append(organization0.R.HistoryHabitatrelates, historyHabitatrelates1...)

	for _, rel := range historyHabitatrelates1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryHabitatrelates(ctx context.Context, exec bob.Executor, related ...*HistoryHabitatrelate) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyHabitatrelates1 := HistoryHabitatrelateSlice(related)

	_, err = attachOrganizationHistoryHabitatrelates0(ctx, exec, len(related), historyHabitatrelates1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryHabitatrelates = append(organization0.R.HistoryHabitatrelates, historyHabitatrelates1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryInspectionsamples0(ctx context.Context, exec bob.Executor, historyInspectionsamples1 []*HistoryInspectionsampleSetter, organization0 *Organization) (HistoryInspectionsampleSlice, error) {
	for i := range historyInspectionsamples1 {
		historyInspectionsamples1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryInspectionsamples.Insert(bob.ToMods(historyInspectionsamples1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryInspectionsamples0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryInspectionsamples0(ctx context.Context, exec bob.Executor, count int, historyInspectionsamples1 HistoryInspectionsampleSlice, organization0 *Organization) (HistoryInspectionsampleSlice, error) {
	setter := &HistoryInspectionsampleSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyInspectionsamples1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryInspectionsamples0: %w", err)
	}

	return historyInspectionsamples1, nil
}

func (organization0 *Organization) InsertHistoryInspectionsamples(ctx context.Context, exec bob.Executor, related ...*HistoryInspectionsampleSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyInspectionsamples1, err := insertOrganizationHistoryInspectionsamples0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryInspectionsamples = append(organization0.R.HistoryInspectionsamples, historyInspectionsamples1...)

	for _, rel := range historyInspectionsamples1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryInspectionsamples(ctx context.Context, exec bob.Executor, related ...*HistoryInspectionsample) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyInspectionsamples1 := HistoryInspectionsampleSlice(related)

	_, err = attachOrganizationHistoryInspectionsamples0(ctx, exec, len(related), historyInspectionsamples1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryInspectionsamples = append(organization0.R.HistoryInspectionsamples, historyInspectionsamples1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryInspectionsampledetails0(ctx context.Context, exec bob.Executor, historyInspectionsampledetails1 []*HistoryInspectionsampledetailSetter, organization0 *Organization) (HistoryInspectionsampledetailSlice, error) {
	for i := range historyInspectionsampledetails1 {
		historyInspectionsampledetails1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryInspectionsampledetails.Insert(bob.ToMods(historyInspectionsampledetails1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryInspectionsampledetails0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryInspectionsampledetails0(ctx context.Context, exec bob.Executor, count int, historyInspectionsampledetails1 HistoryInspectionsampledetailSlice, organization0 *Organization) (HistoryInspectionsampledetailSlice, error) {
	setter := &HistoryInspectionsampledetailSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyInspectionsampledetails1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryInspectionsampledetails0: %w", err)
	}

	return historyInspectionsampledetails1, nil
}

func (organization0 *Organization) InsertHistoryInspectionsampledetails(ctx context.Context, exec bob.Executor, related ...*HistoryInspectionsampledetailSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyInspectionsampledetails1, err := insertOrganizationHistoryInspectionsampledetails0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryInspectionsampledetails = append(organization0.R.HistoryInspectionsampledetails, historyInspectionsampledetails1...)

	for _, rel := range historyInspectionsampledetails1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryInspectionsampledetails(ctx context.Context, exec bob.Executor, related ...*HistoryInspectionsampledetail) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyInspectionsampledetails1 := HistoryInspectionsampledetailSlice(related)

	_, err = attachOrganizationHistoryInspectionsampledetails0(ctx, exec, len(related), historyInspectionsampledetails1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryInspectionsampledetails = append(organization0.R.HistoryInspectionsampledetails, historyInspectionsampledetails1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryLinelocations0(ctx context.Context, exec bob.Executor, historyLinelocations1 []*HistoryLinelocationSetter, organization0 *Organization) (HistoryLinelocationSlice, error) {
	for i := range historyLinelocations1 {
		historyLinelocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryLinelocations.Insert(bob.ToMods(historyLinelocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryLinelocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryLinelocations0(ctx context.Context, exec bob.Executor, count int, historyLinelocations1 HistoryLinelocationSlice, organization0 *Organization) (HistoryLinelocationSlice, error) {
	setter := &HistoryLinelocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyLinelocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryLinelocations0: %w", err)
	}

	return historyLinelocations1, nil
}

func (organization0 *Organization) InsertHistoryLinelocations(ctx context.Context, exec bob.Executor, related ...*HistoryLinelocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyLinelocations1, err := insertOrganizationHistoryLinelocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryLinelocations = append(organization0.R.HistoryLinelocations, historyLinelocations1...)

	for _, rel := range historyLinelocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryLinelocations(ctx context.Context, exec bob.Executor, related ...*HistoryLinelocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyLinelocations1 := HistoryLinelocationSlice(related)

	_, err = attachOrganizationHistoryLinelocations0(ctx, exec, len(related), historyLinelocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryLinelocations = append(organization0.R.HistoryLinelocations, historyLinelocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryLocationtrackings0(ctx context.Context, exec bob.Executor, historyLocationtrackings1 []*HistoryLocationtrackingSetter, organization0 *Organization) (HistoryLocationtrackingSlice, error) {
	for i := range historyLocationtrackings1 {
		historyLocationtrackings1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryLocationtrackings.Insert(bob.ToMods(historyLocationtrackings1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryLocationtrackings0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryLocationtrackings0(ctx context.Context, exec bob.Executor, count int, historyLocationtrackings1 HistoryLocationtrackingSlice, organization0 *Organization) (HistoryLocationtrackingSlice, error) {
	setter := &HistoryLocationtrackingSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyLocationtrackings1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryLocationtrackings0: %w", err)
	}

	return historyLocationtrackings1, nil
}

func (organization0 *Organization) InsertHistoryLocationtrackings(ctx context.Context, exec bob.Executor, related ...*HistoryLocationtrackingSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyLocationtrackings1, err := insertOrganizationHistoryLocationtrackings0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryLocationtrackings = append(organization0.R.HistoryLocationtrackings, historyLocationtrackings1...)

	for _, rel := range historyLocationtrackings1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryLocationtrackings(ctx context.Context, exec bob.Executor, related ...*HistoryLocationtracking) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyLocationtrackings1 := HistoryLocationtrackingSlice(related)

	_, err = attachOrganizationHistoryLocationtrackings0(ctx, exec, len(related), historyLocationtrackings1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryLocationtrackings = append(organization0.R.HistoryLocationtrackings, historyLocationtrackings1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryMosquitoinspections0(ctx context.Context, exec bob.Executor, historyMosquitoinspections1 []*HistoryMosquitoinspectionSetter, organization0 *Organization) (HistoryMosquitoinspectionSlice, error) {
	for i := range historyMosquitoinspections1 {
		historyMosquitoinspections1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryMosquitoinspections.Insert(bob.ToMods(historyMosquitoinspections1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryMosquitoinspections0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryMosquitoinspections0(ctx context.Context, exec bob.Executor, count int, historyMosquitoinspections1 HistoryMosquitoinspectionSlice, organization0 *Organization) (HistoryMosquitoinspectionSlice, error) {
	setter := &HistoryMosquitoinspectionSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyMosquitoinspections1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryMosquitoinspections0: %w", err)
	}

	return historyMosquitoinspections1, nil
}

func (organization0 *Organization) InsertHistoryMosquitoinspections(ctx context.Context, exec bob.Executor, related ...*HistoryMosquitoinspectionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyMosquitoinspections1, err := insertOrganizationHistoryMosquitoinspections0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryMosquitoinspections = append(organization0.R.HistoryMosquitoinspections, historyMosquitoinspections1...)

	for _, rel := range historyMosquitoinspections1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryMosquitoinspections(ctx context.Context, exec bob.Executor, related ...*HistoryMosquitoinspection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyMosquitoinspections1 := HistoryMosquitoinspectionSlice(related)

	_, err = attachOrganizationHistoryMosquitoinspections0(ctx, exec, len(related), historyMosquitoinspections1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryMosquitoinspections = append(organization0.R.HistoryMosquitoinspections, historyMosquitoinspections1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryPointlocations0(ctx context.Context, exec bob.Executor, historyPointlocations1 []*HistoryPointlocationSetter, organization0 *Organization) (HistoryPointlocationSlice, error) {
	for i := range historyPointlocations1 {
		historyPointlocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryPointlocations.Insert(bob.ToMods(historyPointlocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryPointlocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryPointlocations0(ctx context.Context, exec bob.Executor, count int, historyPointlocations1 HistoryPointlocationSlice, organization0 *Organization) (HistoryPointlocationSlice, error) {
	setter := &HistoryPointlocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyPointlocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryPointlocations0: %w", err)
	}

	return historyPointlocations1, nil
}

func (organization0 *Organization) InsertHistoryPointlocations(ctx context.Context, exec bob.Executor, related ...*HistoryPointlocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyPointlocations1, err := insertOrganizationHistoryPointlocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryPointlocations = append(organization0.R.HistoryPointlocations, historyPointlocations1...)

	for _, rel := range historyPointlocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryPointlocations(ctx context.Context, exec bob.Executor, related ...*HistoryPointlocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyPointlocations1 := HistoryPointlocationSlice(related)

	_, err = attachOrganizationHistoryPointlocations0(ctx, exec, len(related), historyPointlocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryPointlocations = append(organization0.R.HistoryPointlocations, historyPointlocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryPolygonlocations0(ctx context.Context, exec bob.Executor, historyPolygonlocations1 []*HistoryPolygonlocationSetter, organization0 *Organization) (HistoryPolygonlocationSlice, error) {
	for i := range historyPolygonlocations1 {
		historyPolygonlocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryPolygonlocations.Insert(bob.ToMods(historyPolygonlocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryPolygonlocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryPolygonlocations0(ctx context.Context, exec bob.Executor, count int, historyPolygonlocations1 HistoryPolygonlocationSlice, organization0 *Organization) (HistoryPolygonlocationSlice, error) {
	setter := &HistoryPolygonlocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyPolygonlocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryPolygonlocations0: %w", err)
	}

	return historyPolygonlocations1, nil
}

func (organization0 *Organization) InsertHistoryPolygonlocations(ctx context.Context, exec bob.Executor, related ...*HistoryPolygonlocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyPolygonlocations1, err := insertOrganizationHistoryPolygonlocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryPolygonlocations = append(organization0.R.HistoryPolygonlocations, historyPolygonlocations1...)

	for _, rel := range historyPolygonlocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryPolygonlocations(ctx context.Context, exec bob.Executor, related ...*HistoryPolygonlocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyPolygonlocations1 := HistoryPolygonlocationSlice(related)

	_, err = attachOrganizationHistoryPolygonlocations0(ctx, exec, len(related), historyPolygonlocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryPolygonlocations = append(organization0.R.HistoryPolygonlocations, historyPolygonlocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryPools0(ctx context.Context, exec bob.Executor, historyPools1 []*HistoryPoolSetter, organization0 *Organization) (HistoryPoolSlice, error) {
	for i := range historyPools1 {
		historyPools1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryPools.Insert(bob.ToMods(historyPools1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryPools0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryPools0(ctx context.Context, exec bob.Executor, count int, historyPools1 HistoryPoolSlice, organization0 *Organization) (HistoryPoolSlice, error) {
	setter := &HistoryPoolSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyPools1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryPools0: %w", err)
	}

	return historyPools1, nil
}

func (organization0 *Organization) InsertHistoryPools(ctx context.Context, exec bob.Executor, related ...*HistoryPoolSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyPools1, err := insertOrganizationHistoryPools0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryPools = append(organization0.R.HistoryPools, historyPools1...)

	for _, rel := range historyPools1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryPools(ctx context.Context, exec bob.Executor, related ...*HistoryPool) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyPools1 := HistoryPoolSlice(related)

	_, err = attachOrganizationHistoryPools0(ctx, exec, len(related), historyPools1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryPools = append(organization0.R.HistoryPools, historyPools1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryPooldetails0(ctx context.Context, exec bob.Executor, historyPooldetails1 []*HistoryPooldetailSetter, organization0 *Organization) (HistoryPooldetailSlice, error) {
	for i := range historyPooldetails1 {
		historyPooldetails1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryPooldetails.Insert(bob.ToMods(historyPooldetails1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryPooldetails0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryPooldetails0(ctx context.Context, exec bob.Executor, count int, historyPooldetails1 HistoryPooldetailSlice, organization0 *Organization) (HistoryPooldetailSlice, error) {
	setter := &HistoryPooldetailSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyPooldetails1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryPooldetails0: %w", err)
	}

	return historyPooldetails1, nil
}

func (organization0 *Organization) InsertHistoryPooldetails(ctx context.Context, exec bob.Executor, related ...*HistoryPooldetailSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyPooldetails1, err := insertOrganizationHistoryPooldetails0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryPooldetails = append(organization0.R.HistoryPooldetails, historyPooldetails1...)

	for _, rel := range historyPooldetails1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryPooldetails(ctx context.Context, exec bob.Executor, related ...*HistoryPooldetail) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyPooldetails1 := HistoryPooldetailSlice(related)

	_, err = attachOrganizationHistoryPooldetails0(ctx, exec, len(related), historyPooldetails1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryPooldetails = append(organization0.R.HistoryPooldetails, historyPooldetails1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryProposedtreatmentareas0(ctx context.Context, exec bob.Executor, historyProposedtreatmentareas1 []*HistoryProposedtreatmentareaSetter, organization0 *Organization) (HistoryProposedtreatmentareaSlice, error) {
	for i := range historyProposedtreatmentareas1 {
		historyProposedtreatmentareas1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryProposedtreatmentareas.Insert(bob.ToMods(historyProposedtreatmentareas1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryProposedtreatmentareas0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryProposedtreatmentareas0(ctx context.Context, exec bob.Executor, count int, historyProposedtreatmentareas1 HistoryProposedtreatmentareaSlice, organization0 *Organization) (HistoryProposedtreatmentareaSlice, error) {
	setter := &HistoryProposedtreatmentareaSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyProposedtreatmentareas1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryProposedtreatmentareas0: %w", err)
	}

	return historyProposedtreatmentareas1, nil
}

func (organization0 *Organization) InsertHistoryProposedtreatmentareas(ctx context.Context, exec bob.Executor, related ...*HistoryProposedtreatmentareaSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyProposedtreatmentareas1, err := insertOrganizationHistoryProposedtreatmentareas0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryProposedtreatmentareas = append(organization0.R.HistoryProposedtreatmentareas, historyProposedtreatmentareas1...)

	for _, rel := range historyProposedtreatmentareas1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryProposedtreatmentareas(ctx context.Context, exec bob.Executor, related ...*HistoryProposedtreatmentarea) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyProposedtreatmentareas1 := HistoryProposedtreatmentareaSlice(related)

	_, err = attachOrganizationHistoryProposedtreatmentareas0(ctx, exec, len(related), historyProposedtreatmentareas1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryProposedtreatmentareas = append(organization0.R.HistoryProposedtreatmentareas, historyProposedtreatmentareas1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryQamosquitoinspections0(ctx context.Context, exec bob.Executor, historyQamosquitoinspections1 []*HistoryQamosquitoinspectionSetter, organization0 *Organization) (HistoryQamosquitoinspectionSlice, error) {
	for i := range historyQamosquitoinspections1 {
		historyQamosquitoinspections1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryQamosquitoinspections.Insert(bob.ToMods(historyQamosquitoinspections1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryQamosquitoinspections0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryQamosquitoinspections0(ctx context.Context, exec bob.Executor, count int, historyQamosquitoinspections1 HistoryQamosquitoinspectionSlice, organization0 *Organization) (HistoryQamosquitoinspectionSlice, error) {
	setter := &HistoryQamosquitoinspectionSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyQamosquitoinspections1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryQamosquitoinspections0: %w", err)
	}

	return historyQamosquitoinspections1, nil
}

func (organization0 *Organization) InsertHistoryQamosquitoinspections(ctx context.Context, exec bob.Executor, related ...*HistoryQamosquitoinspectionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyQamosquitoinspections1, err := insertOrganizationHistoryQamosquitoinspections0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryQamosquitoinspections = append(organization0.R.HistoryQamosquitoinspections, historyQamosquitoinspections1...)

	for _, rel := range historyQamosquitoinspections1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryQamosquitoinspections(ctx context.Context, exec bob.Executor, related ...*HistoryQamosquitoinspection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyQamosquitoinspections1 := HistoryQamosquitoinspectionSlice(related)

	_, err = attachOrganizationHistoryQamosquitoinspections0(ctx, exec, len(related), historyQamosquitoinspections1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryQamosquitoinspections = append(organization0.R.HistoryQamosquitoinspections, historyQamosquitoinspections1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryRodentlocations0(ctx context.Context, exec bob.Executor, historyRodentlocations1 []*HistoryRodentlocationSetter, organization0 *Organization) (HistoryRodentlocationSlice, error) {
	for i := range historyRodentlocations1 {
		historyRodentlocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryRodentlocations.Insert(bob.ToMods(historyRodentlocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryRodentlocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryRodentlocations0(ctx context.Context, exec bob.Executor, count int, historyRodentlocations1 HistoryRodentlocationSlice, organization0 *Organization) (HistoryRodentlocationSlice, error) {
	setter := &HistoryRodentlocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyRodentlocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryRodentlocations0: %w", err)
	}

	return historyRodentlocations1, nil
}

func (organization0 *Organization) InsertHistoryRodentlocations(ctx context.Context, exec bob.Executor, related ...*HistoryRodentlocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyRodentlocations1, err := insertOrganizationHistoryRodentlocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryRodentlocations = append(organization0.R.HistoryRodentlocations, historyRodentlocations1...)

	for _, rel := range historyRodentlocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryRodentlocations(ctx context.Context, exec bob.Executor, related ...*HistoryRodentlocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyRodentlocations1 := HistoryRodentlocationSlice(related)

	_, err = attachOrganizationHistoryRodentlocations0(ctx, exec, len(related), historyRodentlocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryRodentlocations = append(organization0.R.HistoryRodentlocations, historyRodentlocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistorySamplecollections0(ctx context.Context, exec bob.Executor, historySamplecollections1 []*HistorySamplecollectionSetter, organization0 *Organization) (HistorySamplecollectionSlice, error) {
	for i := range historySamplecollections1 {
		historySamplecollections1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistorySamplecollections.Insert(bob.ToMods(historySamplecollections1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistorySamplecollections0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistorySamplecollections0(ctx context.Context, exec bob.Executor, count int, historySamplecollections1 HistorySamplecollectionSlice, organization0 *Organization) (HistorySamplecollectionSlice, error) {
	setter := &HistorySamplecollectionSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historySamplecollections1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistorySamplecollections0: %w", err)
	}

	return historySamplecollections1, nil
}

func (organization0 *Organization) InsertHistorySamplecollections(ctx context.Context, exec bob.Executor, related ...*HistorySamplecollectionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historySamplecollections1, err := insertOrganizationHistorySamplecollections0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistorySamplecollections = append(organization0.R.HistorySamplecollections, historySamplecollections1...)

	for _, rel := range historySamplecollections1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistorySamplecollections(ctx context.Context, exec bob.Executor, related ...*HistorySamplecollection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historySamplecollections1 := HistorySamplecollectionSlice(related)

	_, err = attachOrganizationHistorySamplecollections0(ctx, exec, len(related), historySamplecollections1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistorySamplecollections = append(organization0.R.HistorySamplecollections, historySamplecollections1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistorySamplelocations0(ctx context.Context, exec bob.Executor, historySamplelocations1 []*HistorySamplelocationSetter, organization0 *Organization) (HistorySamplelocationSlice, error) {
	for i := range historySamplelocations1 {
		historySamplelocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistorySamplelocations.Insert(bob.ToMods(historySamplelocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistorySamplelocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistorySamplelocations0(ctx context.Context, exec bob.Executor, count int, historySamplelocations1 HistorySamplelocationSlice, organization0 *Organization) (HistorySamplelocationSlice, error) {
	setter := &HistorySamplelocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historySamplelocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistorySamplelocations0: %w", err)
	}

	return historySamplelocations1, nil
}

func (organization0 *Organization) InsertHistorySamplelocations(ctx context.Context, exec bob.Executor, related ...*HistorySamplelocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historySamplelocations1, err := insertOrganizationHistorySamplelocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistorySamplelocations = append(organization0.R.HistorySamplelocations, historySamplelocations1...)

	for _, rel := range historySamplelocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistorySamplelocations(ctx context.Context, exec bob.Executor, related ...*HistorySamplelocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historySamplelocations1 := HistorySamplelocationSlice(related)

	_, err = attachOrganizationHistorySamplelocations0(ctx, exec, len(related), historySamplelocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistorySamplelocations = append(organization0.R.HistorySamplelocations, historySamplelocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryServicerequests0(ctx context.Context, exec bob.Executor, historyServicerequests1 []*HistoryServicerequestSetter, organization0 *Organization) (HistoryServicerequestSlice, error) {
	for i := range historyServicerequests1 {
		historyServicerequests1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryServicerequests.Insert(bob.ToMods(historyServicerequests1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryServicerequests0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryServicerequests0(ctx context.Context, exec bob.Executor, count int, historyServicerequests1 HistoryServicerequestSlice, organization0 *Organization) (HistoryServicerequestSlice, error) {
	setter := &HistoryServicerequestSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyServicerequests1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryServicerequests0: %w", err)
	}

	return historyServicerequests1, nil
}

func (organization0 *Organization) InsertHistoryServicerequests(ctx context.Context, exec bob.Executor, related ...*HistoryServicerequestSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyServicerequests1, err := insertOrganizationHistoryServicerequests0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryServicerequests = append(organization0.R.HistoryServicerequests, historyServicerequests1...)

	for _, rel := range historyServicerequests1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryServicerequests(ctx context.Context, exec bob.Executor, related ...*HistoryServicerequest) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyServicerequests1 := HistoryServicerequestSlice(related)

	_, err = attachOrganizationHistoryServicerequests0(ctx, exec, len(related), historyServicerequests1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryServicerequests = append(organization0.R.HistoryServicerequests, historyServicerequests1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistorySpeciesabundances0(ctx context.Context, exec bob.Executor, historySpeciesabundances1 []*HistorySpeciesabundanceSetter, organization0 *Organization) (HistorySpeciesabundanceSlice, error) {
	for i := range historySpeciesabundances1 {
		historySpeciesabundances1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistorySpeciesabundances.Insert(bob.ToMods(historySpeciesabundances1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistorySpeciesabundances0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistorySpeciesabundances0(ctx context.Context, exec bob.Executor, count int, historySpeciesabundances1 HistorySpeciesabundanceSlice, organization0 *Organization) (HistorySpeciesabundanceSlice, error) {
	setter := &HistorySpeciesabundanceSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historySpeciesabundances1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistorySpeciesabundances0: %w", err)
	}

	return historySpeciesabundances1, nil
}

func (organization0 *Organization) InsertHistorySpeciesabundances(ctx context.Context, exec bob.Executor, related ...*HistorySpeciesabundanceSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historySpeciesabundances1, err := insertOrganizationHistorySpeciesabundances0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistorySpeciesabundances = append(organization0.R.HistorySpeciesabundances, historySpeciesabundances1...)

	for _, rel := range historySpeciesabundances1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistorySpeciesabundances(ctx context.Context, exec bob.Executor, related ...*HistorySpeciesabundance) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historySpeciesabundances1 := HistorySpeciesabundanceSlice(related)

	_, err = attachOrganizationHistorySpeciesabundances0(ctx, exec, len(related), historySpeciesabundances1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistorySpeciesabundances = append(organization0.R.HistorySpeciesabundances, historySpeciesabundances1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryStormdrains0(ctx context.Context, exec bob.Executor, historyStormdrains1 []*HistoryStormdrainSetter, organization0 *Organization) (HistoryStormdrainSlice, error) {
	for i := range historyStormdrains1 {
		historyStormdrains1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryStormdrains.Insert(bob.ToMods(historyStormdrains1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryStormdrains0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryStormdrains0(ctx context.Context, exec bob.Executor, count int, historyStormdrains1 HistoryStormdrainSlice, organization0 *Organization) (HistoryStormdrainSlice, error) {
	setter := &HistoryStormdrainSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyStormdrains1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryStormdrains0: %w", err)
	}

	return historyStormdrains1, nil
}

func (organization0 *Organization) InsertHistoryStormdrains(ctx context.Context, exec bob.Executor, related ...*HistoryStormdrainSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyStormdrains1, err := insertOrganizationHistoryStormdrains0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryStormdrains = append(organization0.R.HistoryStormdrains, historyStormdrains1...)

	for _, rel := range historyStormdrains1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryStormdrains(ctx context.Context, exec bob.Executor, related ...*HistoryStormdrain) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyStormdrains1 := HistoryStormdrainSlice(related)

	_, err = attachOrganizationHistoryStormdrains0(ctx, exec, len(related), historyStormdrains1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryStormdrains = append(organization0.R.HistoryStormdrains, historyStormdrains1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryTimecards0(ctx context.Context, exec bob.Executor, historyTimecards1 []*HistoryTimecardSetter, organization0 *Organization) (HistoryTimecardSlice, error) {
	for i := range historyTimecards1 {
		historyTimecards1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryTimecards.Insert(bob.ToMods(historyTimecards1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryTimecards0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryTimecards0(ctx context.Context, exec bob.Executor, count int, historyTimecards1 HistoryTimecardSlice, organization0 *Organization) (HistoryTimecardSlice, error) {
	setter := &HistoryTimecardSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyTimecards1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryTimecards0: %w", err)
	}

	return historyTimecards1, nil
}

func (organization0 *Organization) InsertHistoryTimecards(ctx context.Context, exec bob.Executor, related ...*HistoryTimecardSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyTimecards1, err := insertOrganizationHistoryTimecards0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTimecards = append(organization0.R.HistoryTimecards, historyTimecards1...)

	for _, rel := range historyTimecards1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryTimecards(ctx context.Context, exec bob.Executor, related ...*HistoryTimecard) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyTimecards1 := HistoryTimecardSlice(related)

	_, err = attachOrganizationHistoryTimecards0(ctx, exec, len(related), historyTimecards1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTimecards = append(organization0.R.HistoryTimecards, historyTimecards1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryTrapdata0(ctx context.Context, exec bob.Executor, historyTrapdata1 []*HistoryTrapdatumSetter, organization0 *Organization) (HistoryTrapdatumSlice, error) {
	for i := range historyTrapdata1 {
		historyTrapdata1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryTrapdata.Insert(bob.ToMods(historyTrapdata1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryTrapdata0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryTrapdata0(ctx context.Context, exec bob.Executor, count int, historyTrapdata1 HistoryTrapdatumSlice, organization0 *Organization) (HistoryTrapdatumSlice, error) {
	setter := &HistoryTrapdatumSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyTrapdata1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryTrapdata0: %w", err)
	}

	return historyTrapdata1, nil
}

func (organization0 *Organization) InsertHistoryTrapdata(ctx context.Context, exec bob.Executor, related ...*HistoryTrapdatumSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyTrapdata1, err := insertOrganizationHistoryTrapdata0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTrapdata = append(organization0.R.HistoryTrapdata, historyTrapdata1...)

	for _, rel := range historyTrapdata1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryTrapdata(ctx context.Context, exec bob.Executor, related ...*HistoryTrapdatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyTrapdata1 := HistoryTrapdatumSlice(related)

	_, err = attachOrganizationHistoryTrapdata0(ctx, exec, len(related), historyTrapdata1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTrapdata = append(organization0.R.HistoryTrapdata, historyTrapdata1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryTraplocations0(ctx context.Context, exec bob.Executor, historyTraplocations1 []*HistoryTraplocationSetter, organization0 *Organization) (HistoryTraplocationSlice, error) {
	for i := range historyTraplocations1 {
		historyTraplocations1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryTraplocations.Insert(bob.ToMods(historyTraplocations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryTraplocations0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryTraplocations0(ctx context.Context, exec bob.Executor, count int, historyTraplocations1 HistoryTraplocationSlice, organization0 *Organization) (HistoryTraplocationSlice, error) {
	setter := &HistoryTraplocationSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyTraplocations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryTraplocations0: %w", err)
	}

	return historyTraplocations1, nil
}

func (organization0 *Organization) InsertHistoryTraplocations(ctx context.Context, exec bob.Executor, related ...*HistoryTraplocationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyTraplocations1, err := insertOrganizationHistoryTraplocations0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTraplocations = append(organization0.R.HistoryTraplocations, historyTraplocations1...)

	for _, rel := range historyTraplocations1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryTraplocations(ctx context.Context, exec bob.Executor, related ...*HistoryTraplocation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyTraplocations1 := HistoryTraplocationSlice(related)

	_, err = attachOrganizationHistoryTraplocations0(ctx, exec, len(related), historyTraplocations1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTraplocations = append(organization0.R.HistoryTraplocations, historyTraplocations1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryTreatments0(ctx context.Context, exec bob.Executor, historyTreatments1 []*HistoryTreatmentSetter, organization0 *Organization) (HistoryTreatmentSlice, error) {
	for i := range historyTreatments1 {
		historyTreatments1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryTreatments.Insert(bob.ToMods(historyTreatments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryTreatments0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryTreatments0(ctx context.Context, exec bob.Executor, count int, historyTreatments1 HistoryTreatmentSlice, organization0 *Organization) (HistoryTreatmentSlice, error) {
	setter := &HistoryTreatmentSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyTreatments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryTreatments0: %w", err)
	}

	return historyTreatments1, nil
}

func (organization0 *Organization) InsertHistoryTreatments(ctx context.Context, exec bob.Executor, related ...*HistoryTreatmentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyTreatments1, err := insertOrganizationHistoryTreatments0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTreatments = append(organization0.R.HistoryTreatments, historyTreatments1...)

	for _, rel := range historyTreatments1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryTreatments(ctx context.Context, exec bob.Executor, related ...*HistoryTreatment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyTreatments1 := HistoryTreatmentSlice(related)

	_, err = attachOrganizationHistoryTreatments0(ctx, exec, len(related), historyTreatments1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTreatments = append(organization0.R.HistoryTreatments, historyTreatments1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryTreatmentareas0(ctx context.Context, exec bob.Executor, historyTreatmentareas1 []*HistoryTreatmentareaSetter, organization0 *Organization) (HistoryTreatmentareaSlice, error) {
	for i := range historyTreatmentareas1 {
		historyTreatmentareas1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryTreatmentareas.Insert(bob.ToMods(historyTreatmentareas1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryTreatmentareas0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryTreatmentareas0(ctx context.Context, exec bob.Executor, count int, historyTreatmentareas1 HistoryTreatmentareaSlice, organization0 *Organization) (HistoryTreatmentareaSlice, error) {
	setter := &HistoryTreatmentareaSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyTreatmentareas1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryTreatmentareas0: %w", err)
	}

	return historyTreatmentareas1, nil
}

func (organization0 *Organization) InsertHistoryTreatmentareas(ctx context.Context, exec bob.Executor, related ...*HistoryTreatmentareaSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyTreatmentareas1, err := insertOrganizationHistoryTreatmentareas0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTreatmentareas = append(organization0.R.HistoryTreatmentareas, historyTreatmentareas1...)

	for _, rel := range historyTreatmentareas1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryTreatmentareas(ctx context.Context, exec bob.Executor, related ...*HistoryTreatmentarea) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyTreatmentareas1 := HistoryTreatmentareaSlice(related)

	_, err = attachOrganizationHistoryTreatmentareas0(ctx, exec, len(related), historyTreatmentareas1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryTreatmentareas = append(organization0.R.HistoryTreatmentareas, historyTreatmentareas1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryZones0(ctx context.Context, exec bob.Executor, historyZones1 []*HistoryZoneSetter, organization0 *Organization) (HistoryZoneSlice, error) {
	for i := range historyZones1 {
		historyZones1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryZones.Insert(bob.ToMods(historyZones1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryZones0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryZones0(ctx context.Context, exec bob.Executor, count int, historyZones1 HistoryZoneSlice, organization0 *Organization) (HistoryZoneSlice, error) {
	setter := &HistoryZoneSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyZones1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryZones0: %w", err)
	}

	return historyZones1, nil
}

func (organization0 *Organization) InsertHistoryZones(ctx context.Context, exec bob.Executor, related ...*HistoryZoneSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyZones1, err := insertOrganizationHistoryZones0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryZones = append(organization0.R.HistoryZones, historyZones1...)

	for _, rel := range historyZones1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryZones(ctx context.Context, exec bob.Executor, related ...*HistoryZone) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyZones1 := HistoryZoneSlice(related)

	_, err = attachOrganizationHistoryZones0(ctx, exec, len(related), historyZones1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryZones = append(organization0.R.HistoryZones, historyZones1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationHistoryZones2s0(ctx context.Context, exec bob.Executor, historyZones2s1 []*HistoryZones2Setter, organization0 *Organization) (HistoryZones2Slice, error) {
	for i := range historyZones2s1 {
		historyZones2s1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := HistoryZones2s.Insert(bob.ToMods(historyZones2s1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationHistoryZones2s0: %w", err)
	}

	return ret, nil
}

func attachOrganizationHistoryZones2s0(ctx context.Context, exec bob.Executor, count int, historyZones2s1 HistoryZones2Slice, organization0 *Organization) (HistoryZones2Slice, error) {
	setter := &HistoryZones2Setter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := historyZones2s1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationHistoryZones2s0: %w", err)
	}

	return historyZones2s1, nil
}

func (organization0 *Organization) InsertHistoryZones2s(ctx context.Context, exec bob.Executor, related ...*HistoryZones2Setter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	historyZones2s1, err := insertOrganizationHistoryZones2s0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryZones2s = append(organization0.R.HistoryZones2s, historyZones2s1...)

	for _, rel := range historyZones2s1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachHistoryZones2s(ctx context.Context, exec bob.Executor, related ...*HistoryZones2) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	historyZones2s1 := HistoryZones2Slice(related)

	_, err = attachOrganizationHistoryZones2s0(ctx, exec, len(related), historyZones2s1, organization0)
	if err != nil {
		return err
	}

	organization0.R.HistoryZones2s = append(organization0.R.HistoryZones2s, historyZones2s1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

func insertOrganizationUser0(ctx context.Context, exec bob.Executor, users1 []*UserSetter, organization0 *Organization) (UserSlice, error) {
	for i := range users1 {
		users1[i].OrganizationID = omitnull.From(organization0.ID)
	}

	ret, err := Users.Insert(bob.ToMods(users1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrganizationUser0: %w", err)
	}

	return ret, nil
}

func attachOrganizationUser0(ctx context.Context, exec bob.Executor, count int, users1 UserSlice, organization0 *Organization) (UserSlice, error) {
	setter := &UserSetter{
		OrganizationID: omitnull.From(organization0.ID),
	}

	err := users1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrganizationUser0: %w", err)
	}

	return users1, nil
}

func (organization0 *Organization) InsertUser(ctx context.Context, exec bob.Executor, related ...*UserSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	users1, err := insertOrganizationUser0(ctx, exec, related, organization0)
	if err != nil {
		return err
	}

	organization0.R.User = append(organization0.R.User, users1...)

	for _, rel := range users1 {
		rel.R.Organization = organization0
	}
	return nil
}

func (organization0 *Organization) AttachUser(ctx context.Context, exec bob.Executor, related ...*User) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	users1 := UserSlice(related)

	_, err = attachOrganizationUser0(ctx, exec, len(related), users1, organization0)
	if err != nil {
		return err
	}

	organization0.R.User = append(organization0.R.User, users1...)

	for _, rel := range related {
		rel.R.Organization = organization0
	}

	return nil
}

type organizationWhere[Q psql.Filterable] struct {
	ID             psql.WhereMod[Q, int32]
	Name           psql.WhereNullMod[Q, string]
	ArcgisID       psql.WhereNullMod[Q, string]
	ArcgisName     psql.WhereNullMod[Q, string]
	FieldseekerURL psql.WhereNullMod[Q, string]
}

func (organizationWhere[Q]) AliasedAs(alias string) organizationWhere[Q] {
	return buildOrganizationWhere[Q](buildOrganizationColumns(alias))
}

func buildOrganizationWhere[Q psql.Filterable](cols organizationColumns) organizationWhere[Q] {
	return organizationWhere[Q]{
		ID:             psql.Where[Q, int32](cols.ID),
		Name:           psql.WhereNull[Q, string](cols.Name),
		ArcgisID:       psql.WhereNull[Q, string](cols.ArcgisID),
		ArcgisName:     psql.WhereNull[Q, string](cols.ArcgisName),
		FieldseekerURL: psql.WhereNull[Q, string](cols.FieldseekerURL),
	}
}

func (o *Organization) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "FSContainerrelates":
		rels, ok := retrieved.(FSContainerrelateSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSContainerrelates = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSFieldscoutinglogs":
		rels, ok := retrieved.(FSFieldscoutinglogSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSFieldscoutinglogs = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSHabitatrelates":
		rels, ok := retrieved.(FSHabitatrelateSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSHabitatrelates = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSInspectionsamples":
		rels, ok := retrieved.(FSInspectionsampleSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSInspectionsamples = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSInspectionsampledetails":
		rels, ok := retrieved.(FSInspectionsampledetailSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSInspectionsampledetails = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSLinelocations":
		rels, ok := retrieved.(FSLinelocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSLinelocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSLocationtrackings":
		rels, ok := retrieved.(FSLocationtrackingSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSLocationtrackings = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSMosquitoinspections":
		rels, ok := retrieved.(FSMosquitoinspectionSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSMosquitoinspections = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSPointlocations":
		rels, ok := retrieved.(FSPointlocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSPointlocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSPolygonlocations":
		rels, ok := retrieved.(FSPolygonlocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSPolygonlocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSPools":
		rels, ok := retrieved.(FSPoolSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSPools = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSPooldetails":
		rels, ok := retrieved.(FSPooldetailSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSPooldetails = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSProposedtreatmentareas":
		rels, ok := retrieved.(FSProposedtreatmentareaSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSProposedtreatmentareas = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSQamosquitoinspections":
		rels, ok := retrieved.(FSQamosquitoinspectionSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSQamosquitoinspections = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSRodentlocations":
		rels, ok := retrieved.(FSRodentlocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSRodentlocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSSamplecollections":
		rels, ok := retrieved.(FSSamplecollectionSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSSamplecollections = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSSamplelocations":
		rels, ok := retrieved.(FSSamplelocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSSamplelocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSServicerequests":
		rels, ok := retrieved.(FSServicerequestSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSServicerequests = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSSpeciesabundances":
		rels, ok := retrieved.(FSSpeciesabundanceSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSSpeciesabundances = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSStormdrains":
		rels, ok := retrieved.(FSStormdrainSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSStormdrains = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSTimecards":
		rels, ok := retrieved.(FSTimecardSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSTimecards = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSTrapdata":
		rels, ok := retrieved.(FSTrapdatumSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSTrapdata = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSTraplocations":
		rels, ok := retrieved.(FSTraplocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSTraplocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSTreatments":
		rels, ok := retrieved.(FSTreatmentSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSTreatments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSTreatmentareas":
		rels, ok := retrieved.(FSTreatmentareaSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSTreatmentareas = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSZones":
		rels, ok := retrieved.(FSZoneSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSZones = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "FSZones2s":
		rels, ok := retrieved.(FSZones2Slice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.FSZones2s = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryContainerrelates":
		rels, ok := retrieved.(HistoryContainerrelateSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryContainerrelates = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryFieldscoutinglogs":
		rels, ok := retrieved.(HistoryFieldscoutinglogSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryFieldscoutinglogs = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryHabitatrelates":
		rels, ok := retrieved.(HistoryHabitatrelateSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryHabitatrelates = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryInspectionsamples":
		rels, ok := retrieved.(HistoryInspectionsampleSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryInspectionsamples = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryInspectionsampledetails":
		rels, ok := retrieved.(HistoryInspectionsampledetailSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryInspectionsampledetails = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryLinelocations":
		rels, ok := retrieved.(HistoryLinelocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryLinelocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryLocationtrackings":
		rels, ok := retrieved.(HistoryLocationtrackingSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryLocationtrackings = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryMosquitoinspections":
		rels, ok := retrieved.(HistoryMosquitoinspectionSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryMosquitoinspections = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryPointlocations":
		rels, ok := retrieved.(HistoryPointlocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryPointlocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryPolygonlocations":
		rels, ok := retrieved.(HistoryPolygonlocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryPolygonlocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryPools":
		rels, ok := retrieved.(HistoryPoolSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryPools = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryPooldetails":
		rels, ok := retrieved.(HistoryPooldetailSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryPooldetails = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryProposedtreatmentareas":
		rels, ok := retrieved.(HistoryProposedtreatmentareaSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryProposedtreatmentareas = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryQamosquitoinspections":
		rels, ok := retrieved.(HistoryQamosquitoinspectionSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryQamosquitoinspections = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryRodentlocations":
		rels, ok := retrieved.(HistoryRodentlocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryRodentlocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistorySamplecollections":
		rels, ok := retrieved.(HistorySamplecollectionSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistorySamplecollections = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistorySamplelocations":
		rels, ok := retrieved.(HistorySamplelocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistorySamplelocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryServicerequests":
		rels, ok := retrieved.(HistoryServicerequestSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryServicerequests = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistorySpeciesabundances":
		rels, ok := retrieved.(HistorySpeciesabundanceSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistorySpeciesabundances = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryStormdrains":
		rels, ok := retrieved.(HistoryStormdrainSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryStormdrains = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryTimecards":
		rels, ok := retrieved.(HistoryTimecardSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryTimecards = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryTrapdata":
		rels, ok := retrieved.(HistoryTrapdatumSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryTrapdata = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryTraplocations":
		rels, ok := retrieved.(HistoryTraplocationSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryTraplocations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryTreatments":
		rels, ok := retrieved.(HistoryTreatmentSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryTreatments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryTreatmentareas":
		rels, ok := retrieved.(HistoryTreatmentareaSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryTreatmentareas = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryZones":
		rels, ok := retrieved.(HistoryZoneSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryZones = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "HistoryZones2s":
		rels, ok := retrieved.(HistoryZones2Slice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.HistoryZones2s = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	case "User":
		rels, ok := retrieved.(UserSlice)
		if !ok {
			return fmt.Errorf("organization cannot load %T as %q", retrieved, name)
		}

		o.R.User = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Organization = o
			}
		}
		return nil
	default:
		return fmt.Errorf("organization has no relationship %q", name)
	}
}

type organizationPreloader struct{}

func buildOrganizationPreloader() organizationPreloader {
	return organizationPreloader{}
}

type organizationThenLoader[Q orm.Loadable] struct {
	FSContainerrelates             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSFieldscoutinglogs            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSHabitatrelates               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSInspectionsamples            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSInspectionsampledetails      func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSLinelocations                func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSLocationtrackings            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSMosquitoinspections          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSPointlocations               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSPolygonlocations             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSPools                        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSPooldetails                  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSProposedtreatmentareas       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSQamosquitoinspections        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSRodentlocations              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSSamplecollections            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSSamplelocations              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSServicerequests              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSSpeciesabundances            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSStormdrains                  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSTimecards                    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSTrapdata                     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSTraplocations                func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSTreatments                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSTreatmentareas               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSZones                        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FSZones2s                      func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryContainerrelates        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryFieldscoutinglogs       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryHabitatrelates          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryInspectionsamples       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryInspectionsampledetails func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryLinelocations           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryLocationtrackings       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryMosquitoinspections     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryPointlocations          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryPolygonlocations        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryPools                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryPooldetails             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryProposedtreatmentareas  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryQamosquitoinspections   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryRodentlocations         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistorySamplecollections       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistorySamplelocations         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryServicerequests         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistorySpeciesabundances       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryStormdrains             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryTimecards               func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryTrapdata                func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryTraplocations           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryTreatments              func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryTreatmentareas          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryZones                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	HistoryZones2s                 func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	User                           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildOrganizationThenLoader[Q orm.Loadable]() organizationThenLoader[Q] {
	type FSContainerrelatesLoadInterface interface {
		LoadFSContainerrelates(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSFieldscoutinglogsLoadInterface interface {
		LoadFSFieldscoutinglogs(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSHabitatrelatesLoadInterface interface {
		LoadFSHabitatrelates(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSInspectionsamplesLoadInterface interface {
		LoadFSInspectionsamples(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSInspectionsampledetailsLoadInterface interface {
		LoadFSInspectionsampledetails(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSLinelocationsLoadInterface interface {
		LoadFSLinelocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSLocationtrackingsLoadInterface interface {
		LoadFSLocationtrackings(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSMosquitoinspectionsLoadInterface interface {
		LoadFSMosquitoinspections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSPointlocationsLoadInterface interface {
		LoadFSPointlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSPolygonlocationsLoadInterface interface {
		LoadFSPolygonlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSPoolsLoadInterface interface {
		LoadFSPools(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSPooldetailsLoadInterface interface {
		LoadFSPooldetails(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSProposedtreatmentareasLoadInterface interface {
		LoadFSProposedtreatmentareas(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSQamosquitoinspectionsLoadInterface interface {
		LoadFSQamosquitoinspections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSRodentlocationsLoadInterface interface {
		LoadFSRodentlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSSamplecollectionsLoadInterface interface {
		LoadFSSamplecollections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSSamplelocationsLoadInterface interface {
		LoadFSSamplelocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSServicerequestsLoadInterface interface {
		LoadFSServicerequests(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSSpeciesabundancesLoadInterface interface {
		LoadFSSpeciesabundances(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSStormdrainsLoadInterface interface {
		LoadFSStormdrains(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSTimecardsLoadInterface interface {
		LoadFSTimecards(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSTrapdataLoadInterface interface {
		LoadFSTrapdata(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSTraplocationsLoadInterface interface {
		LoadFSTraplocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSTreatmentsLoadInterface interface {
		LoadFSTreatments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSTreatmentareasLoadInterface interface {
		LoadFSTreatmentareas(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSZonesLoadInterface interface {
		LoadFSZones(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FSZones2sLoadInterface interface {
		LoadFSZones2s(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryContainerrelatesLoadInterface interface {
		LoadHistoryContainerrelates(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryFieldscoutinglogsLoadInterface interface {
		LoadHistoryFieldscoutinglogs(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryHabitatrelatesLoadInterface interface {
		LoadHistoryHabitatrelates(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryInspectionsamplesLoadInterface interface {
		LoadHistoryInspectionsamples(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryInspectionsampledetailsLoadInterface interface {
		LoadHistoryInspectionsampledetails(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryLinelocationsLoadInterface interface {
		LoadHistoryLinelocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryLocationtrackingsLoadInterface interface {
		LoadHistoryLocationtrackings(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryMosquitoinspectionsLoadInterface interface {
		LoadHistoryMosquitoinspections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryPointlocationsLoadInterface interface {
		LoadHistoryPointlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryPolygonlocationsLoadInterface interface {
		LoadHistoryPolygonlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryPoolsLoadInterface interface {
		LoadHistoryPools(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryPooldetailsLoadInterface interface {
		LoadHistoryPooldetails(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryProposedtreatmentareasLoadInterface interface {
		LoadHistoryProposedtreatmentareas(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryQamosquitoinspectionsLoadInterface interface {
		LoadHistoryQamosquitoinspections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryRodentlocationsLoadInterface interface {
		LoadHistoryRodentlocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistorySamplecollectionsLoadInterface interface {
		LoadHistorySamplecollections(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistorySamplelocationsLoadInterface interface {
		LoadHistorySamplelocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryServicerequestsLoadInterface interface {
		LoadHistoryServicerequests(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistorySpeciesabundancesLoadInterface interface {
		LoadHistorySpeciesabundances(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryStormdrainsLoadInterface interface {
		LoadHistoryStormdrains(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryTimecardsLoadInterface interface {
		LoadHistoryTimecards(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryTrapdataLoadInterface interface {
		LoadHistoryTrapdata(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryTraplocationsLoadInterface interface {
		LoadHistoryTraplocations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryTreatmentsLoadInterface interface {
		LoadHistoryTreatments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryTreatmentareasLoadInterface interface {
		LoadHistoryTreatmentareas(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryZonesLoadInterface interface {
		LoadHistoryZones(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type HistoryZones2sLoadInterface interface {
		LoadHistoryZones2s(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserLoadInterface interface {
		LoadUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return organizationThenLoader[Q]{
		FSContainerrelates: thenLoadBuilder[Q](
			"FSContainerrelates",
			func(ctx context.Context, exec bob.Executor, retrieved FSContainerrelatesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSContainerrelates(ctx, exec, mods...)
			},
		),
		FSFieldscoutinglogs: thenLoadBuilder[Q](
			"FSFieldscoutinglogs",
			func(ctx context.Context, exec bob.Executor, retrieved FSFieldscoutinglogsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSFieldscoutinglogs(ctx, exec, mods...)
			},
		),
		FSHabitatrelates: thenLoadBuilder[Q](
			"FSHabitatrelates",
			func(ctx context.Context, exec bob.Executor, retrieved FSHabitatrelatesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSHabitatrelates(ctx, exec, mods...)
			},
		),
		FSInspectionsamples: thenLoadBuilder[Q](
			"FSInspectionsamples",
			func(ctx context.Context, exec bob.Executor, retrieved FSInspectionsamplesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSInspectionsamples(ctx, exec, mods...)
			},
		),
		FSInspectionsampledetails: thenLoadBuilder[Q](
			"FSInspectionsampledetails",
			func(ctx context.Context, exec bob.Executor, retrieved FSInspectionsampledetailsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSInspectionsampledetails(ctx, exec, mods...)
			},
		),
		FSLinelocations: thenLoadBuilder[Q](
			"FSLinelocations",
			func(ctx context.Context, exec bob.Executor, retrieved FSLinelocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSLinelocations(ctx, exec, mods...)
			},
		),
		FSLocationtrackings: thenLoadBuilder[Q](
			"FSLocationtrackings",
			func(ctx context.Context, exec bob.Executor, retrieved FSLocationtrackingsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSLocationtrackings(ctx, exec, mods...)
			},
		),
		FSMosquitoinspections: thenLoadBuilder[Q](
			"FSMosquitoinspections",
			func(ctx context.Context, exec bob.Executor, retrieved FSMosquitoinspectionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSMosquitoinspections(ctx, exec, mods...)
			},
		),
		FSPointlocations: thenLoadBuilder[Q](
			"FSPointlocations",
			func(ctx context.Context, exec bob.Executor, retrieved FSPointlocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSPointlocations(ctx, exec, mods...)
			},
		),
		FSPolygonlocations: thenLoadBuilder[Q](
			"FSPolygonlocations",
			func(ctx context.Context, exec bob.Executor, retrieved FSPolygonlocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSPolygonlocations(ctx, exec, mods...)
			},
		),
		FSPools: thenLoadBuilder[Q](
			"FSPools",
			func(ctx context.Context, exec bob.Executor, retrieved FSPoolsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSPools(ctx, exec, mods...)
			},
		),
		FSPooldetails: thenLoadBuilder[Q](
			"FSPooldetails",
			func(ctx context.Context, exec bob.Executor, retrieved FSPooldetailsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSPooldetails(ctx, exec, mods...)
			},
		),
		FSProposedtreatmentareas: thenLoadBuilder[Q](
			"FSProposedtreatmentareas",
			func(ctx context.Context, exec bob.Executor, retrieved FSProposedtreatmentareasLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSProposedtreatmentareas(ctx, exec, mods...)
			},
		),
		FSQamosquitoinspections: thenLoadBuilder[Q](
			"FSQamosquitoinspections",
			func(ctx context.Context, exec bob.Executor, retrieved FSQamosquitoinspectionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSQamosquitoinspections(ctx, exec, mods...)
			},
		),
		FSRodentlocations: thenLoadBuilder[Q](
			"FSRodentlocations",
			func(ctx context.Context, exec bob.Executor, retrieved FSRodentlocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSRodentlocations(ctx, exec, mods...)
			},
		),
		FSSamplecollections: thenLoadBuilder[Q](
			"FSSamplecollections",
			func(ctx context.Context, exec bob.Executor, retrieved FSSamplecollectionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSSamplecollections(ctx, exec, mods...)
			},
		),
		FSSamplelocations: thenLoadBuilder[Q](
			"FSSamplelocations",
			func(ctx context.Context, exec bob.Executor, retrieved FSSamplelocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSSamplelocations(ctx, exec, mods...)
			},
		),
		FSServicerequests: thenLoadBuilder[Q](
			"FSServicerequests",
			func(ctx context.Context, exec bob.Executor, retrieved FSServicerequestsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSServicerequests(ctx, exec, mods...)
			},
		),
		FSSpeciesabundances: thenLoadBuilder[Q](
			"FSSpeciesabundances",
			func(ctx context.Context, exec bob.Executor, retrieved FSSpeciesabundancesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSSpeciesabundances(ctx, exec, mods...)
			},
		),
		FSStormdrains: thenLoadBuilder[Q](
			"FSStormdrains",
			func(ctx context.Context, exec bob.Executor, retrieved FSStormdrainsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSStormdrains(ctx, exec, mods...)
			},
		),
		FSTimecards: thenLoadBuilder[Q](
			"FSTimecards",
			func(ctx context.Context, exec bob.Executor, retrieved FSTimecardsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSTimecards(ctx, exec, mods...)
			},
		),
		FSTrapdata: thenLoadBuilder[Q](
			"FSTrapdata",
			func(ctx context.Context, exec bob.Executor, retrieved FSTrapdataLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSTrapdata(ctx, exec, mods...)
			},
		),
		FSTraplocations: thenLoadBuilder[Q](
			"FSTraplocations",
			func(ctx context.Context, exec bob.Executor, retrieved FSTraplocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSTraplocations(ctx, exec, mods...)
			},
		),
		FSTreatments: thenLoadBuilder[Q](
			"FSTreatments",
			func(ctx context.Context, exec bob.Executor, retrieved FSTreatmentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSTreatments(ctx, exec, mods...)
			},
		),
		FSTreatmentareas: thenLoadBuilder[Q](
			"FSTreatmentareas",
			func(ctx context.Context, exec bob.Executor, retrieved FSTreatmentareasLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSTreatmentareas(ctx, exec, mods...)
			},
		),
		FSZones: thenLoadBuilder[Q](
			"FSZones",
			func(ctx context.Context, exec bob.Executor, retrieved FSZonesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSZones(ctx, exec, mods...)
			},
		),
		FSZones2s: thenLoadBuilder[Q](
			"FSZones2s",
			func(ctx context.Context, exec bob.Executor, retrieved FSZones2sLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFSZones2s(ctx, exec, mods...)
			},
		),
		HistoryContainerrelates: thenLoadBuilder[Q](
			"HistoryContainerrelates",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryContainerrelatesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryContainerrelates(ctx, exec, mods...)
			},
		),
		HistoryFieldscoutinglogs: thenLoadBuilder[Q](
			"HistoryFieldscoutinglogs",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryFieldscoutinglogsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryFieldscoutinglogs(ctx, exec, mods...)
			},
		),
		HistoryHabitatrelates: thenLoadBuilder[Q](
			"HistoryHabitatrelates",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryHabitatrelatesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryHabitatrelates(ctx, exec, mods...)
			},
		),
		HistoryInspectionsamples: thenLoadBuilder[Q](
			"HistoryInspectionsamples",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryInspectionsamplesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryInspectionsamples(ctx, exec, mods...)
			},
		),
		HistoryInspectionsampledetails: thenLoadBuilder[Q](
			"HistoryInspectionsampledetails",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryInspectionsampledetailsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryInspectionsampledetails(ctx, exec, mods...)
			},
		),
		HistoryLinelocations: thenLoadBuilder[Q](
			"HistoryLinelocations",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryLinelocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryLinelocations(ctx, exec, mods...)
			},
		),
		HistoryLocationtrackings: thenLoadBuilder[Q](
			"HistoryLocationtrackings",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryLocationtrackingsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryLocationtrackings(ctx, exec, mods...)
			},
		),
		HistoryMosquitoinspections: thenLoadBuilder[Q](
			"HistoryMosquitoinspections",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryMosquitoinspectionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryMosquitoinspections(ctx, exec, mods...)
			},
		),
		HistoryPointlocations: thenLoadBuilder[Q](
			"HistoryPointlocations",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryPointlocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryPointlocations(ctx, exec, mods...)
			},
		),
		HistoryPolygonlocations: thenLoadBuilder[Q](
			"HistoryPolygonlocations",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryPolygonlocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryPolygonlocations(ctx, exec, mods...)
			},
		),
		HistoryPools: thenLoadBuilder[Q](
			"HistoryPools",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryPoolsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryPools(ctx, exec, mods...)
			},
		),
		HistoryPooldetails: thenLoadBuilder[Q](
			"HistoryPooldetails",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryPooldetailsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryPooldetails(ctx, exec, mods...)
			},
		),
		HistoryProposedtreatmentareas: thenLoadBuilder[Q](
			"HistoryProposedtreatmentareas",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryProposedtreatmentareasLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryProposedtreatmentareas(ctx, exec, mods...)
			},
		),
		HistoryQamosquitoinspections: thenLoadBuilder[Q](
			"HistoryQamosquitoinspections",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryQamosquitoinspectionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryQamosquitoinspections(ctx, exec, mods...)
			},
		),
		HistoryRodentlocations: thenLoadBuilder[Q](
			"HistoryRodentlocations",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryRodentlocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryRodentlocations(ctx, exec, mods...)
			},
		),
		HistorySamplecollections: thenLoadBuilder[Q](
			"HistorySamplecollections",
			func(ctx context.Context, exec bob.Executor, retrieved HistorySamplecollectionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistorySamplecollections(ctx, exec, mods...)
			},
		),
		HistorySamplelocations: thenLoadBuilder[Q](
			"HistorySamplelocations",
			func(ctx context.Context, exec bob.Executor, retrieved HistorySamplelocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistorySamplelocations(ctx, exec, mods...)
			},
		),
		HistoryServicerequests: thenLoadBuilder[Q](
			"HistoryServicerequests",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryServicerequestsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryServicerequests(ctx, exec, mods...)
			},
		),
		HistorySpeciesabundances: thenLoadBuilder[Q](
			"HistorySpeciesabundances",
			func(ctx context.Context, exec bob.Executor, retrieved HistorySpeciesabundancesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistorySpeciesabundances(ctx, exec, mods...)
			},
		),
		HistoryStormdrains: thenLoadBuilder[Q](
			"HistoryStormdrains",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryStormdrainsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryStormdrains(ctx, exec, mods...)
			},
		),
		HistoryTimecards: thenLoadBuilder[Q](
			"HistoryTimecards",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryTimecardsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryTimecards(ctx, exec, mods...)
			},
		),
		HistoryTrapdata: thenLoadBuilder[Q](
			"HistoryTrapdata",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryTrapdataLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryTrapdata(ctx, exec, mods...)
			},
		),
		HistoryTraplocations: thenLoadBuilder[Q](
			"HistoryTraplocations",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryTraplocationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryTraplocations(ctx, exec, mods...)
			},
		),
		HistoryTreatments: thenLoadBuilder[Q](
			"HistoryTreatments",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryTreatmentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryTreatments(ctx, exec, mods...)
			},
		),
		HistoryTreatmentareas: thenLoadBuilder[Q](
			"HistoryTreatmentareas",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryTreatmentareasLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryTreatmentareas(ctx, exec, mods...)
			},
		),
		HistoryZones: thenLoadBuilder[Q](
			"HistoryZones",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryZonesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryZones(ctx, exec, mods...)
			},
		),
		HistoryZones2s: thenLoadBuilder[Q](
			"HistoryZones2s",
			func(ctx context.Context, exec bob.Executor, retrieved HistoryZones2sLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadHistoryZones2s(ctx, exec, mods...)
			},
		),
		User: thenLoadBuilder[Q](
			"User",
			func(ctx context.Context, exec bob.Executor, retrieved UserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadFSContainerrelates loads the organization's FSContainerrelates into the .R struct
func (o *Organization) LoadFSContainerrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSContainerrelates = nil

	related, err := o.FSContainerrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSContainerrelates = related
	return nil
}

// LoadFSContainerrelates loads the organization's FSContainerrelates into the .R struct
func (os OrganizationSlice) LoadFSContainerrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsContainerrelates, err := os.FSContainerrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSContainerrelates = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsContainerrelates {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSContainerrelates = append(o.R.FSContainerrelates, rel)
		}
	}

	return nil
}

// LoadFSFieldscoutinglogs loads the organization's FSFieldscoutinglogs into the .R struct
func (o *Organization) LoadFSFieldscoutinglogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSFieldscoutinglogs = nil

	related, err := o.FSFieldscoutinglogs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSFieldscoutinglogs = related
	return nil
}

// LoadFSFieldscoutinglogs loads the organization's FSFieldscoutinglogs into the .R struct
func (os OrganizationSlice) LoadFSFieldscoutinglogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsFieldscoutinglogs, err := os.FSFieldscoutinglogs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSFieldscoutinglogs = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsFieldscoutinglogs {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSFieldscoutinglogs = append(o.R.FSFieldscoutinglogs, rel)
		}
	}

	return nil
}

// LoadFSHabitatrelates loads the organization's FSHabitatrelates into the .R struct
func (o *Organization) LoadFSHabitatrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSHabitatrelates = nil

	related, err := o.FSHabitatrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSHabitatrelates = related
	return nil
}

// LoadFSHabitatrelates loads the organization's FSHabitatrelates into the .R struct
func (os OrganizationSlice) LoadFSHabitatrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsHabitatrelates, err := os.FSHabitatrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSHabitatrelates = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsHabitatrelates {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSHabitatrelates = append(o.R.FSHabitatrelates, rel)
		}
	}

	return nil
}

// LoadFSInspectionsamples loads the organization's FSInspectionsamples into the .R struct
func (o *Organization) LoadFSInspectionsamples(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSInspectionsamples = nil

	related, err := o.FSInspectionsamples(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSInspectionsamples = related
	return nil
}

// LoadFSInspectionsamples loads the organization's FSInspectionsamples into the .R struct
func (os OrganizationSlice) LoadFSInspectionsamples(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsInspectionsamples, err := os.FSInspectionsamples(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSInspectionsamples = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsInspectionsamples {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSInspectionsamples = append(o.R.FSInspectionsamples, rel)
		}
	}

	return nil
}

// LoadFSInspectionsampledetails loads the organization's FSInspectionsampledetails into the .R struct
func (o *Organization) LoadFSInspectionsampledetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSInspectionsampledetails = nil

	related, err := o.FSInspectionsampledetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSInspectionsampledetails = related
	return nil
}

// LoadFSInspectionsampledetails loads the organization's FSInspectionsampledetails into the .R struct
func (os OrganizationSlice) LoadFSInspectionsampledetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsInspectionsampledetails, err := os.FSInspectionsampledetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSInspectionsampledetails = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsInspectionsampledetails {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSInspectionsampledetails = append(o.R.FSInspectionsampledetails, rel)
		}
	}

	return nil
}

// LoadFSLinelocations loads the organization's FSLinelocations into the .R struct
func (o *Organization) LoadFSLinelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSLinelocations = nil

	related, err := o.FSLinelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSLinelocations = related
	return nil
}

// LoadFSLinelocations loads the organization's FSLinelocations into the .R struct
func (os OrganizationSlice) LoadFSLinelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsLinelocations, err := os.FSLinelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSLinelocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsLinelocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSLinelocations = append(o.R.FSLinelocations, rel)
		}
	}

	return nil
}

// LoadFSLocationtrackings loads the organization's FSLocationtrackings into the .R struct
func (o *Organization) LoadFSLocationtrackings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSLocationtrackings = nil

	related, err := o.FSLocationtrackings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSLocationtrackings = related
	return nil
}

// LoadFSLocationtrackings loads the organization's FSLocationtrackings into the .R struct
func (os OrganizationSlice) LoadFSLocationtrackings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsLocationtrackings, err := os.FSLocationtrackings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSLocationtrackings = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsLocationtrackings {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSLocationtrackings = append(o.R.FSLocationtrackings, rel)
		}
	}

	return nil
}

// LoadFSMosquitoinspections loads the organization's FSMosquitoinspections into the .R struct
func (o *Organization) LoadFSMosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSMosquitoinspections = nil

	related, err := o.FSMosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSMosquitoinspections = related
	return nil
}

// LoadFSMosquitoinspections loads the organization's FSMosquitoinspections into the .R struct
func (os OrganizationSlice) LoadFSMosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsMosquitoinspections, err := os.FSMosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSMosquitoinspections = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsMosquitoinspections {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSMosquitoinspections = append(o.R.FSMosquitoinspections, rel)
		}
	}

	return nil
}

// LoadFSPointlocations loads the organization's FSPointlocations into the .R struct
func (o *Organization) LoadFSPointlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSPointlocations = nil

	related, err := o.FSPointlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSPointlocations = related
	return nil
}

// LoadFSPointlocations loads the organization's FSPointlocations into the .R struct
func (os OrganizationSlice) LoadFSPointlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsPointlocations, err := os.FSPointlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSPointlocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsPointlocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSPointlocations = append(o.R.FSPointlocations, rel)
		}
	}

	return nil
}

// LoadFSPolygonlocations loads the organization's FSPolygonlocations into the .R struct
func (o *Organization) LoadFSPolygonlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSPolygonlocations = nil

	related, err := o.FSPolygonlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSPolygonlocations = related
	return nil
}

// LoadFSPolygonlocations loads the organization's FSPolygonlocations into the .R struct
func (os OrganizationSlice) LoadFSPolygonlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsPolygonlocations, err := os.FSPolygonlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSPolygonlocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsPolygonlocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSPolygonlocations = append(o.R.FSPolygonlocations, rel)
		}
	}

	return nil
}

// LoadFSPools loads the organization's FSPools into the .R struct
func (o *Organization) LoadFSPools(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSPools = nil

	related, err := o.FSPools(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSPools = related
	return nil
}

// LoadFSPools loads the organization's FSPools into the .R struct
func (os OrganizationSlice) LoadFSPools(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsPools, err := os.FSPools(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSPools = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsPools {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSPools = append(o.R.FSPools, rel)
		}
	}

	return nil
}

// LoadFSPooldetails loads the organization's FSPooldetails into the .R struct
func (o *Organization) LoadFSPooldetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSPooldetails = nil

	related, err := o.FSPooldetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSPooldetails = related
	return nil
}

// LoadFSPooldetails loads the organization's FSPooldetails into the .R struct
func (os OrganizationSlice) LoadFSPooldetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsPooldetails, err := os.FSPooldetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSPooldetails = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsPooldetails {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSPooldetails = append(o.R.FSPooldetails, rel)
		}
	}

	return nil
}

// LoadFSProposedtreatmentareas loads the organization's FSProposedtreatmentareas into the .R struct
func (o *Organization) LoadFSProposedtreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSProposedtreatmentareas = nil

	related, err := o.FSProposedtreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSProposedtreatmentareas = related
	return nil
}

// LoadFSProposedtreatmentareas loads the organization's FSProposedtreatmentareas into the .R struct
func (os OrganizationSlice) LoadFSProposedtreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsProposedtreatmentareas, err := os.FSProposedtreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSProposedtreatmentareas = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsProposedtreatmentareas {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSProposedtreatmentareas = append(o.R.FSProposedtreatmentareas, rel)
		}
	}

	return nil
}

// LoadFSQamosquitoinspections loads the organization's FSQamosquitoinspections into the .R struct
func (o *Organization) LoadFSQamosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSQamosquitoinspections = nil

	related, err := o.FSQamosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSQamosquitoinspections = related
	return nil
}

// LoadFSQamosquitoinspections loads the organization's FSQamosquitoinspections into the .R struct
func (os OrganizationSlice) LoadFSQamosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsQamosquitoinspections, err := os.FSQamosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSQamosquitoinspections = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsQamosquitoinspections {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSQamosquitoinspections = append(o.R.FSQamosquitoinspections, rel)
		}
	}

	return nil
}

// LoadFSRodentlocations loads the organization's FSRodentlocations into the .R struct
func (o *Organization) LoadFSRodentlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSRodentlocations = nil

	related, err := o.FSRodentlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSRodentlocations = related
	return nil
}

// LoadFSRodentlocations loads the organization's FSRodentlocations into the .R struct
func (os OrganizationSlice) LoadFSRodentlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsRodentlocations, err := os.FSRodentlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSRodentlocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsRodentlocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSRodentlocations = append(o.R.FSRodentlocations, rel)
		}
	}

	return nil
}

// LoadFSSamplecollections loads the organization's FSSamplecollections into the .R struct
func (o *Organization) LoadFSSamplecollections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSSamplecollections = nil

	related, err := o.FSSamplecollections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSSamplecollections = related
	return nil
}

// LoadFSSamplecollections loads the organization's FSSamplecollections into the .R struct
func (os OrganizationSlice) LoadFSSamplecollections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsSamplecollections, err := os.FSSamplecollections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSSamplecollections = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsSamplecollections {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSSamplecollections = append(o.R.FSSamplecollections, rel)
		}
	}

	return nil
}

// LoadFSSamplelocations loads the organization's FSSamplelocations into the .R struct
func (o *Organization) LoadFSSamplelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSSamplelocations = nil

	related, err := o.FSSamplelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSSamplelocations = related
	return nil
}

// LoadFSSamplelocations loads the organization's FSSamplelocations into the .R struct
func (os OrganizationSlice) LoadFSSamplelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsSamplelocations, err := os.FSSamplelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSSamplelocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsSamplelocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSSamplelocations = append(o.R.FSSamplelocations, rel)
		}
	}

	return nil
}

// LoadFSServicerequests loads the organization's FSServicerequests into the .R struct
func (o *Organization) LoadFSServicerequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSServicerequests = nil

	related, err := o.FSServicerequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSServicerequests = related
	return nil
}

// LoadFSServicerequests loads the organization's FSServicerequests into the .R struct
func (os OrganizationSlice) LoadFSServicerequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsServicerequests, err := os.FSServicerequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSServicerequests = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsServicerequests {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSServicerequests = append(o.R.FSServicerequests, rel)
		}
	}

	return nil
}

// LoadFSSpeciesabundances loads the organization's FSSpeciesabundances into the .R struct
func (o *Organization) LoadFSSpeciesabundances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSSpeciesabundances = nil

	related, err := o.FSSpeciesabundances(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSSpeciesabundances = related
	return nil
}

// LoadFSSpeciesabundances loads the organization's FSSpeciesabundances into the .R struct
func (os OrganizationSlice) LoadFSSpeciesabundances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsSpeciesabundances, err := os.FSSpeciesabundances(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSSpeciesabundances = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsSpeciesabundances {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSSpeciesabundances = append(o.R.FSSpeciesabundances, rel)
		}
	}

	return nil
}

// LoadFSStormdrains loads the organization's FSStormdrains into the .R struct
func (o *Organization) LoadFSStormdrains(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSStormdrains = nil

	related, err := o.FSStormdrains(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSStormdrains = related
	return nil
}

// LoadFSStormdrains loads the organization's FSStormdrains into the .R struct
func (os OrganizationSlice) LoadFSStormdrains(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsStormdrains, err := os.FSStormdrains(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSStormdrains = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsStormdrains {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSStormdrains = append(o.R.FSStormdrains, rel)
		}
	}

	return nil
}

// LoadFSTimecards loads the organization's FSTimecards into the .R struct
func (o *Organization) LoadFSTimecards(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSTimecards = nil

	related, err := o.FSTimecards(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSTimecards = related
	return nil
}

// LoadFSTimecards loads the organization's FSTimecards into the .R struct
func (os OrganizationSlice) LoadFSTimecards(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsTimecards, err := os.FSTimecards(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSTimecards = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsTimecards {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSTimecards = append(o.R.FSTimecards, rel)
		}
	}

	return nil
}

// LoadFSTrapdata loads the organization's FSTrapdata into the .R struct
func (o *Organization) LoadFSTrapdata(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSTrapdata = nil

	related, err := o.FSTrapdata(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSTrapdata = related
	return nil
}

// LoadFSTrapdata loads the organization's FSTrapdata into the .R struct
func (os OrganizationSlice) LoadFSTrapdata(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsTrapdata, err := os.FSTrapdata(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSTrapdata = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsTrapdata {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSTrapdata = append(o.R.FSTrapdata, rel)
		}
	}

	return nil
}

// LoadFSTraplocations loads the organization's FSTraplocations into the .R struct
func (o *Organization) LoadFSTraplocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSTraplocations = nil

	related, err := o.FSTraplocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSTraplocations = related
	return nil
}

// LoadFSTraplocations loads the organization's FSTraplocations into the .R struct
func (os OrganizationSlice) LoadFSTraplocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsTraplocations, err := os.FSTraplocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSTraplocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsTraplocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSTraplocations = append(o.R.FSTraplocations, rel)
		}
	}

	return nil
}

// LoadFSTreatments loads the organization's FSTreatments into the .R struct
func (o *Organization) LoadFSTreatments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSTreatments = nil

	related, err := o.FSTreatments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSTreatments = related
	return nil
}

// LoadFSTreatments loads the organization's FSTreatments into the .R struct
func (os OrganizationSlice) LoadFSTreatments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsTreatments, err := os.FSTreatments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSTreatments = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsTreatments {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSTreatments = append(o.R.FSTreatments, rel)
		}
	}

	return nil
}

// LoadFSTreatmentareas loads the organization's FSTreatmentareas into the .R struct
func (o *Organization) LoadFSTreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSTreatmentareas = nil

	related, err := o.FSTreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSTreatmentareas = related
	return nil
}

// LoadFSTreatmentareas loads the organization's FSTreatmentareas into the .R struct
func (os OrganizationSlice) LoadFSTreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsTreatmentareas, err := os.FSTreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSTreatmentareas = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsTreatmentareas {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSTreatmentareas = append(o.R.FSTreatmentareas, rel)
		}
	}

	return nil
}

// LoadFSZones loads the organization's FSZones into the .R struct
func (o *Organization) LoadFSZones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSZones = nil

	related, err := o.FSZones(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSZones = related
	return nil
}

// LoadFSZones loads the organization's FSZones into the .R struct
func (os OrganizationSlice) LoadFSZones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsZones, err := os.FSZones(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSZones = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsZones {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSZones = append(o.R.FSZones, rel)
		}
	}

	return nil
}

// LoadFSZones2s loads the organization's FSZones2s into the .R struct
func (o *Organization) LoadFSZones2s(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FSZones2s = nil

	related, err := o.FSZones2s(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.FSZones2s = related
	return nil
}

// LoadFSZones2s loads the organization's FSZones2s into the .R struct
func (os OrganizationSlice) LoadFSZones2s(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	fsZones2s, err := os.FSZones2s(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FSZones2s = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range fsZones2s {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.FSZones2s = append(o.R.FSZones2s, rel)
		}
	}

	return nil
}

// LoadHistoryContainerrelates loads the organization's HistoryContainerrelates into the .R struct
func (o *Organization) LoadHistoryContainerrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryContainerrelates = nil

	related, err := o.HistoryContainerrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryContainerrelates = related
	return nil
}

// LoadHistoryContainerrelates loads the organization's HistoryContainerrelates into the .R struct
func (os OrganizationSlice) LoadHistoryContainerrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyContainerrelates, err := os.HistoryContainerrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryContainerrelates = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyContainerrelates {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryContainerrelates = append(o.R.HistoryContainerrelates, rel)
		}
	}

	return nil
}

// LoadHistoryFieldscoutinglogs loads the organization's HistoryFieldscoutinglogs into the .R struct
func (o *Organization) LoadHistoryFieldscoutinglogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryFieldscoutinglogs = nil

	related, err := o.HistoryFieldscoutinglogs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryFieldscoutinglogs = related
	return nil
}

// LoadHistoryFieldscoutinglogs loads the organization's HistoryFieldscoutinglogs into the .R struct
func (os OrganizationSlice) LoadHistoryFieldscoutinglogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyFieldscoutinglogs, err := os.HistoryFieldscoutinglogs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryFieldscoutinglogs = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyFieldscoutinglogs {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryFieldscoutinglogs = append(o.R.HistoryFieldscoutinglogs, rel)
		}
	}

	return nil
}

// LoadHistoryHabitatrelates loads the organization's HistoryHabitatrelates into the .R struct
func (o *Organization) LoadHistoryHabitatrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryHabitatrelates = nil

	related, err := o.HistoryHabitatrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryHabitatrelates = related
	return nil
}

// LoadHistoryHabitatrelates loads the organization's HistoryHabitatrelates into the .R struct
func (os OrganizationSlice) LoadHistoryHabitatrelates(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyHabitatrelates, err := os.HistoryHabitatrelates(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryHabitatrelates = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyHabitatrelates {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryHabitatrelates = append(o.R.HistoryHabitatrelates, rel)
		}
	}

	return nil
}

// LoadHistoryInspectionsamples loads the organization's HistoryInspectionsamples into the .R struct
func (o *Organization) LoadHistoryInspectionsamples(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryInspectionsamples = nil

	related, err := o.HistoryInspectionsamples(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryInspectionsamples = related
	return nil
}

// LoadHistoryInspectionsamples loads the organization's HistoryInspectionsamples into the .R struct
func (os OrganizationSlice) LoadHistoryInspectionsamples(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyInspectionsamples, err := os.HistoryInspectionsamples(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryInspectionsamples = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyInspectionsamples {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryInspectionsamples = append(o.R.HistoryInspectionsamples, rel)
		}
	}

	return nil
}

// LoadHistoryInspectionsampledetails loads the organization's HistoryInspectionsampledetails into the .R struct
func (o *Organization) LoadHistoryInspectionsampledetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryInspectionsampledetails = nil

	related, err := o.HistoryInspectionsampledetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryInspectionsampledetails = related
	return nil
}

// LoadHistoryInspectionsampledetails loads the organization's HistoryInspectionsampledetails into the .R struct
func (os OrganizationSlice) LoadHistoryInspectionsampledetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyInspectionsampledetails, err := os.HistoryInspectionsampledetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryInspectionsampledetails = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyInspectionsampledetails {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryInspectionsampledetails = append(o.R.HistoryInspectionsampledetails, rel)
		}
	}

	return nil
}

// LoadHistoryLinelocations loads the organization's HistoryLinelocations into the .R struct
func (o *Organization) LoadHistoryLinelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryLinelocations = nil

	related, err := o.HistoryLinelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryLinelocations = related
	return nil
}

// LoadHistoryLinelocations loads the organization's HistoryLinelocations into the .R struct
func (os OrganizationSlice) LoadHistoryLinelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyLinelocations, err := os.HistoryLinelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryLinelocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyLinelocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryLinelocations = append(o.R.HistoryLinelocations, rel)
		}
	}

	return nil
}

// LoadHistoryLocationtrackings loads the organization's HistoryLocationtrackings into the .R struct
func (o *Organization) LoadHistoryLocationtrackings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryLocationtrackings = nil

	related, err := o.HistoryLocationtrackings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryLocationtrackings = related
	return nil
}

// LoadHistoryLocationtrackings loads the organization's HistoryLocationtrackings into the .R struct
func (os OrganizationSlice) LoadHistoryLocationtrackings(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyLocationtrackings, err := os.HistoryLocationtrackings(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryLocationtrackings = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyLocationtrackings {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryLocationtrackings = append(o.R.HistoryLocationtrackings, rel)
		}
	}

	return nil
}

// LoadHistoryMosquitoinspections loads the organization's HistoryMosquitoinspections into the .R struct
func (o *Organization) LoadHistoryMosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryMosquitoinspections = nil

	related, err := o.HistoryMosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryMosquitoinspections = related
	return nil
}

// LoadHistoryMosquitoinspections loads the organization's HistoryMosquitoinspections into the .R struct
func (os OrganizationSlice) LoadHistoryMosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyMosquitoinspections, err := os.HistoryMosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryMosquitoinspections = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyMosquitoinspections {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryMosquitoinspections = append(o.R.HistoryMosquitoinspections, rel)
		}
	}

	return nil
}

// LoadHistoryPointlocations loads the organization's HistoryPointlocations into the .R struct
func (o *Organization) LoadHistoryPointlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryPointlocations = nil

	related, err := o.HistoryPointlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryPointlocations = related
	return nil
}

// LoadHistoryPointlocations loads the organization's HistoryPointlocations into the .R struct
func (os OrganizationSlice) LoadHistoryPointlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyPointlocations, err := os.HistoryPointlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryPointlocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyPointlocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryPointlocations = append(o.R.HistoryPointlocations, rel)
		}
	}

	return nil
}

// LoadHistoryPolygonlocations loads the organization's HistoryPolygonlocations into the .R struct
func (o *Organization) LoadHistoryPolygonlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryPolygonlocations = nil

	related, err := o.HistoryPolygonlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryPolygonlocations = related
	return nil
}

// LoadHistoryPolygonlocations loads the organization's HistoryPolygonlocations into the .R struct
func (os OrganizationSlice) LoadHistoryPolygonlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyPolygonlocations, err := os.HistoryPolygonlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryPolygonlocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyPolygonlocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryPolygonlocations = append(o.R.HistoryPolygonlocations, rel)
		}
	}

	return nil
}

// LoadHistoryPools loads the organization's HistoryPools into the .R struct
func (o *Organization) LoadHistoryPools(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryPools = nil

	related, err := o.HistoryPools(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryPools = related
	return nil
}

// LoadHistoryPools loads the organization's HistoryPools into the .R struct
func (os OrganizationSlice) LoadHistoryPools(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyPools, err := os.HistoryPools(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryPools = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyPools {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryPools = append(o.R.HistoryPools, rel)
		}
	}

	return nil
}

// LoadHistoryPooldetails loads the organization's HistoryPooldetails into the .R struct
func (o *Organization) LoadHistoryPooldetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryPooldetails = nil

	related, err := o.HistoryPooldetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryPooldetails = related
	return nil
}

// LoadHistoryPooldetails loads the organization's HistoryPooldetails into the .R struct
func (os OrganizationSlice) LoadHistoryPooldetails(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyPooldetails, err := os.HistoryPooldetails(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryPooldetails = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyPooldetails {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryPooldetails = append(o.R.HistoryPooldetails, rel)
		}
	}

	return nil
}

// LoadHistoryProposedtreatmentareas loads the organization's HistoryProposedtreatmentareas into the .R struct
func (o *Organization) LoadHistoryProposedtreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryProposedtreatmentareas = nil

	related, err := o.HistoryProposedtreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryProposedtreatmentareas = related
	return nil
}

// LoadHistoryProposedtreatmentareas loads the organization's HistoryProposedtreatmentareas into the .R struct
func (os OrganizationSlice) LoadHistoryProposedtreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyProposedtreatmentareas, err := os.HistoryProposedtreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryProposedtreatmentareas = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyProposedtreatmentareas {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryProposedtreatmentareas = append(o.R.HistoryProposedtreatmentareas, rel)
		}
	}

	return nil
}

// LoadHistoryQamosquitoinspections loads the organization's HistoryQamosquitoinspections into the .R struct
func (o *Organization) LoadHistoryQamosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryQamosquitoinspections = nil

	related, err := o.HistoryQamosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryQamosquitoinspections = related
	return nil
}

// LoadHistoryQamosquitoinspections loads the organization's HistoryQamosquitoinspections into the .R struct
func (os OrganizationSlice) LoadHistoryQamosquitoinspections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyQamosquitoinspections, err := os.HistoryQamosquitoinspections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryQamosquitoinspections = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyQamosquitoinspections {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryQamosquitoinspections = append(o.R.HistoryQamosquitoinspections, rel)
		}
	}

	return nil
}

// LoadHistoryRodentlocations loads the organization's HistoryRodentlocations into the .R struct
func (o *Organization) LoadHistoryRodentlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryRodentlocations = nil

	related, err := o.HistoryRodentlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryRodentlocations = related
	return nil
}

// LoadHistoryRodentlocations loads the organization's HistoryRodentlocations into the .R struct
func (os OrganizationSlice) LoadHistoryRodentlocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyRodentlocations, err := os.HistoryRodentlocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryRodentlocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyRodentlocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryRodentlocations = append(o.R.HistoryRodentlocations, rel)
		}
	}

	return nil
}

// LoadHistorySamplecollections loads the organization's HistorySamplecollections into the .R struct
func (o *Organization) LoadHistorySamplecollections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistorySamplecollections = nil

	related, err := o.HistorySamplecollections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistorySamplecollections = related
	return nil
}

// LoadHistorySamplecollections loads the organization's HistorySamplecollections into the .R struct
func (os OrganizationSlice) LoadHistorySamplecollections(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historySamplecollections, err := os.HistorySamplecollections(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistorySamplecollections = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historySamplecollections {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistorySamplecollections = append(o.R.HistorySamplecollections, rel)
		}
	}

	return nil
}

// LoadHistorySamplelocations loads the organization's HistorySamplelocations into the .R struct
func (o *Organization) LoadHistorySamplelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistorySamplelocations = nil

	related, err := o.HistorySamplelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistorySamplelocations = related
	return nil
}

// LoadHistorySamplelocations loads the organization's HistorySamplelocations into the .R struct
func (os OrganizationSlice) LoadHistorySamplelocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historySamplelocations, err := os.HistorySamplelocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistorySamplelocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historySamplelocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistorySamplelocations = append(o.R.HistorySamplelocations, rel)
		}
	}

	return nil
}

// LoadHistoryServicerequests loads the organization's HistoryServicerequests into the .R struct
func (o *Organization) LoadHistoryServicerequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryServicerequests = nil

	related, err := o.HistoryServicerequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryServicerequests = related
	return nil
}

// LoadHistoryServicerequests loads the organization's HistoryServicerequests into the .R struct
func (os OrganizationSlice) LoadHistoryServicerequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyServicerequests, err := os.HistoryServicerequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryServicerequests = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyServicerequests {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryServicerequests = append(o.R.HistoryServicerequests, rel)
		}
	}

	return nil
}

// LoadHistorySpeciesabundances loads the organization's HistorySpeciesabundances into the .R struct
func (o *Organization) LoadHistorySpeciesabundances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistorySpeciesabundances = nil

	related, err := o.HistorySpeciesabundances(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistorySpeciesabundances = related
	return nil
}

// LoadHistorySpeciesabundances loads the organization's HistorySpeciesabundances into the .R struct
func (os OrganizationSlice) LoadHistorySpeciesabundances(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historySpeciesabundances, err := os.HistorySpeciesabundances(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistorySpeciesabundances = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historySpeciesabundances {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistorySpeciesabundances = append(o.R.HistorySpeciesabundances, rel)
		}
	}

	return nil
}

// LoadHistoryStormdrains loads the organization's HistoryStormdrains into the .R struct
func (o *Organization) LoadHistoryStormdrains(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryStormdrains = nil

	related, err := o.HistoryStormdrains(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryStormdrains = related
	return nil
}

// LoadHistoryStormdrains loads the organization's HistoryStormdrains into the .R struct
func (os OrganizationSlice) LoadHistoryStormdrains(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyStormdrains, err := os.HistoryStormdrains(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryStormdrains = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyStormdrains {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryStormdrains = append(o.R.HistoryStormdrains, rel)
		}
	}

	return nil
}

// LoadHistoryTimecards loads the organization's HistoryTimecards into the .R struct
func (o *Organization) LoadHistoryTimecards(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryTimecards = nil

	related, err := o.HistoryTimecards(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryTimecards = related
	return nil
}

// LoadHistoryTimecards loads the organization's HistoryTimecards into the .R struct
func (os OrganizationSlice) LoadHistoryTimecards(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyTimecards, err := os.HistoryTimecards(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryTimecards = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyTimecards {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryTimecards = append(o.R.HistoryTimecards, rel)
		}
	}

	return nil
}

// LoadHistoryTrapdata loads the organization's HistoryTrapdata into the .R struct
func (o *Organization) LoadHistoryTrapdata(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryTrapdata = nil

	related, err := o.HistoryTrapdata(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryTrapdata = related
	return nil
}

// LoadHistoryTrapdata loads the organization's HistoryTrapdata into the .R struct
func (os OrganizationSlice) LoadHistoryTrapdata(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyTrapdata, err := os.HistoryTrapdata(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryTrapdata = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyTrapdata {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryTrapdata = append(o.R.HistoryTrapdata, rel)
		}
	}

	return nil
}

// LoadHistoryTraplocations loads the organization's HistoryTraplocations into the .R struct
func (o *Organization) LoadHistoryTraplocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryTraplocations = nil

	related, err := o.HistoryTraplocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryTraplocations = related
	return nil
}

// LoadHistoryTraplocations loads the organization's HistoryTraplocations into the .R struct
func (os OrganizationSlice) LoadHistoryTraplocations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyTraplocations, err := os.HistoryTraplocations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryTraplocations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyTraplocations {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryTraplocations = append(o.R.HistoryTraplocations, rel)
		}
	}

	return nil
}

// LoadHistoryTreatments loads the organization's HistoryTreatments into the .R struct
func (o *Organization) LoadHistoryTreatments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryTreatments = nil

	related, err := o.HistoryTreatments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryTreatments = related
	return nil
}

// LoadHistoryTreatments loads the organization's HistoryTreatments into the .R struct
func (os OrganizationSlice) LoadHistoryTreatments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyTreatments, err := os.HistoryTreatments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryTreatments = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyTreatments {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryTreatments = append(o.R.HistoryTreatments, rel)
		}
	}

	return nil
}

// LoadHistoryTreatmentareas loads the organization's HistoryTreatmentareas into the .R struct
func (o *Organization) LoadHistoryTreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryTreatmentareas = nil

	related, err := o.HistoryTreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryTreatmentareas = related
	return nil
}

// LoadHistoryTreatmentareas loads the organization's HistoryTreatmentareas into the .R struct
func (os OrganizationSlice) LoadHistoryTreatmentareas(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyTreatmentareas, err := os.HistoryTreatmentareas(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryTreatmentareas = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyTreatmentareas {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryTreatmentareas = append(o.R.HistoryTreatmentareas, rel)
		}
	}

	return nil
}

// LoadHistoryZones loads the organization's HistoryZones into the .R struct
func (o *Organization) LoadHistoryZones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryZones = nil

	related, err := o.HistoryZones(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryZones = related
	return nil
}

// LoadHistoryZones loads the organization's HistoryZones into the .R struct
func (os OrganizationSlice) LoadHistoryZones(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyZones, err := os.HistoryZones(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryZones = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyZones {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryZones = append(o.R.HistoryZones, rel)
		}
	}

	return nil
}

// LoadHistoryZones2s loads the organization's HistoryZones2s into the .R struct
func (o *Organization) LoadHistoryZones2s(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.HistoryZones2s = nil

	related, err := o.HistoryZones2s(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.HistoryZones2s = related
	return nil
}

// LoadHistoryZones2s loads the organization's HistoryZones2s into the .R struct
func (os OrganizationSlice) LoadHistoryZones2s(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	historyZones2s, err := os.HistoryZones2s(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.HistoryZones2s = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range historyZones2s {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.HistoryZones2s = append(o.R.HistoryZones2s, rel)
		}
	}

	return nil
}

// LoadUser loads the organization's User into the .R struct
func (o *Organization) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.User = nil

	related, err := o.User(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Organization = o
	}

	o.R.User = related
	return nil
}

// LoadUser loads the organization's User into the .R struct
func (os OrganizationSlice) LoadUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.User(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.User = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range users {

			if !rel.OrganizationID.IsValue() {
				continue
			}
			if !(rel.OrganizationID.IsValue() && o.ID == rel.OrganizationID.MustGet()) {
				continue
			}

			rel.R.Organization = o

			o.R.User = append(o.R.User, rel)
		}
	}

	return nil
}

type organizationJoins[Q dialect.Joinable] struct {
	typ                            string
	FSContainerrelates             modAs[Q, fsContainerrelateColumns]
	FSFieldscoutinglogs            modAs[Q, fsFieldscoutinglogColumns]
	FSHabitatrelates               modAs[Q, fsHabitatrelateColumns]
	FSInspectionsamples            modAs[Q, fsInspectionsampleColumns]
	FSInspectionsampledetails      modAs[Q, fsInspectionsampledetailColumns]
	FSLinelocations                modAs[Q, fsLinelocationColumns]
	FSLocationtrackings            modAs[Q, fsLocationtrackingColumns]
	FSMosquitoinspections          modAs[Q, fsMosquitoinspectionColumns]
	FSPointlocations               modAs[Q, fsPointlocationColumns]
	FSPolygonlocations             modAs[Q, fsPolygonlocationColumns]
	FSPools                        modAs[Q, fsPoolColumns]
	FSPooldetails                  modAs[Q, fsPooldetailColumns]
	FSProposedtreatmentareas       modAs[Q, fsProposedtreatmentareaColumns]
	FSQamosquitoinspections        modAs[Q, fsQamosquitoinspectionColumns]
	FSRodentlocations              modAs[Q, fsRodentlocationColumns]
	FSSamplecollections            modAs[Q, fsSamplecollectionColumns]
	FSSamplelocations              modAs[Q, fsSamplelocationColumns]
	FSServicerequests              modAs[Q, fsServicerequestColumns]
	FSSpeciesabundances            modAs[Q, fsSpeciesabundanceColumns]
	FSStormdrains                  modAs[Q, fsStormdrainColumns]
	FSTimecards                    modAs[Q, fsTimecardColumns]
	FSTrapdata                     modAs[Q, fsTrapdatumColumns]
	FSTraplocations                modAs[Q, fsTraplocationColumns]
	FSTreatments                   modAs[Q, fsTreatmentColumns]
	FSTreatmentareas               modAs[Q, fsTreatmentareaColumns]
	FSZones                        modAs[Q, fsZoneColumns]
	FSZones2s                      modAs[Q, fsZones2Columns]
	HistoryContainerrelates        modAs[Q, historyContainerrelateColumns]
	HistoryFieldscoutinglogs       modAs[Q, historyFieldscoutinglogColumns]
	HistoryHabitatrelates          modAs[Q, historyHabitatrelateColumns]
	HistoryInspectionsamples       modAs[Q, historyInspectionsampleColumns]
	HistoryInspectionsampledetails modAs[Q, historyInspectionsampledetailColumns]
	HistoryLinelocations           modAs[Q, historyLinelocationColumns]
	HistoryLocationtrackings       modAs[Q, historyLocationtrackingColumns]
	HistoryMosquitoinspections     modAs[Q, historyMosquitoinspectionColumns]
	HistoryPointlocations          modAs[Q, historyPointlocationColumns]
	HistoryPolygonlocations        modAs[Q, historyPolygonlocationColumns]
	HistoryPools                   modAs[Q, historyPoolColumns]
	HistoryPooldetails             modAs[Q, historyPooldetailColumns]
	HistoryProposedtreatmentareas  modAs[Q, historyProposedtreatmentareaColumns]
	HistoryQamosquitoinspections   modAs[Q, historyQamosquitoinspectionColumns]
	HistoryRodentlocations         modAs[Q, historyRodentlocationColumns]
	HistorySamplecollections       modAs[Q, historySamplecollectionColumns]
	HistorySamplelocations         modAs[Q, historySamplelocationColumns]
	HistoryServicerequests         modAs[Q, historyServicerequestColumns]
	HistorySpeciesabundances       modAs[Q, historySpeciesabundanceColumns]
	HistoryStormdrains             modAs[Q, historyStormdrainColumns]
	HistoryTimecards               modAs[Q, historyTimecardColumns]
	HistoryTrapdata                modAs[Q, historyTrapdatumColumns]
	HistoryTraplocations           modAs[Q, historyTraplocationColumns]
	HistoryTreatments              modAs[Q, historyTreatmentColumns]
	HistoryTreatmentareas          modAs[Q, historyTreatmentareaColumns]
	HistoryZones                   modAs[Q, historyZoneColumns]
	HistoryZones2s                 modAs[Q, historyZones2Columns]
	User                           modAs[Q, userColumns]
}

func (j organizationJoins[Q]) aliasedAs(alias string) organizationJoins[Q] {
	return buildOrganizationJoins[Q](buildOrganizationColumns(alias), j.typ)
}

func buildOrganizationJoins[Q dialect.Joinable](cols organizationColumns, typ string) organizationJoins[Q] {
	return organizationJoins[Q]{
		typ: typ,
		FSContainerrelates: modAs[Q, fsContainerrelateColumns]{
			c: FSContainerrelates.Columns,
			f: func(to fsContainerrelateColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSContainerrelates.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSFieldscoutinglogs: modAs[Q, fsFieldscoutinglogColumns]{
			c: FSFieldscoutinglogs.Columns,
			f: func(to fsFieldscoutinglogColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSFieldscoutinglogs.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSHabitatrelates: modAs[Q, fsHabitatrelateColumns]{
			c: FSHabitatrelates.Columns,
			f: func(to fsHabitatrelateColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSHabitatrelates.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSInspectionsamples: modAs[Q, fsInspectionsampleColumns]{
			c: FSInspectionsamples.Columns,
			f: func(to fsInspectionsampleColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSInspectionsamples.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSInspectionsampledetails: modAs[Q, fsInspectionsampledetailColumns]{
			c: FSInspectionsampledetails.Columns,
			f: func(to fsInspectionsampledetailColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSInspectionsampledetails.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSLinelocations: modAs[Q, fsLinelocationColumns]{
			c: FSLinelocations.Columns,
			f: func(to fsLinelocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSLinelocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSLocationtrackings: modAs[Q, fsLocationtrackingColumns]{
			c: FSLocationtrackings.Columns,
			f: func(to fsLocationtrackingColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSLocationtrackings.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSMosquitoinspections: modAs[Q, fsMosquitoinspectionColumns]{
			c: FSMosquitoinspections.Columns,
			f: func(to fsMosquitoinspectionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSMosquitoinspections.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSPointlocations: modAs[Q, fsPointlocationColumns]{
			c: FSPointlocations.Columns,
			f: func(to fsPointlocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSPointlocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSPolygonlocations: modAs[Q, fsPolygonlocationColumns]{
			c: FSPolygonlocations.Columns,
			f: func(to fsPolygonlocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSPolygonlocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSPools: modAs[Q, fsPoolColumns]{
			c: FSPools.Columns,
			f: func(to fsPoolColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSPools.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSPooldetails: modAs[Q, fsPooldetailColumns]{
			c: FSPooldetails.Columns,
			f: func(to fsPooldetailColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSPooldetails.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSProposedtreatmentareas: modAs[Q, fsProposedtreatmentareaColumns]{
			c: FSProposedtreatmentareas.Columns,
			f: func(to fsProposedtreatmentareaColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSProposedtreatmentareas.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSQamosquitoinspections: modAs[Q, fsQamosquitoinspectionColumns]{
			c: FSQamosquitoinspections.Columns,
			f: func(to fsQamosquitoinspectionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSQamosquitoinspections.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSRodentlocations: modAs[Q, fsRodentlocationColumns]{
			c: FSRodentlocations.Columns,
			f: func(to fsRodentlocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSRodentlocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSSamplecollections: modAs[Q, fsSamplecollectionColumns]{
			c: FSSamplecollections.Columns,
			f: func(to fsSamplecollectionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSSamplecollections.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSSamplelocations: modAs[Q, fsSamplelocationColumns]{
			c: FSSamplelocations.Columns,
			f: func(to fsSamplelocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSSamplelocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSServicerequests: modAs[Q, fsServicerequestColumns]{
			c: FSServicerequests.Columns,
			f: func(to fsServicerequestColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSServicerequests.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSSpeciesabundances: modAs[Q, fsSpeciesabundanceColumns]{
			c: FSSpeciesabundances.Columns,
			f: func(to fsSpeciesabundanceColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSSpeciesabundances.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSStormdrains: modAs[Q, fsStormdrainColumns]{
			c: FSStormdrains.Columns,
			f: func(to fsStormdrainColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSStormdrains.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSTimecards: modAs[Q, fsTimecardColumns]{
			c: FSTimecards.Columns,
			f: func(to fsTimecardColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSTimecards.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSTrapdata: modAs[Q, fsTrapdatumColumns]{
			c: FSTrapdata.Columns,
			f: func(to fsTrapdatumColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSTrapdata.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSTraplocations: modAs[Q, fsTraplocationColumns]{
			c: FSTraplocations.Columns,
			f: func(to fsTraplocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSTraplocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSTreatments: modAs[Q, fsTreatmentColumns]{
			c: FSTreatments.Columns,
			f: func(to fsTreatmentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSTreatments.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSTreatmentareas: modAs[Q, fsTreatmentareaColumns]{
			c: FSTreatmentareas.Columns,
			f: func(to fsTreatmentareaColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSTreatmentareas.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSZones: modAs[Q, fsZoneColumns]{
			c: FSZones.Columns,
			f: func(to fsZoneColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSZones.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FSZones2s: modAs[Q, fsZones2Columns]{
			c: FSZones2s.Columns,
			f: func(to fsZones2Columns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, FSZones2s.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryContainerrelates: modAs[Q, historyContainerrelateColumns]{
			c: HistoryContainerrelates.Columns,
			f: func(to historyContainerrelateColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryContainerrelates.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryFieldscoutinglogs: modAs[Q, historyFieldscoutinglogColumns]{
			c: HistoryFieldscoutinglogs.Columns,
			f: func(to historyFieldscoutinglogColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryFieldscoutinglogs.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryHabitatrelates: modAs[Q, historyHabitatrelateColumns]{
			c: HistoryHabitatrelates.Columns,
			f: func(to historyHabitatrelateColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryHabitatrelates.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryInspectionsamples: modAs[Q, historyInspectionsampleColumns]{
			c: HistoryInspectionsamples.Columns,
			f: func(to historyInspectionsampleColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryInspectionsamples.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryInspectionsampledetails: modAs[Q, historyInspectionsampledetailColumns]{
			c: HistoryInspectionsampledetails.Columns,
			f: func(to historyInspectionsampledetailColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryInspectionsampledetails.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryLinelocations: modAs[Q, historyLinelocationColumns]{
			c: HistoryLinelocations.Columns,
			f: func(to historyLinelocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryLinelocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryLocationtrackings: modAs[Q, historyLocationtrackingColumns]{
			c: HistoryLocationtrackings.Columns,
			f: func(to historyLocationtrackingColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryLocationtrackings.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryMosquitoinspections: modAs[Q, historyMosquitoinspectionColumns]{
			c: HistoryMosquitoinspections.Columns,
			f: func(to historyMosquitoinspectionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryMosquitoinspections.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryPointlocations: modAs[Q, historyPointlocationColumns]{
			c: HistoryPointlocations.Columns,
			f: func(to historyPointlocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryPointlocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryPolygonlocations: modAs[Q, historyPolygonlocationColumns]{
			c: HistoryPolygonlocations.Columns,
			f: func(to historyPolygonlocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryPolygonlocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryPools: modAs[Q, historyPoolColumns]{
			c: HistoryPools.Columns,
			f: func(to historyPoolColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryPools.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryPooldetails: modAs[Q, historyPooldetailColumns]{
			c: HistoryPooldetails.Columns,
			f: func(to historyPooldetailColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryPooldetails.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryProposedtreatmentareas: modAs[Q, historyProposedtreatmentareaColumns]{
			c: HistoryProposedtreatmentareas.Columns,
			f: func(to historyProposedtreatmentareaColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryProposedtreatmentareas.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryQamosquitoinspections: modAs[Q, historyQamosquitoinspectionColumns]{
			c: HistoryQamosquitoinspections.Columns,
			f: func(to historyQamosquitoinspectionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryQamosquitoinspections.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryRodentlocations: modAs[Q, historyRodentlocationColumns]{
			c: HistoryRodentlocations.Columns,
			f: func(to historyRodentlocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryRodentlocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistorySamplecollections: modAs[Q, historySamplecollectionColumns]{
			c: HistorySamplecollections.Columns,
			f: func(to historySamplecollectionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistorySamplecollections.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistorySamplelocations: modAs[Q, historySamplelocationColumns]{
			c: HistorySamplelocations.Columns,
			f: func(to historySamplelocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistorySamplelocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryServicerequests: modAs[Q, historyServicerequestColumns]{
			c: HistoryServicerequests.Columns,
			f: func(to historyServicerequestColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryServicerequests.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistorySpeciesabundances: modAs[Q, historySpeciesabundanceColumns]{
			c: HistorySpeciesabundances.Columns,
			f: func(to historySpeciesabundanceColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistorySpeciesabundances.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryStormdrains: modAs[Q, historyStormdrainColumns]{
			c: HistoryStormdrains.Columns,
			f: func(to historyStormdrainColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryStormdrains.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryTimecards: modAs[Q, historyTimecardColumns]{
			c: HistoryTimecards.Columns,
			f: func(to historyTimecardColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryTimecards.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryTrapdata: modAs[Q, historyTrapdatumColumns]{
			c: HistoryTrapdata.Columns,
			f: func(to historyTrapdatumColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryTrapdata.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryTraplocations: modAs[Q, historyTraplocationColumns]{
			c: HistoryTraplocations.Columns,
			f: func(to historyTraplocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryTraplocations.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryTreatments: modAs[Q, historyTreatmentColumns]{
			c: HistoryTreatments.Columns,
			f: func(to historyTreatmentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryTreatments.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryTreatmentareas: modAs[Q, historyTreatmentareaColumns]{
			c: HistoryTreatmentareas.Columns,
			f: func(to historyTreatmentareaColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryTreatmentareas.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryZones: modAs[Q, historyZoneColumns]{
			c: HistoryZones.Columns,
			f: func(to historyZoneColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryZones.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		HistoryZones2s: modAs[Q, historyZones2Columns]{
			c: HistoryZones2s.Columns,
			f: func(to historyZones2Columns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, HistoryZones2s.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		User: modAs[Q, userColumns]{
			c: Users.Columns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.OrganizationID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
	}
}
