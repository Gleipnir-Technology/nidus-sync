// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// FSTreatment is an object representing the database table.
type FSTreatment struct {
	OrganizationID       int32             `db:"organization_id" `
	Activity             null.Val[string]  `db:"activity" `
	Areaunit             null.Val[string]  `db:"areaunit" `
	Avetemp              null.Val[float64] `db:"avetemp" `
	Barrierrouteid       null.Val[string]  `db:"barrierrouteid" `
	Cbcount              null.Val[int16]   `db:"cbcount" `
	Comments             null.Val[string]  `db:"comments" `
	Containercount       null.Val[int16]   `db:"containercount" `
	Creationdate         null.Val[int64]   `db:"creationdate" `
	Creator              null.Val[string]  `db:"creator" `
	Enddatetime          null.Val[int64]   `db:"enddatetime" `
	Equiptype            null.Val[string]  `db:"equiptype" `
	Editdate             null.Val[int64]   `db:"editdate" `
	Editor               null.Val[string]  `db:"editor" `
	Fieldtech            null.Val[string]  `db:"fieldtech" `
	Flowrate             null.Val[float64] `db:"flowrate" `
	Globalid             string            `db:"globalid" `
	Habitat              null.Val[string]  `db:"habitat" `
	InspID               null.Val[string]  `db:"insp_id" `
	Invloc               null.Val[string]  `db:"invloc" `
	Linelocid            null.Val[string]  `db:"linelocid" `
	Locationname         null.Val[string]  `db:"locationname" `
	Method               null.Val[string]  `db:"method" `
	Objectid             int32             `db:"objectid,pk" `
	Pointlocid           null.Val[string]  `db:"pointlocid" `
	Polygonlocid         null.Val[string]  `db:"polygonlocid" `
	Product              null.Val[string]  `db:"product" `
	Ptaid                null.Val[string]  `db:"ptaid" `
	Qty                  null.Val[float64] `db:"qty" `
	Qtyunit              null.Val[string]  `db:"qtyunit" `
	Raingauge            null.Val[float64] `db:"raingauge" `
	Recordstatus         null.Val[int16]   `db:"recordstatus" `
	Reviewed             null.Val[int16]   `db:"reviewed" `
	Reviewedby           null.Val[string]  `db:"reviewedby" `
	Revieweddate         null.Val[int64]   `db:"revieweddate" `
	Sdid                 null.Val[string]  `db:"sdid" `
	Sitecond             null.Val[string]  `db:"sitecond" `
	Srid                 null.Val[string]  `db:"srid" `
	Startdatetime        null.Val[int64]   `db:"startdatetime" `
	Targetspecies        null.Val[string]  `db:"targetspecies" `
	Tirecount            null.Val[int16]   `db:"tirecount" `
	Treatacres           null.Val[float64] `db:"treatacres" `
	Treatarea            null.Val[float64] `db:"treatarea" `
	Treathectares        null.Val[float64] `db:"treathectares" `
	Treatmenthours       null.Val[float64] `db:"treatmenthours" `
	Treatmentlength      null.Val[float64] `db:"treatmentlength" `
	Treatmentlengthunits null.Val[string]  `db:"treatmentlengthunits" `
	Totalcostprodcut     null.Val[float64] `db:"totalcostprodcut" `
	Ulvrouteid           null.Val[string]  `db:"ulvrouteid" `
	Warningoverride      null.Val[int16]   `db:"warningoverride" `
	Winddir              null.Val[string]  `db:"winddir" `
	Windspeed            null.Val[float64] `db:"windspeed" `
	Zone                 null.Val[string]  `db:"zone" `
	Zone2                null.Val[string]  `db:"zone2" `
	GeometryX            null.Val[float64] `db:"geometry_x" `
	GeometryY            null.Val[float64] `db:"geometry_y" `
	TempSitecond         null.Val[string]  `db:"temp_sitecond" `
	Updated              time.Time         `db:"updated" `

	R fsTreatmentR `db:"-" `
}

// FSTreatmentSlice is an alias for a slice of pointers to FSTreatment.
// This should almost always be used instead of []*FSTreatment.
type FSTreatmentSlice []*FSTreatment

// FSTreatments contains methods to work with the fs_treatment table
var FSTreatments = psql.NewTablex[*FSTreatment, FSTreatmentSlice, *FSTreatmentSetter]("", "fs_treatment", buildFSTreatmentColumns("fs_treatment"))

// FSTreatmentsQuery is a query on the fs_treatment table
type FSTreatmentsQuery = *psql.ViewQuery[*FSTreatment, FSTreatmentSlice]

// fsTreatmentR is where relationships are stored.
type fsTreatmentR struct {
	Organization *Organization // fs_treatment.fs_treatment_organization_id_fkey
}

func buildFSTreatmentColumns(alias string) fsTreatmentColumns {
	return fsTreatmentColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"organization_id", "activity", "areaunit", "avetemp", "barrierrouteid", "cbcount", "comments", "containercount", "creationdate", "creator", "enddatetime", "equiptype", "editdate", "editor", "fieldtech", "flowrate", "globalid", "habitat", "insp_id", "invloc", "linelocid", "locationname", "method", "objectid", "pointlocid", "polygonlocid", "product", "ptaid", "qty", "qtyunit", "raingauge", "recordstatus", "reviewed", "reviewedby", "revieweddate", "sdid", "sitecond", "srid", "startdatetime", "targetspecies", "tirecount", "treatacres", "treatarea", "treathectares", "treatmenthours", "treatmentlength", "treatmentlengthunits", "totalcostprodcut", "ulvrouteid", "warningoverride", "winddir", "windspeed", "zone", "zone2", "geometry_x", "geometry_y", "temp_sitecond", "updated",
		).WithParent("fs_treatment"),
		tableAlias:           alias,
		OrganizationID:       psql.Quote(alias, "organization_id"),
		Activity:             psql.Quote(alias, "activity"),
		Areaunit:             psql.Quote(alias, "areaunit"),
		Avetemp:              psql.Quote(alias, "avetemp"),
		Barrierrouteid:       psql.Quote(alias, "barrierrouteid"),
		Cbcount:              psql.Quote(alias, "cbcount"),
		Comments:             psql.Quote(alias, "comments"),
		Containercount:       psql.Quote(alias, "containercount"),
		Creationdate:         psql.Quote(alias, "creationdate"),
		Creator:              psql.Quote(alias, "creator"),
		Enddatetime:          psql.Quote(alias, "enddatetime"),
		Equiptype:            psql.Quote(alias, "equiptype"),
		Editdate:             psql.Quote(alias, "editdate"),
		Editor:               psql.Quote(alias, "editor"),
		Fieldtech:            psql.Quote(alias, "fieldtech"),
		Flowrate:             psql.Quote(alias, "flowrate"),
		Globalid:             psql.Quote(alias, "globalid"),
		Habitat:              psql.Quote(alias, "habitat"),
		InspID:               psql.Quote(alias, "insp_id"),
		Invloc:               psql.Quote(alias, "invloc"),
		Linelocid:            psql.Quote(alias, "linelocid"),
		Locationname:         psql.Quote(alias, "locationname"),
		Method:               psql.Quote(alias, "method"),
		Objectid:             psql.Quote(alias, "objectid"),
		Pointlocid:           psql.Quote(alias, "pointlocid"),
		Polygonlocid:         psql.Quote(alias, "polygonlocid"),
		Product:              psql.Quote(alias, "product"),
		Ptaid:                psql.Quote(alias, "ptaid"),
		Qty:                  psql.Quote(alias, "qty"),
		Qtyunit:              psql.Quote(alias, "qtyunit"),
		Raingauge:            psql.Quote(alias, "raingauge"),
		Recordstatus:         psql.Quote(alias, "recordstatus"),
		Reviewed:             psql.Quote(alias, "reviewed"),
		Reviewedby:           psql.Quote(alias, "reviewedby"),
		Revieweddate:         psql.Quote(alias, "revieweddate"),
		Sdid:                 psql.Quote(alias, "sdid"),
		Sitecond:             psql.Quote(alias, "sitecond"),
		Srid:                 psql.Quote(alias, "srid"),
		Startdatetime:        psql.Quote(alias, "startdatetime"),
		Targetspecies:        psql.Quote(alias, "targetspecies"),
		Tirecount:            psql.Quote(alias, "tirecount"),
		Treatacres:           psql.Quote(alias, "treatacres"),
		Treatarea:            psql.Quote(alias, "treatarea"),
		Treathectares:        psql.Quote(alias, "treathectares"),
		Treatmenthours:       psql.Quote(alias, "treatmenthours"),
		Treatmentlength:      psql.Quote(alias, "treatmentlength"),
		Treatmentlengthunits: psql.Quote(alias, "treatmentlengthunits"),
		Totalcostprodcut:     psql.Quote(alias, "totalcostprodcut"),
		Ulvrouteid:           psql.Quote(alias, "ulvrouteid"),
		Warningoverride:      psql.Quote(alias, "warningoverride"),
		Winddir:              psql.Quote(alias, "winddir"),
		Windspeed:            psql.Quote(alias, "windspeed"),
		Zone:                 psql.Quote(alias, "zone"),
		Zone2:                psql.Quote(alias, "zone2"),
		GeometryX:            psql.Quote(alias, "geometry_x"),
		GeometryY:            psql.Quote(alias, "geometry_y"),
		TempSitecond:         psql.Quote(alias, "temp_sitecond"),
		Updated:              psql.Quote(alias, "updated"),
	}
}

type fsTreatmentColumns struct {
	expr.ColumnsExpr
	tableAlias           string
	OrganizationID       psql.Expression
	Activity             psql.Expression
	Areaunit             psql.Expression
	Avetemp              psql.Expression
	Barrierrouteid       psql.Expression
	Cbcount              psql.Expression
	Comments             psql.Expression
	Containercount       psql.Expression
	Creationdate         psql.Expression
	Creator              psql.Expression
	Enddatetime          psql.Expression
	Equiptype            psql.Expression
	Editdate             psql.Expression
	Editor               psql.Expression
	Fieldtech            psql.Expression
	Flowrate             psql.Expression
	Globalid             psql.Expression
	Habitat              psql.Expression
	InspID               psql.Expression
	Invloc               psql.Expression
	Linelocid            psql.Expression
	Locationname         psql.Expression
	Method               psql.Expression
	Objectid             psql.Expression
	Pointlocid           psql.Expression
	Polygonlocid         psql.Expression
	Product              psql.Expression
	Ptaid                psql.Expression
	Qty                  psql.Expression
	Qtyunit              psql.Expression
	Raingauge            psql.Expression
	Recordstatus         psql.Expression
	Reviewed             psql.Expression
	Reviewedby           psql.Expression
	Revieweddate         psql.Expression
	Sdid                 psql.Expression
	Sitecond             psql.Expression
	Srid                 psql.Expression
	Startdatetime        psql.Expression
	Targetspecies        psql.Expression
	Tirecount            psql.Expression
	Treatacres           psql.Expression
	Treatarea            psql.Expression
	Treathectares        psql.Expression
	Treatmenthours       psql.Expression
	Treatmentlength      psql.Expression
	Treatmentlengthunits psql.Expression
	Totalcostprodcut     psql.Expression
	Ulvrouteid           psql.Expression
	Warningoverride      psql.Expression
	Winddir              psql.Expression
	Windspeed            psql.Expression
	Zone                 psql.Expression
	Zone2                psql.Expression
	GeometryX            psql.Expression
	GeometryY            psql.Expression
	TempSitecond         psql.Expression
	Updated              psql.Expression
}

func (c fsTreatmentColumns) Alias() string {
	return c.tableAlias
}

func (fsTreatmentColumns) AliasedAs(alias string) fsTreatmentColumns {
	return buildFSTreatmentColumns(alias)
}

// FSTreatmentSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type FSTreatmentSetter struct {
	OrganizationID       omit.Val[int32]       `db:"organization_id" `
	Activity             omitnull.Val[string]  `db:"activity" `
	Areaunit             omitnull.Val[string]  `db:"areaunit" `
	Avetemp              omitnull.Val[float64] `db:"avetemp" `
	Barrierrouteid       omitnull.Val[string]  `db:"barrierrouteid" `
	Cbcount              omitnull.Val[int16]   `db:"cbcount" `
	Comments             omitnull.Val[string]  `db:"comments" `
	Containercount       omitnull.Val[int16]   `db:"containercount" `
	Creationdate         omitnull.Val[int64]   `db:"creationdate" `
	Creator              omitnull.Val[string]  `db:"creator" `
	Enddatetime          omitnull.Val[int64]   `db:"enddatetime" `
	Equiptype            omitnull.Val[string]  `db:"equiptype" `
	Editdate             omitnull.Val[int64]   `db:"editdate" `
	Editor               omitnull.Val[string]  `db:"editor" `
	Fieldtech            omitnull.Val[string]  `db:"fieldtech" `
	Flowrate             omitnull.Val[float64] `db:"flowrate" `
	Globalid             omit.Val[string]      `db:"globalid" `
	Habitat              omitnull.Val[string]  `db:"habitat" `
	InspID               omitnull.Val[string]  `db:"insp_id" `
	Invloc               omitnull.Val[string]  `db:"invloc" `
	Linelocid            omitnull.Val[string]  `db:"linelocid" `
	Locationname         omitnull.Val[string]  `db:"locationname" `
	Method               omitnull.Val[string]  `db:"method" `
	Objectid             omit.Val[int32]       `db:"objectid,pk" `
	Pointlocid           omitnull.Val[string]  `db:"pointlocid" `
	Polygonlocid         omitnull.Val[string]  `db:"polygonlocid" `
	Product              omitnull.Val[string]  `db:"product" `
	Ptaid                omitnull.Val[string]  `db:"ptaid" `
	Qty                  omitnull.Val[float64] `db:"qty" `
	Qtyunit              omitnull.Val[string]  `db:"qtyunit" `
	Raingauge            omitnull.Val[float64] `db:"raingauge" `
	Recordstatus         omitnull.Val[int16]   `db:"recordstatus" `
	Reviewed             omitnull.Val[int16]   `db:"reviewed" `
	Reviewedby           omitnull.Val[string]  `db:"reviewedby" `
	Revieweddate         omitnull.Val[int64]   `db:"revieweddate" `
	Sdid                 omitnull.Val[string]  `db:"sdid" `
	Sitecond             omitnull.Val[string]  `db:"sitecond" `
	Srid                 omitnull.Val[string]  `db:"srid" `
	Startdatetime        omitnull.Val[int64]   `db:"startdatetime" `
	Targetspecies        omitnull.Val[string]  `db:"targetspecies" `
	Tirecount            omitnull.Val[int16]   `db:"tirecount" `
	Treatacres           omitnull.Val[float64] `db:"treatacres" `
	Treatarea            omitnull.Val[float64] `db:"treatarea" `
	Treathectares        omitnull.Val[float64] `db:"treathectares" `
	Treatmenthours       omitnull.Val[float64] `db:"treatmenthours" `
	Treatmentlength      omitnull.Val[float64] `db:"treatmentlength" `
	Treatmentlengthunits omitnull.Val[string]  `db:"treatmentlengthunits" `
	Totalcostprodcut     omitnull.Val[float64] `db:"totalcostprodcut" `
	Ulvrouteid           omitnull.Val[string]  `db:"ulvrouteid" `
	Warningoverride      omitnull.Val[int16]   `db:"warningoverride" `
	Winddir              omitnull.Val[string]  `db:"winddir" `
	Windspeed            omitnull.Val[float64] `db:"windspeed" `
	Zone                 omitnull.Val[string]  `db:"zone" `
	Zone2                omitnull.Val[string]  `db:"zone2" `
	GeometryX            omitnull.Val[float64] `db:"geometry_x" `
	GeometryY            omitnull.Val[float64] `db:"geometry_y" `
	TempSitecond         omitnull.Val[string]  `db:"temp_sitecond" `
	Updated              omit.Val[time.Time]   `db:"updated" `
}

func (s FSTreatmentSetter) SetColumns() []string {
	vals := make([]string, 0, 58)
	if s.OrganizationID.IsValue() {
		vals = append(vals, "organization_id")
	}
	if !s.Activity.IsUnset() {
		vals = append(vals, "activity")
	}
	if !s.Areaunit.IsUnset() {
		vals = append(vals, "areaunit")
	}
	if !s.Avetemp.IsUnset() {
		vals = append(vals, "avetemp")
	}
	if !s.Barrierrouteid.IsUnset() {
		vals = append(vals, "barrierrouteid")
	}
	if !s.Cbcount.IsUnset() {
		vals = append(vals, "cbcount")
	}
	if !s.Comments.IsUnset() {
		vals = append(vals, "comments")
	}
	if !s.Containercount.IsUnset() {
		vals = append(vals, "containercount")
	}
	if !s.Creationdate.IsUnset() {
		vals = append(vals, "creationdate")
	}
	if !s.Creator.IsUnset() {
		vals = append(vals, "creator")
	}
	if !s.Enddatetime.IsUnset() {
		vals = append(vals, "enddatetime")
	}
	if !s.Equiptype.IsUnset() {
		vals = append(vals, "equiptype")
	}
	if !s.Editdate.IsUnset() {
		vals = append(vals, "editdate")
	}
	if !s.Editor.IsUnset() {
		vals = append(vals, "editor")
	}
	if !s.Fieldtech.IsUnset() {
		vals = append(vals, "fieldtech")
	}
	if !s.Flowrate.IsUnset() {
		vals = append(vals, "flowrate")
	}
	if s.Globalid.IsValue() {
		vals = append(vals, "globalid")
	}
	if !s.Habitat.IsUnset() {
		vals = append(vals, "habitat")
	}
	if !s.InspID.IsUnset() {
		vals = append(vals, "insp_id")
	}
	if !s.Invloc.IsUnset() {
		vals = append(vals, "invloc")
	}
	if !s.Linelocid.IsUnset() {
		vals = append(vals, "linelocid")
	}
	if !s.Locationname.IsUnset() {
		vals = append(vals, "locationname")
	}
	if !s.Method.IsUnset() {
		vals = append(vals, "method")
	}
	if s.Objectid.IsValue() {
		vals = append(vals, "objectid")
	}
	if !s.Pointlocid.IsUnset() {
		vals = append(vals, "pointlocid")
	}
	if !s.Polygonlocid.IsUnset() {
		vals = append(vals, "polygonlocid")
	}
	if !s.Product.IsUnset() {
		vals = append(vals, "product")
	}
	if !s.Ptaid.IsUnset() {
		vals = append(vals, "ptaid")
	}
	if !s.Qty.IsUnset() {
		vals = append(vals, "qty")
	}
	if !s.Qtyunit.IsUnset() {
		vals = append(vals, "qtyunit")
	}
	if !s.Raingauge.IsUnset() {
		vals = append(vals, "raingauge")
	}
	if !s.Recordstatus.IsUnset() {
		vals = append(vals, "recordstatus")
	}
	if !s.Reviewed.IsUnset() {
		vals = append(vals, "reviewed")
	}
	if !s.Reviewedby.IsUnset() {
		vals = append(vals, "reviewedby")
	}
	if !s.Revieweddate.IsUnset() {
		vals = append(vals, "revieweddate")
	}
	if !s.Sdid.IsUnset() {
		vals = append(vals, "sdid")
	}
	if !s.Sitecond.IsUnset() {
		vals = append(vals, "sitecond")
	}
	if !s.Srid.IsUnset() {
		vals = append(vals, "srid")
	}
	if !s.Startdatetime.IsUnset() {
		vals = append(vals, "startdatetime")
	}
	if !s.Targetspecies.IsUnset() {
		vals = append(vals, "targetspecies")
	}
	if !s.Tirecount.IsUnset() {
		vals = append(vals, "tirecount")
	}
	if !s.Treatacres.IsUnset() {
		vals = append(vals, "treatacres")
	}
	if !s.Treatarea.IsUnset() {
		vals = append(vals, "treatarea")
	}
	if !s.Treathectares.IsUnset() {
		vals = append(vals, "treathectares")
	}
	if !s.Treatmenthours.IsUnset() {
		vals = append(vals, "treatmenthours")
	}
	if !s.Treatmentlength.IsUnset() {
		vals = append(vals, "treatmentlength")
	}
	if !s.Treatmentlengthunits.IsUnset() {
		vals = append(vals, "treatmentlengthunits")
	}
	if !s.Totalcostprodcut.IsUnset() {
		vals = append(vals, "totalcostprodcut")
	}
	if !s.Ulvrouteid.IsUnset() {
		vals = append(vals, "ulvrouteid")
	}
	if !s.Warningoverride.IsUnset() {
		vals = append(vals, "warningoverride")
	}
	if !s.Winddir.IsUnset() {
		vals = append(vals, "winddir")
	}
	if !s.Windspeed.IsUnset() {
		vals = append(vals, "windspeed")
	}
	if !s.Zone.IsUnset() {
		vals = append(vals, "zone")
	}
	if !s.Zone2.IsUnset() {
		vals = append(vals, "zone2")
	}
	if !s.GeometryX.IsUnset() {
		vals = append(vals, "geometry_x")
	}
	if !s.GeometryY.IsUnset() {
		vals = append(vals, "geometry_y")
	}
	if !s.TempSitecond.IsUnset() {
		vals = append(vals, "temp_sitecond")
	}
	if s.Updated.IsValue() {
		vals = append(vals, "updated")
	}
	return vals
}

func (s FSTreatmentSetter) Overwrite(t *FSTreatment) {
	if s.OrganizationID.IsValue() {
		t.OrganizationID = s.OrganizationID.MustGet()
	}
	if !s.Activity.IsUnset() {
		t.Activity = s.Activity.MustGetNull()
	}
	if !s.Areaunit.IsUnset() {
		t.Areaunit = s.Areaunit.MustGetNull()
	}
	if !s.Avetemp.IsUnset() {
		t.Avetemp = s.Avetemp.MustGetNull()
	}
	if !s.Barrierrouteid.IsUnset() {
		t.Barrierrouteid = s.Barrierrouteid.MustGetNull()
	}
	if !s.Cbcount.IsUnset() {
		t.Cbcount = s.Cbcount.MustGetNull()
	}
	if !s.Comments.IsUnset() {
		t.Comments = s.Comments.MustGetNull()
	}
	if !s.Containercount.IsUnset() {
		t.Containercount = s.Containercount.MustGetNull()
	}
	if !s.Creationdate.IsUnset() {
		t.Creationdate = s.Creationdate.MustGetNull()
	}
	if !s.Creator.IsUnset() {
		t.Creator = s.Creator.MustGetNull()
	}
	if !s.Enddatetime.IsUnset() {
		t.Enddatetime = s.Enddatetime.MustGetNull()
	}
	if !s.Equiptype.IsUnset() {
		t.Equiptype = s.Equiptype.MustGetNull()
	}
	if !s.Editdate.IsUnset() {
		t.Editdate = s.Editdate.MustGetNull()
	}
	if !s.Editor.IsUnset() {
		t.Editor = s.Editor.MustGetNull()
	}
	if !s.Fieldtech.IsUnset() {
		t.Fieldtech = s.Fieldtech.MustGetNull()
	}
	if !s.Flowrate.IsUnset() {
		t.Flowrate = s.Flowrate.MustGetNull()
	}
	if s.Globalid.IsValue() {
		t.Globalid = s.Globalid.MustGet()
	}
	if !s.Habitat.IsUnset() {
		t.Habitat = s.Habitat.MustGetNull()
	}
	if !s.InspID.IsUnset() {
		t.InspID = s.InspID.MustGetNull()
	}
	if !s.Invloc.IsUnset() {
		t.Invloc = s.Invloc.MustGetNull()
	}
	if !s.Linelocid.IsUnset() {
		t.Linelocid = s.Linelocid.MustGetNull()
	}
	if !s.Locationname.IsUnset() {
		t.Locationname = s.Locationname.MustGetNull()
	}
	if !s.Method.IsUnset() {
		t.Method = s.Method.MustGetNull()
	}
	if s.Objectid.IsValue() {
		t.Objectid = s.Objectid.MustGet()
	}
	if !s.Pointlocid.IsUnset() {
		t.Pointlocid = s.Pointlocid.MustGetNull()
	}
	if !s.Polygonlocid.IsUnset() {
		t.Polygonlocid = s.Polygonlocid.MustGetNull()
	}
	if !s.Product.IsUnset() {
		t.Product = s.Product.MustGetNull()
	}
	if !s.Ptaid.IsUnset() {
		t.Ptaid = s.Ptaid.MustGetNull()
	}
	if !s.Qty.IsUnset() {
		t.Qty = s.Qty.MustGetNull()
	}
	if !s.Qtyunit.IsUnset() {
		t.Qtyunit = s.Qtyunit.MustGetNull()
	}
	if !s.Raingauge.IsUnset() {
		t.Raingauge = s.Raingauge.MustGetNull()
	}
	if !s.Recordstatus.IsUnset() {
		t.Recordstatus = s.Recordstatus.MustGetNull()
	}
	if !s.Reviewed.IsUnset() {
		t.Reviewed = s.Reviewed.MustGetNull()
	}
	if !s.Reviewedby.IsUnset() {
		t.Reviewedby = s.Reviewedby.MustGetNull()
	}
	if !s.Revieweddate.IsUnset() {
		t.Revieweddate = s.Revieweddate.MustGetNull()
	}
	if !s.Sdid.IsUnset() {
		t.Sdid = s.Sdid.MustGetNull()
	}
	if !s.Sitecond.IsUnset() {
		t.Sitecond = s.Sitecond.MustGetNull()
	}
	if !s.Srid.IsUnset() {
		t.Srid = s.Srid.MustGetNull()
	}
	if !s.Startdatetime.IsUnset() {
		t.Startdatetime = s.Startdatetime.MustGetNull()
	}
	if !s.Targetspecies.IsUnset() {
		t.Targetspecies = s.Targetspecies.MustGetNull()
	}
	if !s.Tirecount.IsUnset() {
		t.Tirecount = s.Tirecount.MustGetNull()
	}
	if !s.Treatacres.IsUnset() {
		t.Treatacres = s.Treatacres.MustGetNull()
	}
	if !s.Treatarea.IsUnset() {
		t.Treatarea = s.Treatarea.MustGetNull()
	}
	if !s.Treathectares.IsUnset() {
		t.Treathectares = s.Treathectares.MustGetNull()
	}
	if !s.Treatmenthours.IsUnset() {
		t.Treatmenthours = s.Treatmenthours.MustGetNull()
	}
	if !s.Treatmentlength.IsUnset() {
		t.Treatmentlength = s.Treatmentlength.MustGetNull()
	}
	if !s.Treatmentlengthunits.IsUnset() {
		t.Treatmentlengthunits = s.Treatmentlengthunits.MustGetNull()
	}
	if !s.Totalcostprodcut.IsUnset() {
		t.Totalcostprodcut = s.Totalcostprodcut.MustGetNull()
	}
	if !s.Ulvrouteid.IsUnset() {
		t.Ulvrouteid = s.Ulvrouteid.MustGetNull()
	}
	if !s.Warningoverride.IsUnset() {
		t.Warningoverride = s.Warningoverride.MustGetNull()
	}
	if !s.Winddir.IsUnset() {
		t.Winddir = s.Winddir.MustGetNull()
	}
	if !s.Windspeed.IsUnset() {
		t.Windspeed = s.Windspeed.MustGetNull()
	}
	if !s.Zone.IsUnset() {
		t.Zone = s.Zone.MustGetNull()
	}
	if !s.Zone2.IsUnset() {
		t.Zone2 = s.Zone2.MustGetNull()
	}
	if !s.GeometryX.IsUnset() {
		t.GeometryX = s.GeometryX.MustGetNull()
	}
	if !s.GeometryY.IsUnset() {
		t.GeometryY = s.GeometryY.MustGetNull()
	}
	if !s.TempSitecond.IsUnset() {
		t.TempSitecond = s.TempSitecond.MustGetNull()
	}
	if s.Updated.IsValue() {
		t.Updated = s.Updated.MustGet()
	}
}

func (s *FSTreatmentSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return FSTreatments.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 58)
		if s.OrganizationID.IsValue() {
			vals[0] = psql.Arg(s.OrganizationID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if !s.Activity.IsUnset() {
			vals[1] = psql.Arg(s.Activity.MustGetNull())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if !s.Areaunit.IsUnset() {
			vals[2] = psql.Arg(s.Areaunit.MustGetNull())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Avetemp.IsUnset() {
			vals[3] = psql.Arg(s.Avetemp.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Barrierrouteid.IsUnset() {
			vals[4] = psql.Arg(s.Barrierrouteid.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.Cbcount.IsUnset() {
			vals[5] = psql.Arg(s.Cbcount.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.Comments.IsUnset() {
			vals[6] = psql.Arg(s.Comments.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.Containercount.IsUnset() {
			vals[7] = psql.Arg(s.Containercount.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.Creationdate.IsUnset() {
			vals[8] = psql.Arg(s.Creationdate.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if !s.Creator.IsUnset() {
			vals[9] = psql.Arg(s.Creator.MustGetNull())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.Enddatetime.IsUnset() {
			vals[10] = psql.Arg(s.Enddatetime.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if !s.Equiptype.IsUnset() {
			vals[11] = psql.Arg(s.Equiptype.MustGetNull())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if !s.Editdate.IsUnset() {
			vals[12] = psql.Arg(s.Editdate.MustGetNull())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if !s.Editor.IsUnset() {
			vals[13] = psql.Arg(s.Editor.MustGetNull())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if !s.Fieldtech.IsUnset() {
			vals[14] = psql.Arg(s.Fieldtech.MustGetNull())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if !s.Flowrate.IsUnset() {
			vals[15] = psql.Arg(s.Flowrate.MustGetNull())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if s.Globalid.IsValue() {
			vals[16] = psql.Arg(s.Globalid.MustGet())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if !s.Habitat.IsUnset() {
			vals[17] = psql.Arg(s.Habitat.MustGetNull())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if !s.InspID.IsUnset() {
			vals[18] = psql.Arg(s.InspID.MustGetNull())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.Invloc.IsUnset() {
			vals[19] = psql.Arg(s.Invloc.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		if !s.Linelocid.IsUnset() {
			vals[20] = psql.Arg(s.Linelocid.MustGetNull())
		} else {
			vals[20] = psql.Raw("DEFAULT")
		}

		if !s.Locationname.IsUnset() {
			vals[21] = psql.Arg(s.Locationname.MustGetNull())
		} else {
			vals[21] = psql.Raw("DEFAULT")
		}

		if !s.Method.IsUnset() {
			vals[22] = psql.Arg(s.Method.MustGetNull())
		} else {
			vals[22] = psql.Raw("DEFAULT")
		}

		if s.Objectid.IsValue() {
			vals[23] = psql.Arg(s.Objectid.MustGet())
		} else {
			vals[23] = psql.Raw("DEFAULT")
		}

		if !s.Pointlocid.IsUnset() {
			vals[24] = psql.Arg(s.Pointlocid.MustGetNull())
		} else {
			vals[24] = psql.Raw("DEFAULT")
		}

		if !s.Polygonlocid.IsUnset() {
			vals[25] = psql.Arg(s.Polygonlocid.MustGetNull())
		} else {
			vals[25] = psql.Raw("DEFAULT")
		}

		if !s.Product.IsUnset() {
			vals[26] = psql.Arg(s.Product.MustGetNull())
		} else {
			vals[26] = psql.Raw("DEFAULT")
		}

		if !s.Ptaid.IsUnset() {
			vals[27] = psql.Arg(s.Ptaid.MustGetNull())
		} else {
			vals[27] = psql.Raw("DEFAULT")
		}

		if !s.Qty.IsUnset() {
			vals[28] = psql.Arg(s.Qty.MustGetNull())
		} else {
			vals[28] = psql.Raw("DEFAULT")
		}

		if !s.Qtyunit.IsUnset() {
			vals[29] = psql.Arg(s.Qtyunit.MustGetNull())
		} else {
			vals[29] = psql.Raw("DEFAULT")
		}

		if !s.Raingauge.IsUnset() {
			vals[30] = psql.Arg(s.Raingauge.MustGetNull())
		} else {
			vals[30] = psql.Raw("DEFAULT")
		}

		if !s.Recordstatus.IsUnset() {
			vals[31] = psql.Arg(s.Recordstatus.MustGetNull())
		} else {
			vals[31] = psql.Raw("DEFAULT")
		}

		if !s.Reviewed.IsUnset() {
			vals[32] = psql.Arg(s.Reviewed.MustGetNull())
		} else {
			vals[32] = psql.Raw("DEFAULT")
		}

		if !s.Reviewedby.IsUnset() {
			vals[33] = psql.Arg(s.Reviewedby.MustGetNull())
		} else {
			vals[33] = psql.Raw("DEFAULT")
		}

		if !s.Revieweddate.IsUnset() {
			vals[34] = psql.Arg(s.Revieweddate.MustGetNull())
		} else {
			vals[34] = psql.Raw("DEFAULT")
		}

		if !s.Sdid.IsUnset() {
			vals[35] = psql.Arg(s.Sdid.MustGetNull())
		} else {
			vals[35] = psql.Raw("DEFAULT")
		}

		if !s.Sitecond.IsUnset() {
			vals[36] = psql.Arg(s.Sitecond.MustGetNull())
		} else {
			vals[36] = psql.Raw("DEFAULT")
		}

		if !s.Srid.IsUnset() {
			vals[37] = psql.Arg(s.Srid.MustGetNull())
		} else {
			vals[37] = psql.Raw("DEFAULT")
		}

		if !s.Startdatetime.IsUnset() {
			vals[38] = psql.Arg(s.Startdatetime.MustGetNull())
		} else {
			vals[38] = psql.Raw("DEFAULT")
		}

		if !s.Targetspecies.IsUnset() {
			vals[39] = psql.Arg(s.Targetspecies.MustGetNull())
		} else {
			vals[39] = psql.Raw("DEFAULT")
		}

		if !s.Tirecount.IsUnset() {
			vals[40] = psql.Arg(s.Tirecount.MustGetNull())
		} else {
			vals[40] = psql.Raw("DEFAULT")
		}

		if !s.Treatacres.IsUnset() {
			vals[41] = psql.Arg(s.Treatacres.MustGetNull())
		} else {
			vals[41] = psql.Raw("DEFAULT")
		}

		if !s.Treatarea.IsUnset() {
			vals[42] = psql.Arg(s.Treatarea.MustGetNull())
		} else {
			vals[42] = psql.Raw("DEFAULT")
		}

		if !s.Treathectares.IsUnset() {
			vals[43] = psql.Arg(s.Treathectares.MustGetNull())
		} else {
			vals[43] = psql.Raw("DEFAULT")
		}

		if !s.Treatmenthours.IsUnset() {
			vals[44] = psql.Arg(s.Treatmenthours.MustGetNull())
		} else {
			vals[44] = psql.Raw("DEFAULT")
		}

		if !s.Treatmentlength.IsUnset() {
			vals[45] = psql.Arg(s.Treatmentlength.MustGetNull())
		} else {
			vals[45] = psql.Raw("DEFAULT")
		}

		if !s.Treatmentlengthunits.IsUnset() {
			vals[46] = psql.Arg(s.Treatmentlengthunits.MustGetNull())
		} else {
			vals[46] = psql.Raw("DEFAULT")
		}

		if !s.Totalcostprodcut.IsUnset() {
			vals[47] = psql.Arg(s.Totalcostprodcut.MustGetNull())
		} else {
			vals[47] = psql.Raw("DEFAULT")
		}

		if !s.Ulvrouteid.IsUnset() {
			vals[48] = psql.Arg(s.Ulvrouteid.MustGetNull())
		} else {
			vals[48] = psql.Raw("DEFAULT")
		}

		if !s.Warningoverride.IsUnset() {
			vals[49] = psql.Arg(s.Warningoverride.MustGetNull())
		} else {
			vals[49] = psql.Raw("DEFAULT")
		}

		if !s.Winddir.IsUnset() {
			vals[50] = psql.Arg(s.Winddir.MustGetNull())
		} else {
			vals[50] = psql.Raw("DEFAULT")
		}

		if !s.Windspeed.IsUnset() {
			vals[51] = psql.Arg(s.Windspeed.MustGetNull())
		} else {
			vals[51] = psql.Raw("DEFAULT")
		}

		if !s.Zone.IsUnset() {
			vals[52] = psql.Arg(s.Zone.MustGetNull())
		} else {
			vals[52] = psql.Raw("DEFAULT")
		}

		if !s.Zone2.IsUnset() {
			vals[53] = psql.Arg(s.Zone2.MustGetNull())
		} else {
			vals[53] = psql.Raw("DEFAULT")
		}

		if !s.GeometryX.IsUnset() {
			vals[54] = psql.Arg(s.GeometryX.MustGetNull())
		} else {
			vals[54] = psql.Raw("DEFAULT")
		}

		if !s.GeometryY.IsUnset() {
			vals[55] = psql.Arg(s.GeometryY.MustGetNull())
		} else {
			vals[55] = psql.Raw("DEFAULT")
		}

		if !s.TempSitecond.IsUnset() {
			vals[56] = psql.Arg(s.TempSitecond.MustGetNull())
		} else {
			vals[56] = psql.Raw("DEFAULT")
		}

		if s.Updated.IsValue() {
			vals[57] = psql.Arg(s.Updated.MustGet())
		} else {
			vals[57] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s FSTreatmentSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s FSTreatmentSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 58)

	if s.OrganizationID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "organization_id")...),
			psql.Arg(s.OrganizationID),
		}})
	}

	if !s.Activity.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "activity")...),
			psql.Arg(s.Activity),
		}})
	}

	if !s.Areaunit.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "areaunit")...),
			psql.Arg(s.Areaunit),
		}})
	}

	if !s.Avetemp.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "avetemp")...),
			psql.Arg(s.Avetemp),
		}})
	}

	if !s.Barrierrouteid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "barrierrouteid")...),
			psql.Arg(s.Barrierrouteid),
		}})
	}

	if !s.Cbcount.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "cbcount")...),
			psql.Arg(s.Cbcount),
		}})
	}

	if !s.Comments.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "comments")...),
			psql.Arg(s.Comments),
		}})
	}

	if !s.Containercount.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "containercount")...),
			psql.Arg(s.Containercount),
		}})
	}

	if !s.Creationdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creationdate")...),
			psql.Arg(s.Creationdate),
		}})
	}

	if !s.Creator.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "creator")...),
			psql.Arg(s.Creator),
		}})
	}

	if !s.Enddatetime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "enddatetime")...),
			psql.Arg(s.Enddatetime),
		}})
	}

	if !s.Equiptype.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "equiptype")...),
			psql.Arg(s.Equiptype),
		}})
	}

	if !s.Editdate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editdate")...),
			psql.Arg(s.Editdate),
		}})
	}

	if !s.Editor.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "editor")...),
			psql.Arg(s.Editor),
		}})
	}

	if !s.Fieldtech.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "fieldtech")...),
			psql.Arg(s.Fieldtech),
		}})
	}

	if !s.Flowrate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "flowrate")...),
			psql.Arg(s.Flowrate),
		}})
	}

	if s.Globalid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "globalid")...),
			psql.Arg(s.Globalid),
		}})
	}

	if !s.Habitat.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "habitat")...),
			psql.Arg(s.Habitat),
		}})
	}

	if !s.InspID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "insp_id")...),
			psql.Arg(s.InspID),
		}})
	}

	if !s.Invloc.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "invloc")...),
			psql.Arg(s.Invloc),
		}})
	}

	if !s.Linelocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "linelocid")...),
			psql.Arg(s.Linelocid),
		}})
	}

	if !s.Locationname.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "locationname")...),
			psql.Arg(s.Locationname),
		}})
	}

	if !s.Method.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "method")...),
			psql.Arg(s.Method),
		}})
	}

	if s.Objectid.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "objectid")...),
			psql.Arg(s.Objectid),
		}})
	}

	if !s.Pointlocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "pointlocid")...),
			psql.Arg(s.Pointlocid),
		}})
	}

	if !s.Polygonlocid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "polygonlocid")...),
			psql.Arg(s.Polygonlocid),
		}})
	}

	if !s.Product.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "product")...),
			psql.Arg(s.Product),
		}})
	}

	if !s.Ptaid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "ptaid")...),
			psql.Arg(s.Ptaid),
		}})
	}

	if !s.Qty.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "qty")...),
			psql.Arg(s.Qty),
		}})
	}

	if !s.Qtyunit.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "qtyunit")...),
			psql.Arg(s.Qtyunit),
		}})
	}

	if !s.Raingauge.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "raingauge")...),
			psql.Arg(s.Raingauge),
		}})
	}

	if !s.Recordstatus.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "recordstatus")...),
			psql.Arg(s.Recordstatus),
		}})
	}

	if !s.Reviewed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reviewed")...),
			psql.Arg(s.Reviewed),
		}})
	}

	if !s.Reviewedby.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reviewedby")...),
			psql.Arg(s.Reviewedby),
		}})
	}

	if !s.Revieweddate.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "revieweddate")...),
			psql.Arg(s.Revieweddate),
		}})
	}

	if !s.Sdid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sdid")...),
			psql.Arg(s.Sdid),
		}})
	}

	if !s.Sitecond.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sitecond")...),
			psql.Arg(s.Sitecond),
		}})
	}

	if !s.Srid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "srid")...),
			psql.Arg(s.Srid),
		}})
	}

	if !s.Startdatetime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "startdatetime")...),
			psql.Arg(s.Startdatetime),
		}})
	}

	if !s.Targetspecies.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "targetspecies")...),
			psql.Arg(s.Targetspecies),
		}})
	}

	if !s.Tirecount.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "tirecount")...),
			psql.Arg(s.Tirecount),
		}})
	}

	if !s.Treatacres.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "treatacres")...),
			psql.Arg(s.Treatacres),
		}})
	}

	if !s.Treatarea.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "treatarea")...),
			psql.Arg(s.Treatarea),
		}})
	}

	if !s.Treathectares.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "treathectares")...),
			psql.Arg(s.Treathectares),
		}})
	}

	if !s.Treatmenthours.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "treatmenthours")...),
			psql.Arg(s.Treatmenthours),
		}})
	}

	if !s.Treatmentlength.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "treatmentlength")...),
			psql.Arg(s.Treatmentlength),
		}})
	}

	if !s.Treatmentlengthunits.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "treatmentlengthunits")...),
			psql.Arg(s.Treatmentlengthunits),
		}})
	}

	if !s.Totalcostprodcut.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "totalcostprodcut")...),
			psql.Arg(s.Totalcostprodcut),
		}})
	}

	if !s.Ulvrouteid.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "ulvrouteid")...),
			psql.Arg(s.Ulvrouteid),
		}})
	}

	if !s.Warningoverride.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "warningoverride")...),
			psql.Arg(s.Warningoverride),
		}})
	}

	if !s.Winddir.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "winddir")...),
			psql.Arg(s.Winddir),
		}})
	}

	if !s.Windspeed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "windspeed")...),
			psql.Arg(s.Windspeed),
		}})
	}

	if !s.Zone.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone")...),
			psql.Arg(s.Zone),
		}})
	}

	if !s.Zone2.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "zone2")...),
			psql.Arg(s.Zone2),
		}})
	}

	if !s.GeometryX.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_x")...),
			psql.Arg(s.GeometryX),
		}})
	}

	if !s.GeometryY.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "geometry_y")...),
			psql.Arg(s.GeometryY),
		}})
	}

	if !s.TempSitecond.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "temp_sitecond")...),
			psql.Arg(s.TempSitecond),
		}})
	}

	if s.Updated.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated")...),
			psql.Arg(s.Updated),
		}})
	}

	return exprs
}

// FindFSTreatment retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindFSTreatment(ctx context.Context, exec bob.Executor, ObjectidPK int32, cols ...string) (*FSTreatment, error) {
	if len(cols) == 0 {
		return FSTreatments.Query(
			sm.Where(FSTreatments.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		).One(ctx, exec)
	}

	return FSTreatments.Query(
		sm.Where(FSTreatments.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
		sm.Columns(FSTreatments.Columns.Only(cols...)),
	).One(ctx, exec)
}

// FSTreatmentExists checks the presence of a single record by primary key
func FSTreatmentExists(ctx context.Context, exec bob.Executor, ObjectidPK int32) (bool, error) {
	return FSTreatments.Query(
		sm.Where(FSTreatments.Columns.Objectid.EQ(psql.Arg(ObjectidPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after FSTreatment is retrieved from the database
func (o *FSTreatment) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FSTreatments.AfterSelectHooks.RunHooks(ctx, exec, FSTreatmentSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = FSTreatments.AfterInsertHooks.RunHooks(ctx, exec, FSTreatmentSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = FSTreatments.AfterUpdateHooks.RunHooks(ctx, exec, FSTreatmentSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = FSTreatments.AfterDeleteHooks.RunHooks(ctx, exec, FSTreatmentSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the FSTreatment
func (o *FSTreatment) primaryKeyVals() bob.Expression {
	return psql.Arg(o.Objectid)
}

func (o *FSTreatment) pkEQ() dialect.Expression {
	return psql.Quote("fs_treatment", "objectid").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the FSTreatment
func (o *FSTreatment) Update(ctx context.Context, exec bob.Executor, s *FSTreatmentSetter) error {
	v, err := FSTreatments.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single FSTreatment record with an executor
func (o *FSTreatment) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := FSTreatments.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the FSTreatment using the executor
func (o *FSTreatment) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := FSTreatments.Query(
		sm.Where(FSTreatments.Columns.Objectid.EQ(psql.Arg(o.Objectid))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after FSTreatmentSlice is retrieved from the database
func (o FSTreatmentSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = FSTreatments.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = FSTreatments.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = FSTreatments.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = FSTreatments.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o FSTreatmentSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("fs_treatment", "objectid").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o FSTreatmentSlice) copyMatchingRows(from ...*FSTreatment) {
	for i, old := range o {
		for _, new := range from {
			if new.Objectid != old.Objectid {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o FSTreatmentSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FSTreatments.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FSTreatment:
				o.copyMatchingRows(retrieved)
			case []*FSTreatment:
				o.copyMatchingRows(retrieved...)
			case FSTreatmentSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FSTreatment or a slice of FSTreatment
				// then run the AfterUpdateHooks on the slice
				_, err = FSTreatments.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o FSTreatmentSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return FSTreatments.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *FSTreatment:
				o.copyMatchingRows(retrieved)
			case []*FSTreatment:
				o.copyMatchingRows(retrieved...)
			case FSTreatmentSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a FSTreatment or a slice of FSTreatment
				// then run the AfterDeleteHooks on the slice
				_, err = FSTreatments.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o FSTreatmentSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals FSTreatmentSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FSTreatments.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o FSTreatmentSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := FSTreatments.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o FSTreatmentSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := FSTreatments.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// Organization starts a query for related objects on organization
func (o *FSTreatment) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	return Organizations.Query(append(mods,
		sm.Where(Organizations.Columns.ID.EQ(psql.Arg(o.OrganizationID))),
	)...)
}

func (os FSTreatmentSlice) Organization(mods ...bob.Mod[*dialect.SelectQuery]) OrganizationsQuery {
	pkOrganizationID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkOrganizationID = append(pkOrganizationID, o.OrganizationID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkOrganizationID), "integer[]")),
	))

	return Organizations.Query(append(mods,
		sm.Where(psql.Group(Organizations.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

func attachFSTreatmentOrganization0(ctx context.Context, exec bob.Executor, count int, fsTreatment0 *FSTreatment, organization1 *Organization) (*FSTreatment, error) {
	setter := &FSTreatmentSetter{
		OrganizationID: omit.From(organization1.ID),
	}

	err := fsTreatment0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachFSTreatmentOrganization0: %w", err)
	}

	return fsTreatment0, nil
}

func (fsTreatment0 *FSTreatment) InsertOrganization(ctx context.Context, exec bob.Executor, related *OrganizationSetter) error {
	var err error

	organization1, err := Organizations.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachFSTreatmentOrganization0(ctx, exec, 1, fsTreatment0, organization1)
	if err != nil {
		return err
	}

	fsTreatment0.R.Organization = organization1

	organization1.R.FSTreatments = append(organization1.R.FSTreatments, fsTreatment0)

	return nil
}

func (fsTreatment0 *FSTreatment) AttachOrganization(ctx context.Context, exec bob.Executor, organization1 *Organization) error {
	var err error

	_, err = attachFSTreatmentOrganization0(ctx, exec, 1, fsTreatment0, organization1)
	if err != nil {
		return err
	}

	fsTreatment0.R.Organization = organization1

	organization1.R.FSTreatments = append(organization1.R.FSTreatments, fsTreatment0)

	return nil
}

type fsTreatmentWhere[Q psql.Filterable] struct {
	OrganizationID       psql.WhereMod[Q, int32]
	Activity             psql.WhereNullMod[Q, string]
	Areaunit             psql.WhereNullMod[Q, string]
	Avetemp              psql.WhereNullMod[Q, float64]
	Barrierrouteid       psql.WhereNullMod[Q, string]
	Cbcount              psql.WhereNullMod[Q, int16]
	Comments             psql.WhereNullMod[Q, string]
	Containercount       psql.WhereNullMod[Q, int16]
	Creationdate         psql.WhereNullMod[Q, int64]
	Creator              psql.WhereNullMod[Q, string]
	Enddatetime          psql.WhereNullMod[Q, int64]
	Equiptype            psql.WhereNullMod[Q, string]
	Editdate             psql.WhereNullMod[Q, int64]
	Editor               psql.WhereNullMod[Q, string]
	Fieldtech            psql.WhereNullMod[Q, string]
	Flowrate             psql.WhereNullMod[Q, float64]
	Globalid             psql.WhereMod[Q, string]
	Habitat              psql.WhereNullMod[Q, string]
	InspID               psql.WhereNullMod[Q, string]
	Invloc               psql.WhereNullMod[Q, string]
	Linelocid            psql.WhereNullMod[Q, string]
	Locationname         psql.WhereNullMod[Q, string]
	Method               psql.WhereNullMod[Q, string]
	Objectid             psql.WhereMod[Q, int32]
	Pointlocid           psql.WhereNullMod[Q, string]
	Polygonlocid         psql.WhereNullMod[Q, string]
	Product              psql.WhereNullMod[Q, string]
	Ptaid                psql.WhereNullMod[Q, string]
	Qty                  psql.WhereNullMod[Q, float64]
	Qtyunit              psql.WhereNullMod[Q, string]
	Raingauge            psql.WhereNullMod[Q, float64]
	Recordstatus         psql.WhereNullMod[Q, int16]
	Reviewed             psql.WhereNullMod[Q, int16]
	Reviewedby           psql.WhereNullMod[Q, string]
	Revieweddate         psql.WhereNullMod[Q, int64]
	Sdid                 psql.WhereNullMod[Q, string]
	Sitecond             psql.WhereNullMod[Q, string]
	Srid                 psql.WhereNullMod[Q, string]
	Startdatetime        psql.WhereNullMod[Q, int64]
	Targetspecies        psql.WhereNullMod[Q, string]
	Tirecount            psql.WhereNullMod[Q, int16]
	Treatacres           psql.WhereNullMod[Q, float64]
	Treatarea            psql.WhereNullMod[Q, float64]
	Treathectares        psql.WhereNullMod[Q, float64]
	Treatmenthours       psql.WhereNullMod[Q, float64]
	Treatmentlength      psql.WhereNullMod[Q, float64]
	Treatmentlengthunits psql.WhereNullMod[Q, string]
	Totalcostprodcut     psql.WhereNullMod[Q, float64]
	Ulvrouteid           psql.WhereNullMod[Q, string]
	Warningoverride      psql.WhereNullMod[Q, int16]
	Winddir              psql.WhereNullMod[Q, string]
	Windspeed            psql.WhereNullMod[Q, float64]
	Zone                 psql.WhereNullMod[Q, string]
	Zone2                psql.WhereNullMod[Q, string]
	GeometryX            psql.WhereNullMod[Q, float64]
	GeometryY            psql.WhereNullMod[Q, float64]
	TempSitecond         psql.WhereNullMod[Q, string]
	Updated              psql.WhereMod[Q, time.Time]
}

func (fsTreatmentWhere[Q]) AliasedAs(alias string) fsTreatmentWhere[Q] {
	return buildFSTreatmentWhere[Q](buildFSTreatmentColumns(alias))
}

func buildFSTreatmentWhere[Q psql.Filterable](cols fsTreatmentColumns) fsTreatmentWhere[Q] {
	return fsTreatmentWhere[Q]{
		OrganizationID:       psql.Where[Q, int32](cols.OrganizationID),
		Activity:             psql.WhereNull[Q, string](cols.Activity),
		Areaunit:             psql.WhereNull[Q, string](cols.Areaunit),
		Avetemp:              psql.WhereNull[Q, float64](cols.Avetemp),
		Barrierrouteid:       psql.WhereNull[Q, string](cols.Barrierrouteid),
		Cbcount:              psql.WhereNull[Q, int16](cols.Cbcount),
		Comments:             psql.WhereNull[Q, string](cols.Comments),
		Containercount:       psql.WhereNull[Q, int16](cols.Containercount),
		Creationdate:         psql.WhereNull[Q, int64](cols.Creationdate),
		Creator:              psql.WhereNull[Q, string](cols.Creator),
		Enddatetime:          psql.WhereNull[Q, int64](cols.Enddatetime),
		Equiptype:            psql.WhereNull[Q, string](cols.Equiptype),
		Editdate:             psql.WhereNull[Q, int64](cols.Editdate),
		Editor:               psql.WhereNull[Q, string](cols.Editor),
		Fieldtech:            psql.WhereNull[Q, string](cols.Fieldtech),
		Flowrate:             psql.WhereNull[Q, float64](cols.Flowrate),
		Globalid:             psql.Where[Q, string](cols.Globalid),
		Habitat:              psql.WhereNull[Q, string](cols.Habitat),
		InspID:               psql.WhereNull[Q, string](cols.InspID),
		Invloc:               psql.WhereNull[Q, string](cols.Invloc),
		Linelocid:            psql.WhereNull[Q, string](cols.Linelocid),
		Locationname:         psql.WhereNull[Q, string](cols.Locationname),
		Method:               psql.WhereNull[Q, string](cols.Method),
		Objectid:             psql.Where[Q, int32](cols.Objectid),
		Pointlocid:           psql.WhereNull[Q, string](cols.Pointlocid),
		Polygonlocid:         psql.WhereNull[Q, string](cols.Polygonlocid),
		Product:              psql.WhereNull[Q, string](cols.Product),
		Ptaid:                psql.WhereNull[Q, string](cols.Ptaid),
		Qty:                  psql.WhereNull[Q, float64](cols.Qty),
		Qtyunit:              psql.WhereNull[Q, string](cols.Qtyunit),
		Raingauge:            psql.WhereNull[Q, float64](cols.Raingauge),
		Recordstatus:         psql.WhereNull[Q, int16](cols.Recordstatus),
		Reviewed:             psql.WhereNull[Q, int16](cols.Reviewed),
		Reviewedby:           psql.WhereNull[Q, string](cols.Reviewedby),
		Revieweddate:         psql.WhereNull[Q, int64](cols.Revieweddate),
		Sdid:                 psql.WhereNull[Q, string](cols.Sdid),
		Sitecond:             psql.WhereNull[Q, string](cols.Sitecond),
		Srid:                 psql.WhereNull[Q, string](cols.Srid),
		Startdatetime:        psql.WhereNull[Q, int64](cols.Startdatetime),
		Targetspecies:        psql.WhereNull[Q, string](cols.Targetspecies),
		Tirecount:            psql.WhereNull[Q, int16](cols.Tirecount),
		Treatacres:           psql.WhereNull[Q, float64](cols.Treatacres),
		Treatarea:            psql.WhereNull[Q, float64](cols.Treatarea),
		Treathectares:        psql.WhereNull[Q, float64](cols.Treathectares),
		Treatmenthours:       psql.WhereNull[Q, float64](cols.Treatmenthours),
		Treatmentlength:      psql.WhereNull[Q, float64](cols.Treatmentlength),
		Treatmentlengthunits: psql.WhereNull[Q, string](cols.Treatmentlengthunits),
		Totalcostprodcut:     psql.WhereNull[Q, float64](cols.Totalcostprodcut),
		Ulvrouteid:           psql.WhereNull[Q, string](cols.Ulvrouteid),
		Warningoverride:      psql.WhereNull[Q, int16](cols.Warningoverride),
		Winddir:              psql.WhereNull[Q, string](cols.Winddir),
		Windspeed:            psql.WhereNull[Q, float64](cols.Windspeed),
		Zone:                 psql.WhereNull[Q, string](cols.Zone),
		Zone2:                psql.WhereNull[Q, string](cols.Zone2),
		GeometryX:            psql.WhereNull[Q, float64](cols.GeometryX),
		GeometryY:            psql.WhereNull[Q, float64](cols.GeometryY),
		TempSitecond:         psql.WhereNull[Q, string](cols.TempSitecond),
		Updated:              psql.Where[Q, time.Time](cols.Updated),
	}
}

func (o *FSTreatment) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Organization":
		rel, ok := retrieved.(*Organization)
		if !ok {
			return fmt.Errorf("fsTreatment cannot load %T as %q", retrieved, name)
		}

		o.R.Organization = rel

		if rel != nil {
			rel.R.FSTreatments = FSTreatmentSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("fsTreatment has no relationship %q", name)
	}
}

type fsTreatmentPreloader struct {
	Organization func(...psql.PreloadOption) psql.Preloader
}

func buildFSTreatmentPreloader() fsTreatmentPreloader {
	return fsTreatmentPreloader{
		Organization: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Organization, OrganizationSlice](psql.PreloadRel{
				Name: "Organization",
				Sides: []psql.PreloadSide{
					{
						From:        FSTreatments,
						To:          Organizations,
						FromColumns: []string{"organization_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Organizations.Columns.Names(), opts...)
		},
	}
}

type fsTreatmentThenLoader[Q orm.Loadable] struct {
	Organization func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildFSTreatmentThenLoader[Q orm.Loadable]() fsTreatmentThenLoader[Q] {
	type OrganizationLoadInterface interface {
		LoadOrganization(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return fsTreatmentThenLoader[Q]{
		Organization: thenLoadBuilder[Q](
			"Organization",
			func(ctx context.Context, exec bob.Executor, retrieved OrganizationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrganization(ctx, exec, mods...)
			},
		),
	}
}

// LoadOrganization loads the fsTreatment's Organization into the .R struct
func (o *FSTreatment) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Organization = nil

	related, err := o.Organization(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.FSTreatments = FSTreatmentSlice{o}

	o.R.Organization = related
	return nil
}

// LoadOrganization loads the fsTreatment's Organization into the .R struct
func (os FSTreatmentSlice) LoadOrganization(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	organizations, err := os.Organization(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range organizations {

			if !(o.OrganizationID == rel.ID) {
				continue
			}

			rel.R.FSTreatments = append(rel.R.FSTreatments, o)

			o.R.Organization = rel
			break
		}
	}

	return nil
}

type fsTreatmentJoins[Q dialect.Joinable] struct {
	typ          string
	Organization modAs[Q, organizationColumns]
}

func (j fsTreatmentJoins[Q]) aliasedAs(alias string) fsTreatmentJoins[Q] {
	return buildFSTreatmentJoins[Q](buildFSTreatmentColumns(alias), j.typ)
}

func buildFSTreatmentJoins[Q dialect.Joinable](cols fsTreatmentColumns, typ string) fsTreatmentJoins[Q] {
	return fsTreatmentJoins[Q]{
		typ: typ,
		Organization: modAs[Q, organizationColumns]{
			c: Organizations.Columns,
			f: func(to organizationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Organizations.Name().As(to.Alias())).On(
						to.ID.EQ(cols.OrganizationID),
					))
				}

				return mods
			},
		},
	}
}
