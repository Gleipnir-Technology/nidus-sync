// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package sql

import (
	"context"
	_ "embed"
	"io"
	"iter"
	"time"

	enums "github.com/Gleipnir-Technology/nidus-sync/enums"
	"github.com/aarondl/opt/null"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/scan"
)

//go:embed user_by_username.bob.sql
var formattedQueries_user_by_username string

var userByUsernameSQL = formattedQueries_user_by_username[152:773]

type UserByUsernameQuery = orm.ModQuery[*dialect.SelectQuery, userByUsername, UserByUsernameRow, []UserByUsernameRow, userByUsernameTransformer]

func UserByUsername(Username string) *UserByUsernameQuery {
	var expressionTypArgs userByUsername

	expressionTypArgs.Username = psql.Arg(Username)

	return &UserByUsernameQuery{
		Query: orm.Query[userByUsername, UserByUsernameRow, []UserByUsernameRow, userByUsernameTransformer]{
			ExecQuery: orm.ExecQuery[userByUsername]{
				BaseQuery: bob.BaseQuery[userByUsername]{
					Expression: expressionTypArgs,
					Dialect:    dialect.Dialect,
					QueryType:  bob.QueryTypeSelect,
				},
			},
			Scanner: func(context.Context, []string) (func(*scan.Row) (any, error), func(any) (UserByUsernameRow, error)) {
				return func(row *scan.Row) (any, error) {
						var t UserByUsernameRow
						row.ScheduleScanByIndex(0, &t.ID)
						row.ScheduleScanByIndex(1, &t.ArcgisAccessToken)
						row.ScheduleScanByIndex(2, &t.ArcgisLicense)
						row.ScheduleScanByIndex(3, &t.ArcgisRefreshToken)
						row.ScheduleScanByIndex(4, &t.ArcgisRefreshTokenExpires)
						row.ScheduleScanByIndex(5, &t.ArcgisRole)
						row.ScheduleScanByIndex(6, &t.DisplayName)
						row.ScheduleScanByIndex(7, &t.Email)
						row.ScheduleScanByIndex(8, &t.OrganizationID)
						row.ScheduleScanByIndex(9, &t.Username)
						row.ScheduleScanByIndex(10, &t.PasswordHashType)
						row.ScheduleScanByIndex(11, &t.PasswordHash)
						return &t, nil
					}, func(v any) (UserByUsernameRow, error) {
						return *(v.(*UserByUsernameRow)), nil
					}
			},
		},
		Mod: bob.ModFunc[*dialect.SelectQuery](func(q *dialect.SelectQuery) {
			q.AppendSelect(expressionTypArgs.subExpr(7, 551))
			q.SetTable(expressionTypArgs.subExpr(557, 562))
			q.AppendWhere(expressionTypArgs.subExpr(570, 621))
		}),
	}
}

type UserByUsernameRow = struct {
	ID                        int32                             `db:"id"`
	ArcgisAccessToken         null.Val[string]                  `db:"arcgis_access_token"`
	ArcgisLicense             null.Val[enums.Arcgislicensetype] `db:"arcgis_license"`
	ArcgisRefreshToken        null.Val[string]                  `db:"arcgis_refresh_token"`
	ArcgisRefreshTokenExpires null.Val[time.Time]               `db:"arcgis_refresh_token_expires"`
	ArcgisRole                null.Val[string]                  `db:"arcgis_role"`
	DisplayName               string                            `db:"display_name"`
	Email                     null.Val[string]                  `db:"email"`
	OrganizationID            null.Val[int32]                   `db:"organization_id"`
	Username                  string                            `db:"username"`
	PasswordHashType          enums.Hashtype                    `db:"password_hash_type"`
	PasswordHash              string                            `db:"password_hash"`
}

type userByUsernameTransformer = bob.SliceTransformer[UserByUsernameRow, []UserByUsernameRow]

type userByUsername struct {
	Username bob.Expression
}

func (o userByUsername) args() iter.Seq[orm.ArgWithPosition] {
	return func(yield func(arg orm.ArgWithPosition) bool) {
		if !yield(orm.ArgWithPosition{
			Name:       "username",
			Start:      581,
			Stop:       583,
			Expression: o.Username,
		}) {
			return
		}
	}
}

func (o userByUsername) raw(from, to int) string {
	return userByUsernameSQL[from:to]
}

func (o userByUsername) subExpr(from, to int) bob.Expression {
	return orm.ArgsToExpression(userByUsernameSQL, from, to, o.args())
}

func (o userByUsername) WriteSQL(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
	return o.subExpr(0, len(userByUsernameSQL)).WriteSQL(ctx, w, d, start)
}
